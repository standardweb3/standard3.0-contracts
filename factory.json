{"language":"Solidity","sources":{"src/exchange/orderbooks/OrderbookFactory.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.24;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {Orderbook, IOrderbook} from \"./Orderbook.sol\";\nimport {CloneFactory} from \"../libraries/CloneFactory.sol\";\nimport {IOrderbookFactory} from \"../interfaces/IOrderbookFactory.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\ninterface IERC20 {\n    function symbol() external view returns (string memory);\n}\n\ncontract OrderbookFactory is IOrderbookFactory, Initializable {\n    // Orderbooks\n    address[] public allPairs;\n    /// Address of manager\n    address public override engine;\n    /// version number of impl\n    uint32 public version;\n    /// address of order impl\n    address public impl;\n    /// listing cost of pair, for each fee token.\n    mapping(string => mapping(address => uint256)) public listingCosts;\n\n    error InvalidAccess(address sender, address allowed);\n    error PairAlreadyExists(address base, address quote, address pair);\n    error SameBaseQuote(address base, address quote);\n\n    constructor() {}\n\n    function createBook(address base_, address quote_) external override returns (address orderbook) {\n        if (msg.sender != engine) {\n            revert InvalidAccess(msg.sender, engine);\n        }\n\n        if (base_ == quote_) {\n            revert SameBaseQuote(base_, quote_);\n        }\n\n        address pair = _predictAddress(base_, quote_);\n\n        // Check if the address has code\n        uint32 size;\n        assembly {\n            size := extcodesize(pair)\n        }\n\n        // If the address has code and it's a clone of impl, revert.\n        if (size > 0 || CloneFactory._isClone(impl, pair)) {\n            revert PairAlreadyExists(base_, quote_, pair);\n        }\n\n        address proxy = CloneFactory._createCloneWithSalt(impl, _getSalt(base_, quote_));\n        IOrderbook(proxy).initialize(allPairsLength(), base_, quote_, engine);\n        allPairs.push(proxy);\n        return (proxy);\n    }\n\n    function isClone(address vault) external view returns (bool cloned) {\n        cloned = CloneFactory._isClone(impl, vault);\n    }\n\n    function getPair(address base, address quote) external view override returns (address book) {\n        book = _predictAddress(base, quote);\n        return address(book).code.length > 0 ? book : address(0);\n    }\n\n    function getPairs(uint256 start, uint256 end) public view override returns (IOrderbookFactory.Pair[] memory) {\n        uint256 last = end > allPairs.length ? allPairs.length : end;\n        IOrderbookFactory.Pair[] memory pairs = new IOrderbookFactory.Pair[](last - start);\n        for (uint256 i = start; i < last; i++) {\n            (address base, address quote) = IOrderbook(allPairs[i]).getBaseQuote();\n            pairs[i] = Pair(base, quote);\n        }\n        return pairs;\n    }\n\n    function getPairsWithIds(uint256[] memory ids)\n        public\n        view\n        override\n        returns (IOrderbookFactory.Pair[] memory pairs)\n    {\n        pairs = new IOrderbookFactory.Pair[](ids.length);\n        for (uint256 i = 0; i < ids.length; i++) {\n            (address base, address quote) = IOrderbook(allPairs[i]).getBaseQuote();\n            pairs[i] = Pair(base, quote);\n        }\n        return pairs;\n    }\n\n    function getPairNames(uint256 start, uint256 end) external view override returns (string[] memory names) {\n        IOrderbookFactory.Pair[] memory pairs = getPairs(start, end);\n        names = new string[](pairs.length);\n        for (uint256 i = 0; i < pairs.length; i++) {\n            string memory baseName = IERC20(pairs[i].base).symbol();\n            string memory quoteName = IERC20(pairs[i].quote).symbol();\n            names[i] = string(abi.encodePacked(baseName, \"/\", quoteName));\n        }\n        return names;\n    }\n\n    function getPairNamesWithIds(uint256[] memory ids) external view override returns (string[] memory names) {\n        names = new string[](ids.length);\n        for (uint256 i = 0; i < ids.length; i++) {\n            (address base, address quote) = IOrderbook(allPairs[i]).getBaseQuote();\n            string memory baseName = IERC20(base).symbol();\n            string memory quoteName = IERC20(quote).symbol();\n            names[i] = string(abi.encodePacked(baseName, \"/\", quoteName));\n        }\n        return names;\n    }\n\n    function getBaseQuote(address orderbook) external view override returns (address base, address quote) {\n        return IOrderbook(orderbook).getBaseQuote();\n    }\n\n    /**\n     * @dev Initialize orderbook factory contract with engine address, reinitialize if engine is reset.\n     * @param engine_ The address of the engine contract\n     * @return address of pair implementation contract\n     */\n    function initialize(address engine_) public initializer returns (address) {\n        engine = engine_;\n        _createImpl();\n        return impl;\n    }\n\n    function allPairsLength() public view returns (uint256) {\n        return allPairs.length;\n    }\n\n    // Set immutable, consistant, one rule for orderbook implementation\n    function _createImpl() internal {\n        address addr;\n        bytes memory bytecode = type(Orderbook).creationCode;\n        bytes32 salt = keccak256(abi.encodePacked(\"orderbook\", version));\n        assembly {\n            addr := create2(0, add(bytecode, 0x20), mload(bytecode), salt)\n            if iszero(extcodesize(addr)) { revert(0, 0) }\n        }\n        impl = addr;\n    }\n\n    function _predictAddress(address base_, address quote_) internal view returns (address) {\n        bytes32 salt = _getSalt(base_, quote_);\n        return CloneFactory.predictAddressWithSalt(address(this), impl, salt);\n    }\n\n    function _getSalt(address base_, address quote_) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(base_, quote_));\n    }\n\n    function getByteCode() external view returns (bytes memory bytecode) {\n        return CloneFactory.getBytecode(impl);\n    }\n\n    function getListingCost(string memory terminal, address payment) external view returns (uint256) {\n        return listingCosts[terminal][payment];\n    }\n\n    //  Set up listing cost for each token, each pair creates 2GB of data in a month, costing 0.1 ETH\n    function setListingCost(string memory terminal, address payment, uint256 amount) external returns (uint256) {\n        if (msg.sender != engine) {\n            revert InvalidAccess(msg.sender, engine);\n        }\n        listingCosts[terminal][payment] = amount;\n        return amount;\n    }\n}\n"},"lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/access/AccessControl.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"./IAccessControl.sol\";\nimport {Context} from \"../utils/Context.sol\";\nimport {IERC165, ERC165} from \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` from `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"},"src/exchange/orderbooks/Orderbook.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.24;\n\nimport {IOrderbook} from \"../interfaces/IOrderbook.sol\";\nimport {Initializable} from \"../../security/Initializable.sol\";\nimport {TransferHelper} from \"../libraries/TransferHelper.sol\";\nimport {ExchangeLinkedList} from \"../libraries/ExchangeLinkedList.sol\";\nimport {ExchangeOrderbook} from \"../libraries/ExchangeOrderbook.sol\";\nimport {IMatchingEngine} from \"../interfaces/IMatchingEngine.sol\";\n\ninterface IWETHMinimal {\n    function WETH() external view returns (address);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function withdraw(uint256) external;\n}\n\ncontract Orderbook is IOrderbook, Initializable {\n    using ExchangeLinkedList for ExchangeLinkedList.PriceLinkedList;\n    using ExchangeOrderbook for ExchangeOrderbook.OrderStorage;\n\n    uint32 public constant DENOM = 100000000;\n\n    // Pair Struct\n    struct Pair {\n        uint256 id;\n        address base;\n        address quote;\n        address engine;\n    }\n\n    Pair private pair;\n\n    uint64 private decDiff;\n    bool private baseBquote;\n\n    ExchangeLinkedList.PriceLinkedList private priceLists;\n    ExchangeOrderbook.OrderStorage private _askOrders;\n    ExchangeOrderbook.OrderStorage private _bidOrders;\n\n    error InvalidDecimals(uint8 base, uint8 quote);\n    error InvalidAccess(address sender, address allowed);\n    error PriceIsZero(uint256 price);\n\n    function initialize(\n        uint256 id_,\n        address base_,\n        address quote_,\n        address engine_\n    ) external initializer {\n        uint8 baseD = TransferHelper.decimals(base_);\n        uint8 quoteD = TransferHelper.decimals(quote_);\n        if (baseD > 18 || quoteD > 18) {\n            revert InvalidDecimals(baseD, quoteD);\n        }\n        (uint8 diff, bool baseBquote_) = _absdiff(baseD, quoteD);\n        decDiff = uint64(10 ** diff);\n        baseBquote = baseBquote_;\n        pair = Pair(id_, base_, quote_, engine_);\n    }\n\n    modifier onlyEngine() {\n        if (msg.sender != pair.engine) {\n            revert InvalidAccess(msg.sender, pair.engine);\n        }\n        _;\n    }\n\n    function setLmp(uint256 price) external onlyEngine {\n        if (price == 0) revert PriceIsZero(price);\n        priceLists._setLmp(price);\n    }\n\n    function placeAsk(\n        address owner,\n        uint256 price,\n        uint256 amount\n    ) external onlyEngine returns (uint32 id, bool foundDmt) {\n        // clear empty head\n        clearEmptyHead(false);\n        (id, foundDmt) = _askOrders._createOrder(owner, price, amount);\n        // check if the price is new in the list. if not, insert id to the list\n        if (_askOrders._isEmpty(price)) {\n            priceLists._insert(false, price);\n        }\n        _askOrders._insertId(price, id, amount);\n        return (id, foundDmt);\n    }\n\n    function placeBid(\n        address owner,\n        uint256 price,\n        uint256 amount\n    ) external onlyEngine returns (uint32 id, bool foundDmt) {\n        // clear empty head\n        clearEmptyHead(true);\n        (id, foundDmt) = _bidOrders._createOrder(owner, price, amount);\n        // check if the price is new in the list. if not, insert id to the list\n        if (_bidOrders._isEmpty(price)) {\n            priceLists._insert(true, price);\n        }\n        _bidOrders._insertId(price, id, amount);\n        return (id, foundDmt);\n    }\n\n    function removeDmt(\n        bool isBid\n    ) external onlyEngine returns (ExchangeOrderbook.Order memory order) {\n        // get dormant order\n        order = isBid ? _bidOrders.dormantOrder : _askOrders.dormantOrder;\n\n        isBid\n            ? _sendFunds(pair.quote, order.owner, order.depositAmount, false)\n            : _sendFunds(pair.base, order.owner, order.depositAmount, false);\n\n        // check if the dormant order was the only one order in the list of the price after deleting on order renewal\n        if (isEmpty(isBid, order.price)) {\n            priceLists._delete(isBid, order.price);\n        }\n\n        // free memory for dormant order\n        isBid ? delete _bidOrders.dormantOrder : delete _askOrders.dormantOrder;\n        return order;\n    }\n\n    function cancelOrder(\n        bool isBid,\n        uint32 orderId,\n        address owner\n    ) external onlyEngine returns (uint256 remaining) {\n        // check order owner\n        ExchangeOrderbook.Order memory order = isBid\n            ? _bidOrders._getOrder(orderId)\n            : _askOrders._getOrder(orderId);\n\n        // check before the price had an order not being empty\n        bool wasEmpty = isEmpty(isBid, order.price);\n\n        if (order.owner != owner) {\n            revert InvalidAccess(owner, order.owner);\n        }\n\n        uint256 deletePrice = isBid\n            ? _bidOrders._deleteOrder(orderId)\n            : _askOrders._deleteOrder(orderId);\n        isBid\n            ? _sendFunds(pair.quote, owner, order.depositAmount, false)\n            : _sendFunds(pair.base, owner, order.depositAmount, false);\n\n        // check if the canceled order was the only one order in the list\n        if (!wasEmpty && deletePrice != 0) {\n            priceLists._delete(isBid, order.price);\n        }\n\n        return (order.depositAmount);\n    }\n\n    function execute(\n        uint32 orderId,\n        bool isBid,\n        address sender,\n        uint256 amount,\n        bool clear\n    )\n        external\n        onlyEngine\n        returns (IMatchingEngine.OrderMatch memory orderMatch)\n    {\n        ExchangeOrderbook.Order memory order = isBid\n            ? _bidOrders._getOrder(orderId)\n            : _askOrders._getOrder(orderId);\n        uint256 converted = convert(order.price, amount, isBid);\n        uint256 dust = convert(order.price, 1, isBid);\n        uint256 baseTakerFee;\n        uint256 quoteTakerFee;\n        // if isBid == true, sender is matching ask order with bid order(i.e. selling base to receive quote), otherwise sender is matching bid order with ask order(i.e. buying base with quote)\n        if (isBid) {\n            // decrease remaining amount of order\n            (uint256 withDust, uint256 deletePrice) = _bidOrders._decreaseOrder(\n                orderId,\n                converted,\n                dust,\n                clear\n            );\n            // sender is matching ask order for base asset with quote asset\n            baseTakerFee = _sendFunds(pair.base, order.owner, amount, false);\n            // send converted amount of quote asset from owner to sender\n            quoteTakerFee = _sendFunds(pair.quote, sender, withDust, true);\n            // delete price if price of the order is empty\n            if (deletePrice != 0) {\n                priceLists._delete(isBid, deletePrice);\n            }\n        }\n        // if the order is bid order on the base/quote pair\n        else {\n            // decrease remaining amount of order\n            (uint256 withDust, uint256 deletePrice) = _askOrders._decreaseOrder(\n                orderId,\n                converted,\n                dust,\n                clear\n            );\n            // sender is matching bid order for quote asset with base asset\n            // send deposited amount of quote asset from sender to owner\n            quoteTakerFee = _sendFunds(pair.quote, order.owner, amount, false);\n            // send converted amount of base asset from owner to sender\n            baseTakerFee = _sendFunds(pair.base, sender, withDust, true);\n            // delete price if price of the order is empty\n            if (deletePrice != 0) {\n                priceLists._delete(isBid, deletePrice);\n            }\n        }\n        return\n            IMatchingEngine.OrderMatch(\n                order.owner,\n                baseTakerFee,\n                quoteTakerFee\n            );\n    }\n\n    function clearEmptyHead(bool isBid) public returns (uint256 head) {\n        head = isBid ? priceLists._bidHead() : priceLists._askHead();\n        uint32 orderId = isBid\n            ? _bidOrders._head(head)\n            : _askOrders._head(head);\n        while (orderId == 0 && head != 0) {\n            orderId = isBid ? _bidOrders._head(head) : _askOrders._head(head);\n            if (orderId == 0) {\n                head = priceLists._clearHead(isBid);\n            }\n        }\n        return head;\n    }\n\n    function fpop(\n        bool isBid,\n        uint256 price,\n        uint256 remaining\n    )\n        external\n        onlyEngine\n        returns (uint32 orderId, uint256 required, bool clear)\n    {\n        orderId = isBid ? _bidOrders._head(price) : _askOrders._head(price);\n        ExchangeOrderbook.Order memory order = isBid\n            ? _bidOrders._getOrder(orderId)\n            : _askOrders._getOrder(orderId);\n        required = convert(price, order.depositAmount, !isBid);\n        if (required <= remaining) {\n            isBid ? _bidOrders._fpop(price) : _askOrders._fpop(price);\n            if (isEmpty(isBid, price)) {\n                isBid\n                    ? priceLists.bidHead = priceLists._next(isBid, price)\n                    : priceLists.askHead = priceLists._next(isBid, price);\n            }\n            return (orderId, required, true); // clear order as required <=remaining\n        }\n        return (orderId, required, false);\n    }\n\n    function _sendFunds(\n        address token,\n        address to,\n        uint256 amount,\n        bool isTaker\n    ) internal returns (uint256 takerFeeAmount) {\n        address weth = IWETHMinimal(pair.engine).WETH();\n        if (isTaker) {\n            uint32 takerFee = IMatchingEngine(pair.engine).feeOf(\n                pair.base,\n                pair.quote,\n                to,\n                false\n            );\n            takerFeeAmount = (amount * takerFee) / DENOM;\n            address feeTo = IMatchingEngine(pair.engine).feeTo();\n            uint256 withoutTakerFee = amount - takerFeeAmount;\n            if (token == weth) {\n                IWETHMinimal(weth).withdraw(amount);\n                payable(feeTo).transfer(takerFeeAmount);\n                payable(to).transfer(withoutTakerFee);\n            } else {\n                TransferHelper.safeTransfer(token, feeTo, takerFeeAmount);\n                TransferHelper.safeTransfer(token, to, withoutTakerFee);\n            }\n            return takerFeeAmount;\n        } else {\n            if (token == weth) {\n                IWETHMinimal(weth).withdraw(amount);\n                payable(to).transfer(amount);\n            } else {\n                TransferHelper.safeTransfer(token, to, amount);\n            }\n            return 0;\n        }\n    }\n\n    function _absdiff(uint8 a, uint8 b) internal pure returns (uint8, bool) {\n        return (a > b ? a - b : b - a, a > b);\n    }\n\n    // get required amount for executing the order\n    function getRequired(\n        bool isBid,\n        uint256 price,\n        uint32 orderId\n    ) external view returns (uint256 required) {\n        ExchangeOrderbook.Order memory order = isBid\n            ? _bidOrders._getOrder(orderId)\n            : _askOrders._getOrder(orderId);\n        if (order.depositAmount == 0) {\n            return 0;\n        }\n        /* if ask, required base amount is quoteAmount / price,\n         * converting the number converting decimal from quote to base,\n         * otherwise quote amount is baseAmount * price, converting decimal from base to quote\n         */\n        return convert(price, order.depositAmount, isBid);\n    }\n\n    /////////////////////////////////\n    /// Price linked list methods ///\n    /////////////////////////////////\n\n    // last market price\n    function lmp() external view returns (uint256) {\n        return priceLists.lmp;\n    }\n\n    function heads() external view returns (uint256, uint256) {\n        return priceLists._heads();\n    }\n\n    function askHead() external view returns (uint256) {\n        return priceLists._askHead();\n    }\n\n    function bidHead() external view returns (uint256) {\n        return priceLists._bidHead();\n    }\n\n    function orderHead(\n        bool isBid,\n        uint256 price\n    ) external view returns (uint32) {\n        return isBid ? _bidOrders._head(price) : _askOrders._head(price);\n    }\n\n    function mktPrice() external view returns (uint256) {\n        return priceLists._mktPrice();\n    }\n\n    function getPrices(\n        bool isBid,\n        uint32 n\n    ) external view returns (uint256[] memory) {\n        return priceLists._getPrices(isBid, n);\n    }\n\n    function nextPrice(\n        bool isBid,\n        uint256 price\n    ) external view returns (uint256 next) {\n        return priceLists._next(isBid, price);\n    }\n\n    function nextOrder(\n        bool isBid,\n        uint256 price,\n        uint32 orderId\n    ) public view returns (uint32 next) {\n        return\n            isBid\n                ? _bidOrders._next(price, orderId)\n                : _askOrders._next(price, orderId);\n    }\n\n    function sfpop(\n        bool isBid,\n        uint256 price,\n        uint32 orderId,\n        bool isHead\n    ) external view returns (uint32 id, uint256 required, bool clear) {\n        id = isHead ? orderId : nextOrder(isBid, price, orderId);\n        ExchangeOrderbook.Order memory order = isBid\n            ? _bidOrders._getOrder(id)\n            : _askOrders._getOrder(id);\n        required = convert(price, order.depositAmount, !isBid);\n        return (id, required, id == 0);\n    }\n\n    function getPricesPaginated(\n        bool isBid,\n        uint32 start,\n        uint32 end\n    ) external view returns (uint256[] memory) {\n        return priceLists._getPricesPaginated(isBid, start, end);\n    }\n\n    function getOrderIds(\n        bool isBid,\n        uint256 price,\n        uint32 n\n    ) external view returns (uint32[] memory) {\n        return\n            isBid\n                ? _bidOrders._getOrderIds(price, n)\n                : _askOrders._getOrderIds(price, n);\n    }\n\n    function getOrders(\n        bool isBid,\n        uint256 price,\n        uint32 n\n    ) external view returns (ExchangeOrderbook.Order[] memory) {\n        return\n            isBid\n                ? _bidOrders._getOrders(price, n)\n                : _askOrders._getOrders(price, n);\n    }\n\n    function getOrdersPaginated(\n        bool isBid,\n        uint256 price,\n        uint32 start,\n        uint32 end\n    ) external view returns (ExchangeOrderbook.Order[] memory) {\n        return\n            isBid\n                ? _bidOrders._getOrdersPaginated(price, start, end)\n                : _askOrders._getOrdersPaginated(price, start, end);\n    }\n\n    function getOrder(\n        bool isBid,\n        uint32 orderId\n    ) external view returns (ExchangeOrderbook.Order memory) {\n        return\n            isBid\n                ? _bidOrders._getOrder(orderId)\n                : _askOrders._getOrder(orderId);\n    }\n\n    function getBaseQuote()\n        external\n        view\n        returns (address base, address quote)\n    {\n        return (pair.base, pair.quote);\n    }\n\n    /**\n     * @dev get asset value in quote asset if isBid is true, otherwise get asset value in base asset\n     * @param amount amount of asset in base asset if isBid is true, otherwise in quote asset\n     * @param isBid if true, get asset value in quote asset, otherwise get asset value in base asset\n     * @return converted asset value in quote asset if isBid is true, otherwise asset value in base asset\n     */\n    function assetValue(\n        uint256 amount,\n        bool isBid\n    ) external view returns (uint256 converted) {\n        return convert(priceLists._mktPrice(), amount, isBid);\n    }\n\n    function isEmpty(bool isBid, uint256 price) public view returns (bool) {\n        return isBid ? _bidOrders._isEmpty(price) : _askOrders._isEmpty(price);\n    }\n\n    function convertMarket(\n        uint256 amount,\n        bool isBid\n    ) external view returns (uint256 converted) {\n        return convert(priceLists.lmp, amount, isBid);\n    }\n\n    function convert(\n        uint256 price,\n        uint256 amount,\n        bool isBid\n    ) public view returns (uint256 converted) {\n        if (isBid) {\n            // convert base to quote\n            return\n                baseBquote\n                    ? ((amount * price) / 1e8) / decDiff\n                    : ((amount * price) / 1e8) * decDiff;\n        } else {\n            // convert quote to base\n            return\n                baseBquote\n                    ? ((amount * 1e8) / price) * decDiff\n                    : ((amount * 1e8) / price) / decDiff;\n        }\n    }\n\n    receive() external payable {\n        \n    }\n}\n"},"src/exchange/libraries/CloneFactory.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.24;\n\nlibrary CloneFactory {\n    function _createClone(address target) internal returns (address result) {\n        // convert address to 20 bytes\n        bytes20 targetBytes = bytes20(target);\n\n        // actual code //\n        // 3d602d80600a3d3981f3363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3\n\n        // creation code //\n        // copy runtime code into memory and return it\n        // 3d602d80600a3d3981f3\n\n        // runtime code //\n        // code to delegatecall to address\n        // 363d3d373d3d3d363d73 address 5af43d82803e903d91602b57fd5bf3\n\n        assembly {\n            /*\n            reads the 32 bytes of memory starting at pointer stored in 0x40\n\n            In solidity, the 0x40 slot in memory is special: it contains the \"free memory pointer\"\n            which points to the end of the currently allocated memory.\n            */\n            let clone := mload(0x40)\n            // store 32 bytes to memory starting at \"clone\"\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n\n            /*\n              |              20 bytes                |\n            0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\n                                                      ^\n                                                      pointer\n            */\n            // store 32 bytes to memory starting at \"clone\" + 20 bytes\n            // 0x14 = 20\n            mstore(add(clone, 0x14), targetBytes)\n\n            /*\n              |               20 bytes               |                 20 bytes              |\n            0x3d602d80600a3d3981f3363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe\n                                                                                              ^\n                                                                                              pointer\n            */\n            // store 32 bytes to memory starting at \"clone\" + 40 bytes\n            // 0x28 = 40\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n\n            /*\n              |               20 bytes               |                 20 bytes              |           15 bytes          |\n            0x3d602d80600a3d3981f3363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3\n            */\n            // create new contract\n            // send 0 Ether\n            // code starts at pointer stored in \"clone\"\n            // code size 0x37 (55 bytes)\n            result := create(0, clone, 0x37)\n        }\n    }\n\n    function _isClone(address target, address query) internal view returns (bool result) {\n        bytes20 targetBytes = bytes20(target);\n        assembly {\n            let clone := mload(0x40)\n            mstore(clone, 0x363d3d373d3d3d363d7300000000000000000000000000000000000000000000)\n            mstore(add(clone, 0xa), targetBytes)\n            mstore(add(clone, 0x1e), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n\n            let other := add(clone, 0x40)\n            extcodecopy(query, other, 0, 0x2d)\n            result := and(eq(mload(clone), mload(other)), eq(mload(add(clone, 0xd)), mload(add(other, 0xd))))\n        }\n    }\n\n    function _createCloneWithSalt(address target, bytes32 salt) internal returns (address result) {\n        bytes20 targetBytes = bytes20(target);\n        assembly {\n            let clone := mload(0x40)\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(clone, 0x14), targetBytes)\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n\n            // Use create2 with the provided salt\n            result := create2(0, clone, 0x37, salt)\n            if iszero(extcodesize(result)) { revert(0, 0) }\n        }\n    }\n\n    function predictAddressWithSalt(address deployer, address target, bytes32 salt) internal pure returns (address) {\n        // Create the expected bytecode of the minimal proxy\n        bytes memory bytecode =\n            abi.encodePacked(hex\"3d602d80600a3d3981f3363d3d373d3d3d363d73\", target, hex\"5af43d82803e903d91602b57fd5bf3\");\n\n        bytes32 bytecodeHash = keccak256(bytecode);\n\n        bytes32 _data = keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash));\n        return address(uint160(uint256(_data)));\n    }\n\n    function getBytecode(address target) internal pure returns (bytes memory bytecode) {\n        return\n            abi.encodePacked(hex\"3d602d80600a3d3981f3363d3d373d3d3d363d73\", target, hex\"5af43d82803e903d91602b57fd5bf3\");\n    }\n}\n"},"src/exchange/interfaces/IOrderbookFactory.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.24;\n\ninterface IOrderbookFactory {\n    struct Pair {\n        address base;\n        address quote;\n    }\n\n    function engine() external view returns (address);\n\n    function impl() external view returns (address);\n\n    function createBook(address base_, address quote_) external returns (address pair);\n\n    function setListingCost(string memory terminal, address payment, uint256 amount) external returns (uint256);\n\n    function isClone(address vault) external view returns (bool cloned);\n\n    function getPair(address base, address quote) external view returns (address book);\n\n    function getPairs(uint256 start, uint256 end) external view returns (Pair[] memory);\n\n    function getPairsWithIds(uint256[] memory ids) external view returns (Pair[] memory pairs);\n\n    function getPairNames(uint256 start, uint256 end) external view returns (string[] memory names);\n\n    function getPairNamesWithIds(uint256[] memory ids) external view returns (string[] memory names);\n\n    function getBaseQuote(address pair) external view returns (address base, address quote);\n\n    function getByteCode() external view returns (bytes memory bytecode);\n\n    function getListingCost(string memory terminal, address payment) external view returns (uint256 amount);\n}\n"},"lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/proxy/utils/Initializable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n     *\n     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n     */\n    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n        return INITIALIZABLE_STORAGE;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        bytes32 slot = _initializableStorageSlot();\n        assembly {\n            $.slot := slot\n        }\n    }\n}\n"},"lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/access/IAccessControl.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (access/IAccessControl.sol)\n\npragma solidity >=0.8.4;\n\n/**\n * @dev External interface of AccessControl declared to support ERC-165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted to signal this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call. This account bears the admin role (for the granted role).\n     * Expected in cases where the role was granted using the internal {AccessControl-_grantRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"},"lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/Context.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"},"lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"},"src/exchange/interfaces/IOrderbook.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.24;\n\nimport {IMatchingEngine, ExchangeOrderbook} from \"./IMatchingEngine.sol\";\n\ninterface IOrderbook {\n    function initialize(uint256 id_, address base_, address quote_, address engine_) external;\n\n    function setLmp(uint256 price) external;\n\n    function placeAsk(address owner, uint256 price, uint256 amount) external returns (uint32 id, bool foundDmt);\n\n    function placeBid(address owner, uint256 price, uint256 amount) external returns (uint32 id, bool foundDmt);\n\n    function removeDmt(bool isBid) external returns (ExchangeOrderbook.Order memory order);\n\n    function cancelOrder(bool isBid, uint32 orderId, address owner) external returns (uint256 remaining);\n\n    function execute(uint32 orderId, bool isBid, address sender, uint256 amount, bool clear)\n        external\n        returns (IMatchingEngine.OrderMatch memory orderMatch);\n\n    function clearEmptyHead(bool isBid) external returns (uint256 head);\n\n    function fpop(bool isBid, uint256 price, uint256 remaining)\n        external\n        returns (uint32 orderId, uint256 required, bool clear);\n\n    function getRequired(bool isBid, uint256 price, uint32 orderId) external view returns (uint256 required);\n\n    function lmp() external view returns (uint256);\n\n    function heads() external view returns (uint256, uint256);\n\n    function askHead() external view returns (uint256);\n\n    function bidHead() external view returns (uint256);\n\n    function orderHead(bool isBid, uint256 price) external view returns (uint32);\n\n    function mktPrice() external view returns (uint256);\n\n    function getPrices(bool isBid, uint32 n) external view returns (uint256[] memory);\n\n    function nextPrice(bool isBid, uint256 price) external view returns (uint256 next);\n\n    function nextOrder(bool isBid, uint256 price, uint32 orderId) external view returns (uint32 next);\n\n    function sfpop(bool isBid, uint256 price, uint32 orderId, bool isHead)\n        external\n        view\n        returns (uint32 id, uint256 required, bool clear);\n\n    function getPricesPaginated(bool isBid, uint32 start, uint32 end) external view returns (uint256[] memory);\n\n    function getOrderIds(bool isBid, uint256 price, uint32 n) external view returns (uint32[] memory);\n\n    function getOrders(bool isBid, uint256 price, uint32 n) external view returns (ExchangeOrderbook.Order[] memory);\n\n    function getOrdersPaginated(bool isBid, uint256 price, uint32 start, uint32 end)\n        external\n        view\n        returns (ExchangeOrderbook.Order[] memory);\n\n    function getOrder(bool isBid, uint32 orderId) external view returns (ExchangeOrderbook.Order memory);\n\n    function getBaseQuote() external view returns (address base, address quote);\n\n    function assetValue(uint256 amount, bool isBid) external view returns (uint256 converted);\n\n    function isEmpty(bool isBid, uint256 price) external view returns (bool);\n\n    function convertMarket(uint256 amount, bool isBid) external view returns (uint256 converted);\n\n    function convert(uint256 price, uint256 amount, bool isBid) external view returns (uint256 converted);\n}\n"},"src/security/Initializable.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.24;\n\ncontract Initializable {\n    bool private _initialized = false;\n\n    modifier initializer() {\n        // solhint-disable-next-line reason-string\n        require(!_initialized);\n        _;\n        _initialized = true;\n    }\n\n    function initialized() external view returns (bool) {\n        return _initialized;\n    }\n}\n"},"src/exchange/libraries/TransferHelper.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.24;\n\nimport {ILSP7DigitalAsset} from \"@lukso/lsp7-contracts/contracts/ILSP7DigitalAsset.sol\";\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    struct TokenInfo {\n        address token;\n        uint8 decimals;\n        string name;\n        string symbol;\n        uint256 totalSupply;\n    }\n\n    function safeApprove(address token, address to, uint256 value) internal {\n        // bytes4(keccak256(bytes(\"approve(address,uint256)\")));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"AF\");\n    }\n\n    function safeTransfer(address token, address to, uint256 value) internal {\n        // bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TF\");\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint256 value) internal {\n        // bytes4(keccak256(bytes(\"transferFrom(address,address,uint256)\")));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TFF\");\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success,) = to.call{value: value}(new bytes(0));\n        require(success, \"ETF\");\n    }\n\n    function name(address token) internal view returns (string memory) {\n        // bytes4(keccak256(bytes(\"name()\")));\n        (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(0x06fdde03));\n        require(success, \"NF\");\n        return abi.decode(data, (string));\n    }\n\n    function symbol(address token) internal view returns (string memory) {\n        // bytes4(keccak256(bytes(\"symbol()\")));\n        (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(0x95d89b41));\n        require(success, \"SF\");\n        return abi.decode(data, (string));\n    }\n\n    function totalSupply(address token) internal view returns (uint256) {\n        // bytes4(keccak256(bytes(\"totalSupply()\")));\n        (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(0x18160ddd));\n        require(success, \"TSF\");\n        return abi.decode(data, (uint256));\n    }\n\n    function decimals(address token) internal view returns (uint8) {\n        // bytes4(keccak256(bytes(\"decimals()\")));\n        (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(0x313ce567));\n        require(success, \"DF\");\n        return abi.decode(data, (uint8));\n    }\n\n    function getTokenInfo(address token) internal view returns (TokenInfo memory tokenInfo) {\n        tokenInfo.token = token;\n        tokenInfo.name = name(token);\n        tokenInfo.symbol = symbol(token);\n        tokenInfo.totalSupply = totalSupply(token);\n        tokenInfo.decimals = decimals(token);\n        return tokenInfo;\n    }\n\n    function lsp7Transfer(address token, address from, address to, uint256 value) internal {\n        // bytes4(keccak256(bytes(\"transfer(address,address,uint256,bool,bytes)\")));\n        (bool success, bytes memory data) =\n            token.call(abi.encodeWithSelector(ILSP7DigitalAsset.transfer.selector, from, to, value, true, \"\"));\n\n        // Suggest using this function for abi-encoding\n        // (bool success, bytes memory data) = token.call(abi.encodeCall(ILSP7DigitalAsset.transfer, from, to, value, true, \"\"));\n        require(success && (data.length == 0), \"AF\");\n    }\n}\n"},"src/exchange/libraries/ExchangeLinkedList.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.24;\n\nlibrary ExchangeLinkedList {\n    error NoMatchPrice(uint256 askHead, uint256 bidHead, uint256 lmp);\n\n    struct PriceLinkedList {\n        /// Hashmap-style linked list of prices to route orders\n        // key: price, value: next_price (next_price > price)\n        mapping(uint256 => uint256) askPrices;\n        // key: price, value: next_price (next_price < price)\n        mapping(uint256 => uint256) bidPrices;\n        // Head of the bid price linked list(i.e. highest bid price)\n        uint256 askHead;\n        // Head of the ask price linked list(i.e. lowest ask price)\n        uint256 bidHead;\n        // Last matched price\n        uint256 lmp;\n    }\n\n    error ZeroPrice(uint256 price);\n    error NoHeadBelow(bool isBid, uint256 head);\n    error PriceOutOfRange(uint256 price, uint256 np);\n    error PriceNoneInRange(uint256 price, uint256 np);\n\n    function _setLmp(PriceLinkedList storage self, uint256 lmp_) internal {\n        self.lmp = lmp_;\n    }\n\n    function _heads(PriceLinkedList storage self) internal view returns (uint256, uint256) {\n        return (self.bidHead, self.askHead);\n    }\n\n    function _askHead(PriceLinkedList storage self) internal view returns (uint256) {\n        return self.askHead;\n    }\n\n    function _bidHead(PriceLinkedList storage self) internal view returns (uint256) {\n        return self.bidHead;\n    }\n\n    function _mktPrice(PriceLinkedList storage self) internal view returns (uint256) {\n        if (self.bidHead == 0 && self.askHead == 0) {\n            if (self.lmp == 0) {\n                revert NoMatchPrice(self.bidHead, self.askHead, self.lmp);\n            }\n            return self.lmp;\n        } else if (self.bidHead != 0 && self.askHead == 0) {\n            if (self.lmp != 0) {\n                return self.lmp >= self.bidHead ? self.lmp : self.bidHead;\n            }\n            return self.bidHead;\n        } else if (self.bidHead == 0 && self.askHead != 0) {\n            if (self.lmp != 0) {\n                return self.lmp <= self.askHead ? self.lmp : self.askHead;\n            }\n            return self.askHead;\n        } else {\n            return self.lmp;\n        }\n    }\n\n    function _next(PriceLinkedList storage self, bool isBid, uint256 price) internal view returns (uint256) {\n        if (isBid) {\n            return self.bidPrices[price];\n        } else {\n            return self.askPrices[price];\n        }\n    }\n\n    // for bidPrices, lower ones are next, for askPrices, higher ones are next\n    function _insert(PriceLinkedList storage self, bool isBid, uint256 price) internal {\n        if (isBid) {\n            uint256 last = 0;\n            uint256 head = self.bidHead;\n            // insert bid price to the linked list\n            // if the list is empty\n            if (head == 0 || price > head) {\n                self.bidHead = price;\n                self.bidPrices[price] = head;\n                return;\n            }\n            while (head != 0) {\n                uint256 next = self.bidPrices[head];\n                if (price < next) {\n                    // Keep traversing\n                    head = self.bidPrices[head];\n                    last = next;\n                } else if (price > next) {\n                    if (next == 0) {\n                        // Insert price at the end of the list\n                        self.bidPrices[head] = price;\n                        self.bidPrices[price] = 0;\n                        return;\n                    }\n                    // Insert price in the middle of the list\n                    self.bidPrices[head] = price;\n                    self.bidPrices[price] = next;\n                    return;\n                } else {\n                    // price is already included in the queue as it is equal to next\n                    // End traversal as there is no need to traverse further\n                    return;\n                }\n            }\n        }\n        // insert ask price to the linked list\n        else {\n            uint256 last = 0;\n            uint256 head = self.askHead;\n            // insert order to the linked list\n            // if the list is empty and price is the lowest ask\n            if (head == 0 || price < head) {\n                self.askHead = price;\n                self.askPrices[price] = head;\n                return;\n            }\n            // traverse the list\n            while (head != 0) {\n                uint256 next = self.askPrices[head];\n                // Keep traversing\n                if (price > next) {\n                    if (next == 0) {\n                        // Insert price in the middle of the list\n                        self.askPrices[head] = price;\n                        self.askPrices[price] = 0;\n                        return;\n                    }\n                    head = self.askPrices[head];\n                    last = next;\n                } else if (price < next) {\n                    // Insert price in the middle of the list\n                    self.askPrices[head] = price;\n                    self.askPrices[price] = next;\n                    return;\n                } else {\n                    // price is already included in the queue as it is equal to next\n                    // End traversal as there is no need to traverse further\n                    return;\n                }\n            }\n        }\n    }\n\n    function _clearHead(PriceLinkedList storage self, bool isBid) internal returns (uint256 newHead) {\n        if (isBid) {\n            self.bidHead = self.bidPrices[self.bidHead];\n        } else {\n            self.askHead = self.askPrices[self.askHead];\n        }\n        return isBid ? self.bidHead : self.askHead;\n    }\n\n    function _delete(PriceLinkedList storage self, bool isBid, uint256 price) internal returns (bool) {\n        // traverse the list\n        if (price == 0) {\n            // revert ZeroPrice(price);\n            return false;\n        }\n\n        if (isBid) {\n            uint256 last = 0;\n            uint256 head = self.bidHead;\n            // insert bid price to the linked list\n            // if the list is empty\n            if (head == 0 || price > head) {\n                // revert NoHeadBelow(isBid, head);\n                return false;\n            }\n            while (head != 0 && price > head) {\n                uint256 next = self.bidPrices[head];\n                // price is below head bid price, traversing to lower end\n                if (price < next) {\n                    // Keep traversing\n                    head = self.bidPrices[head];\n                    last = next;\n                }\n                // price is above lowest bid price, and the search price is head which is right before next\n                else if (price > next) {\n                    // the search price is at the end\n                    if (next == 0) {\n                        // if there is only one price left, check if it is the price we are looking for\n                        if (head == price) {\n                            // remove price at the end\n                            self.bidPrices[last] = 0;\n                            delete self.bidPrices[head];\n                            // if the price is at the foremost head, set foremost head as 0.\n                            if (self.bidHead == price) {\n                                self.bidHead = 0;\n                            }\n                            return true;\n                        }\n                        // Price does not exist in price list\n                        // revert PriceOutOfRange(head, price);\n                        return false;\n                    }\n                    // the search price is right above the next price which is not zero\n                    else {\n                        if (head == price) {\n                            // if last price did exist\n                            if (last != 0) {\n                                self.bidPrices[last] = next;\n                                delete self.bidPrices[head];\n                                return true;\n                            }\n                            // if current price is head\n                            else {\n                                self.bidHead = next;\n                                delete self.bidPrices[head];\n                                return true;\n                            }\n                        }\n                    }\n                    // Price does not exist within range of prices\n                    // revert PriceNoneInRange(head, price);\n                    return false;\n                }\n                // price is above lowest bid price, and the search price is next price\n                else {\n                    // price is already included in the queue as it is equal to next. price exists in the orderbook\n                    // End traversal as there is no need to traverse further\n                    // remove price in next, connect next next to the head\n                    self.bidPrices[head] = self.bidPrices[next];\n                    delete self.bidPrices[next];\n                    return true;\n                }\n            }\n        }\n        // insert ask price to the linked list\n        else {\n            uint256 last = 0;\n            uint256 head = self.askHead;\n            // insert order to the linked list\n            // if the list is empty and price is the lowest ask\n            if (head == 0 || price < head) {\n                // revert NoHeadBelow(isBid, head);\n                return false;\n            }\n            // traverse the list\n            while (head != 0 && price < head) {\n                uint256 next = self.askPrices[head];\n                // price is above head price, traversing to end\n                if (price > next) {\n                    // the price is at the end of range\n                    if (next == 0) {\n                        // if there is only one price left, check if it is the price we are looking for\n                        if (head == price) {\n                            self.askPrices[last] = 0;\n                            delete self.askPrices[head];\n                            // if the price is at the foremost head, set foremost head as 0.\n                            if (self.askHead == price) {\n                                self.askHead = 0;\n                            }\n                            return true;\n                        }\n                        // Price does not exist in price list\n                        //revert PriceOutOfRange(head, price);\n                        return false;\n                    }\n                    // Keep traversing\n                    head = self.askPrices[head];\n                    last = next;\n                }\n                // price is below highest ask, and the search price is head which is right before next\n                else if (price < next) {\n                    // Price does exist within range of prices\n                    if (head == price) {\n                        // price is already included in the queue as it is equal to next\n                        // End traversal as there is no need to traverse further\n                        // if last price did exist\n                        if (last != 0) {\n                            self.askPrices[last] = self.askPrices[next];\n                            delete self.askPrices[head];\n                            return true;\n                        }\n                        // if current price is head\n                        else {\n                            self.askHead = self.askPrices[next];\n                            delete self.askPrices[head];\n                            return true;\n                        }\n                    } else {\n                        // revert PriceNoneInRange(head, price);\n                        return false;\n                    }\n                    //return false;\n                }\n                // price is below highest ask, and the search price is next price\n                else {\n                    // price is already included in the queue as it is equal to next\n                    // End traversal as there is no need to traverse further\n                    self.askPrices[head] = self.askPrices[next];\n                    delete self.askPrices[next];\n                    return true;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    // show n prices shown in the orderbook\n    function _getPrices(PriceLinkedList storage self, bool isBid, uint256 n) internal view returns (uint256[] memory) {\n        uint256 i = 0;\n        uint256[] memory prices = new uint256[](n);\n        for (\n            uint256 price = isBid ? self.bidHead : self.askHead;\n            price != 0 && i < n;\n            price = isBid ? self.bidPrices[price] : self.askPrices[price]\n        ) {\n            prices[i] = price;\n            i++;\n        }\n        return prices;\n    }\n\n    function _getPricesPaginated(PriceLinkedList storage self, bool isBid, uint256 start, uint256 end)\n        internal\n        view\n        returns (uint256[] memory)\n    {\n        uint256 i = 0;\n        uint256[] memory prices = new uint256[](end - start);\n        uint256 price = isBid ? self.bidHead : self.askHead;\n        for (price; price != 0 && i < start; price = isBid ? self.bidPrices[price] : self.askPrices[price]) {\n            i++;\n        }\n        if (price == 0) {\n            return prices;\n        }\n        for (price; price != 0 && i < end; price = isBid ? self.bidPrices[price] : self.askPrices[price]) {\n            prices[i] = price;\n            i++;\n        }\n        return prices;\n    }\n\n    function _checkPriceExists(PriceLinkedList storage self, bool isBid, uint256 price) internal view returns (bool) {\n        // traverse the list\n        if (price == 0) {\n            revert ZeroPrice(price);\n            //return false;\n        }\n\n        if (isBid) {\n            uint256 last = 0;\n            uint256 head = self.bidHead;\n            // insert bid price to the linked list\n            // if the list is empty\n            if (head == 0 || price > head) {\n                revert NoHeadBelow(isBid, head);\n            } else if (head == price) {\n                return true;\n            }\n\n            while (head != 0 && price > head) {\n                uint256 next = self.bidPrices[head];\n                if (price < next) {\n                    // Keep traversing\n                    head = self.bidPrices[head];\n                    last = next;\n                }\n                // within the price range\n                else if (price > next) {\n                    // if next is end of the list\n                    if (next == 0) {\n                        // if there is only one price left, check if it is the price we are looking for\n                        if (head == price) {\n                            return true;\n                        }\n                        // Price does not exist in price list\n                        revert PriceOutOfRange(head, price);\n                    }\n                    // if next is lower bid than the price\n                    else {\n                        if (head == price) {\n                            return true;\n                        }\n                        // Price does not exist within range of prices\n                        revert PriceNoneInRange(head, price);\n                    }\n                } else {\n                    // price is already included in the queue as it is equal to next. price exists in the orderbook\n                    // End traversal as there is no need to traverse further\n                    return true;\n                }\n            }\n        }\n        // insert ask price to the linked list\n        else {\n            uint256 last = 0;\n            uint256 head = self.askHead;\n            // insert order to the linked list\n            // if the list is empty and price is the lowest ask\n            if (head == 0 || price < head) {\n                revert NoHeadBelow(isBid, head);\n            } else if (head == price) {\n                return true;\n            }\n            // traverse the list\n            while (head != 0) {\n                uint256 next = self.askPrices[head];\n                // Keep traversing\n                if (price > next) {\n                    if (next == 0) {\n                        // if there is only one price left, check if it is the price we are looking for\n                        if (head == price) {\n                            return true;\n                        }\n                        // Price does not exist in price list\n                        revert PriceOutOfRange(head, price);\n                    }\n                    head = self.askPrices[head];\n                    last = next;\n                } else if (price < next) {\n                    if (head == price) {\n                        return true;\n                    }\n                    // Price does not exist within range of prices\n                    revert PriceNoneInRange(head, price);\n                } else {\n                    // price is already included in the queue as it is equal to next\n                    // End traversal as there is no need to traverse further\n                    return true;\n                }\n            }\n        }\n\n        return true;\n    }\n}\n"},"src/exchange/libraries/ExchangeOrderbook.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.24;\n\nlibrary ExchangeOrderbook {\n    // Order struct\n    struct Order {\n        address owner;\n        uint256 price;\n        uint256 depositAmount;\n    }\n\n    // Order Linked List\n    struct OrderStorage {\n        /// Hashmap-style linked list of prices to route orders\n        // key: price, value: order indices linked hashmap\n        mapping(uint256 => mapping(uint32 => uint32)) list;\n        mapping(uint32 => Order) orders;\n        // Head of the linked list(i.e. lowest ask price / highest bid price)\n        mapping(uint256 => uint32) head;\n        // count of the orders, used for array allocation\n        uint32 count;\n        address engine;\n        Order dormantOrder;\n    }\n\n    error OrderIdIsZero(uint32 id);\n    error PriceIsZero(uint256 price);\n\n    // for orders, lower depositAmount are next, higher depositAmount comes first\n    function _insertId(OrderStorage storage self, uint256 price, uint32 id, uint256 amount) internal {\n        uint32 last = 0;\n        uint32 head = self.head[price];\n        mapping(uint32 => uint32) storage list = self.list[price];\n        mapping(uint32 => Order) storage orders = self.orders;\n        // insert order to the linked list\n        // if the list is empty\n        if (head == 0 || amount > self.orders[head].depositAmount) {\n            self.head[price] = id;\n            list[id] = head;\n            return;\n        }\n        // Traverse through list until we find the right spot where id's deposit amount is higher than next\n        while (head != 0) {\n            // what if order deposit amount is bigger than the next order's deposit amount?\n            uint32 next = list[head];\n            if (amount < orders[next].depositAmount) {\n                // Keep traversing\n                head = list[head];\n                last = next;\n            } else if (amount > orders[next].depositAmount) {\n                // This is either order is cancelled or order is at the end of the list\n                if (orders[next].depositAmount == 0) {\n                    // Insert order at the end of the list\n                    list[head] = id;\n                    list[id] = 0;\n                    return;\n                }\n                // Insert order in the middle of the list\n                list[head] = id;\n                list[id] = next;\n                return;\n            }\n            // what if there is same order with same deposit amount?\n            else if (amount == orders[next].depositAmount) {\n                list[id] = list[next];\n                list[next] = id;\n                return;\n            }\n        }\n    }\n\n    // pop front\n    function _fpop(OrderStorage storage self, uint256 price) internal returns (uint256) {\n        uint32 first = self.head[price];\n        if (first == 0) {\n            return 0;\n        }\n        uint32 next = self.list[price][first];\n        self.head[price] = next;\n        delete self.list[price][first];\n        return first;\n    }\n\n    function _createOrder(OrderStorage storage self, address owner, uint256 price, uint256 depositAmount)\n        internal\n        returns (uint32 id, bool foundDmt)\n    {\n        if (price == 0) {\n            revert PriceIsZero(price);\n        }\n        Order memory order = Order({owner: owner, price: price, depositAmount: depositAmount});\n        // set foundDmt to false by default\n        foundDmt = false;\n        // In order to prevent order overflow, order id must start from 1\n        self.count = self.count == 0 || self.count == type(uint32).max ? 1 : self.count + 1;\n        // check if the order already exists\n        if (self.orders[self.count].owner != address(0)) {\n            // store canceling order to dormantOrder\n            self.dormantOrder = self.orders[self.count];\n            // cancel the dormant order and set foundDmt to true\n            _deleteOrder(self, self.count);\n            foundDmt = true;\n        }\n        // insert order\n        self.orders[self.count] = order;\n        return (self.count, foundDmt == true);\n    }\n\n    function _decreaseOrder(OrderStorage storage self, uint32 id, uint256 amount, uint256 dust, bool clear)\n        internal\n        returns (uint256 sendFund, uint256 deletePrice)\n    {\n        uint256 decreased = self.orders[id].depositAmount < amount ? 0 : self.orders[id].depositAmount - amount;\n        // remove dust\n        if (decreased <= dust || clear) {\n            decreased = self.orders[id].depositAmount;\n            deletePrice = _deleteOrder(self, id);\n            return (decreased, deletePrice);\n        } else {\n            self.orders[id].depositAmount = decreased;\n            return (amount, deletePrice);\n        }\n    }\n\n    function _deleteOrder(OrderStorage storage self, uint32 id) internal returns (uint256 deletePrice) {\n        uint256 price = self.orders[id].price;\n        uint32 last = 0;\n        uint32 head = self.head[price];\n        uint32 next;\n        uint16 i;\n        mapping(uint32 => uint32) storage list = self.list[price];\n        // delete id in the order linked list\n        if (head == id) {\n            self.head[price] = list[head];\n            delete list[id];\n        } else {\n            // search for the order id in the linked list\n            while (head != 0) {\n                next = list[head];\n                if (next == id) {\n                    list[head] = list[next];\n                    delete list[id];\n                    break;\n                }\n                last = head;\n                head = next;\n                ++i;\n            }\n        }\n        // delete order\n        delete self.orders[id];\n        return self.head[price] == 0 ? price : 0;\n    }\n\n    // show n order ids at the price in the orderbook\n    function _getOrderIds(OrderStorage storage self, uint256 price, uint32 n) internal view returns (uint32[] memory) {\n        uint32 head = self.head[price];\n        uint32[] memory orders = new uint32[](n);\n        uint32 i = 0;\n        while (head != 0 && i < n) {\n            orders[i] = head;\n            head = self.list[price][head];\n            i++;\n        }\n        return orders;\n    }\n\n    function _getOrders(OrderStorage storage self, uint256 price, uint32 n) internal view returns (Order[] memory) {\n        uint32 head = self.head[price];\n        Order[] memory orders = new Order[](n);\n        uint32 i = 0;\n        while (head != 0 && i < n) {\n            orders[i] = self.orders[head];\n            head = self.list[price][head];\n            i++;\n        }\n        return orders;\n    }\n\n    function _getOrdersPaginated(OrderStorage storage self, uint256 price, uint32 start, uint32 end)\n        internal\n        view\n        returns (Order[] memory)\n    {\n        uint32 head = self.head[price];\n        Order[] memory orders = new Order[](end - start);\n        uint32 i = 0;\n        while (head != 0 && i < start) {\n            head = self.list[price][head];\n            i++;\n        }\n        if (head == 0) {\n            return orders;\n        }\n        while (head != 0 && i < end) {\n            orders[i] = self.orders[head];\n            head = self.list[price][head];\n            i++;\n        }\n        return orders;\n    }\n\n    function _head(OrderStorage storage self, uint256 price) internal view returns (uint32) {\n        return self.head[price];\n    }\n\n    function _isEmpty(OrderStorage storage self, uint256 price) internal view returns (bool) {\n        return self.head[price] == 0;\n    }\n\n    function _next(OrderStorage storage self, uint256 price, uint32 curr) internal view returns (uint32) {\n        return self.list[price][curr];\n    }\n\n    function _getOrder(OrderStorage storage self, uint32 id) internal view returns (Order memory) {\n        return self.orders[id];\n    }\n}\n"},"src/exchange/interfaces/IMatchingEngine.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\nimport {ExchangeOrderbook} from \"../libraries/ExchangeOrderbook.sol\";\n\npragma solidity ^0.8.24;\n\ninterface IMatchingEngine {\n\n    struct OrderMatch {\n        address owner;\n        uint256 baseTakerFee;\n        uint256 quoteTakerFee;\n    }\n\n    struct CancelOrderInput {\n        address base;\n        address quote;\n        bool isBid;\n        uint32 orderId;\n    }\n\n    struct UpdateOrderInput {\n        address base;\n        address quote;\n        bool isBid;\n        uint32 orderId;\n        uint256 price;\n        uint256 amount;\n        uint32 n;\n        address recipient;\n    }\n\n    // admin functions\n    function setFeeTo(address feeTo_) external returns (bool success);\n\n    function setDefaultFee(bool isMaker, uint32 fee_) external returns (bool success);\n\n    function setDefaultSpread(uint32 buy, uint32 sell, bool isMkt) external returns (bool success);\n\n    function setSpread(address base, address quote, uint32 buy, uint32 sell, bool isMkt)\n        external\n        returns (bool success);\n\n    function adjustPrice(\n        address base,\n        address quote,\n        bool isBuy,\n        uint256 price,\n        uint256 assetAmount,\n        uint32 beforeAdjust,\n        uint32 afterAdjust,\n        bool isMaker,\n        uint32 n\n    ) external returns (uint256 makePrice, uint256 placed, uint32 id);\n\n    function updatePair(address base, address quote, uint256 listingPrice, uint256 listingDate)\n        external\n        returns (address pair);\n\n    // user functions\n    function marketBuy(\n        address base,\n        address quote,\n        uint256 quoteAmount,\n        bool isMaker,\n        uint32 n,\n        address recipient,\n        uint32 slippageLimit\n    ) external returns (uint256 makePrice, uint256 placed, uint32 id);\n\n    function marketSell(\n        address base,\n        address quote,\n        uint256 baseAmount,\n        bool isMaker,\n        uint32 n,\n        address recipient,\n        uint32 slippageLimit\n    ) external returns (uint256 makePrice, uint256 placed, uint32 id);\n\n    function marketBuyETH(address base, bool isMaker, uint32 n, address recipient, uint32 slippageLimit)\n        external\n        payable\n        returns (uint256 makePrice, uint256 placed, uint32 id);\n\n    function marketSellETH(address quote, bool isMaker, uint32 n, address recipient, uint32 slippageLimit)\n        external\n        payable\n        returns (uint256 makePrice, uint256 placed, uint32 id);\n\n    function limitBuy(\n        address base,\n        address quote,\n        uint256 price,\n        uint256 quoteAmount,\n        bool isMaker,\n        uint32 n,\n        address recipient\n    ) external returns (uint256 makePrice, uint256 placed, uint32 id);\n\n    function limitSell(\n        address base,\n        address quote,\n        uint256 price,\n        uint256 baseAmount,\n        bool isMaker,\n        uint32 n,\n        address recipient\n    ) external returns (uint256 makePrice, uint256 placed, uint32 id);\n\n    function limitBuyETH(address base, uint256 price, bool isMaker, uint32 n, address recipient)\n        external\n        payable\n        returns (uint256 makePrice, uint256 placed, uint32 id);\n\n    function limitSellETH(address quote, uint256 price, bool isMaker, uint32 n, address recipient)\n        external\n        payable\n        returns (uint256 makePrice, uint256 placed, uint32 id);\n\n    function addPair(address base, address quote, uint256 listingPrice, uint256 listingDate, address payment)\n        external\n        returns (address pair);\n\n    function addPairETH(address base, address quote, uint256 listingPrice, uint256 listingDate)\n        external\n        payable\n        returns (address book);\n\n    function updateOrder(UpdateOrderInput memory updateOrderData)\n        external\n        returns (uint256 makePrice, uint256 placed, uint32 id);\n\n    function updateOrders(UpdateOrderInput[] memory updateOrderData)\n        external\n        returns (uint256[] memory makePrice, uint256[] memory placed, uint32[] memory id);\n\n    function cancelOrder(address base, address quote, bool isBid, uint32 orderId) external returns (uint256 refunded);\n\n    function cancelOrders(CancelOrderInput[] memory cancelOrders) external returns (uint256[] memory refunded);\n\n    function getOrder(address base, address quote, bool isBid, uint32 orderId)\n        external\n        view\n        returns (ExchangeOrderbook.Order memory);\n\n    function getPair(address base, address quote) external view returns (address book);\n\n    function heads(address base, address quote) external view returns (uint256 bidHead, uint256 askHead);\n\n    function mktPrice(address base, address quote) external view returns (uint256);\n\n    function convert(address base, address quote, uint256 amount, bool isBid)\n        external\n        view\n        returns (uint256 converted);\n\n    function feeTo() external view returns (address);\n\n    function incentive() external view returns (address);\n    \n    function feeOf(address base, address quote, address account, bool isMaker) external view returns (uint32 feeNum);\n}\n"},"lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"node_modules/@lukso/lsp7-contracts/contracts/ILSP7DigitalAsset.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.8.4;\n\n// interfaces\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {\n    IERC725Y\n} from \"@erc725/smart-contracts/contracts/interfaces/IERC725Y.sol\";\n\n/**\n * @title Interface of the LSP7 - Digital Asset standard, a fungible digital asset.\n */\ninterface ILSP7DigitalAsset is IERC165, IERC725Y {\n    // --- Events\n\n    /**\n     * @dev Emitted when the `from` transferred successfully `amount` of tokens to `to`.\n     * @param operator The address of the operator that executed the transfer.\n     * @param from The address which tokens were sent from (balance decreased by `-amount`).\n     * @param to The address that received the tokens (balance increased by `+amount`).\n     * @param amount The amount of tokens transferred.\n     * @param force if the transferred enforced the `to` recipient address to be a contract that implements the LSP1 standard or not.\n     * @param data Any additional data included by the caller during the transfer, and sent in the LSP1 hooks to the `from` and `to` addresses.\n     */\n    event Transfer(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bool force,\n        bytes data\n    );\n\n    /**\n     * @dev Emitted when `tokenOwner` enables `operator` for `amount` tokens.\n     * @param operator The address authorized as an operator\n     * @param tokenOwner The token owner\n     * @param amount The amount of tokens `operator` address has access to from `tokenOwner`\n     * @param operatorNotificationData The data to notify the operator about via LSP1.\n     */\n    event OperatorAuthorizationChanged(\n        address indexed operator,\n        address indexed tokenOwner,\n        uint256 indexed amount,\n        bytes operatorNotificationData\n    );\n\n    /**\n     * @dev Emitted when `tokenOwner` disables `operator` for `amount` tokens and set its {`authorizedAmountFor(...)`} to `0`.\n     * @param operator The address revoked from operating\n     * @param tokenOwner The token owner\n     * @param notified Bool indicating whether the operator has been notified or not\n     * @param operatorNotificationData The data to notify the operator about via LSP1.\n     */\n    event OperatorRevoked(\n        address indexed operator,\n        address indexed tokenOwner,\n        bool indexed notified,\n        bytes operatorNotificationData\n    );\n\n    // --- Token queries\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * If the asset contract has been set to be non-divisible via the `isNonDivisible_` parameter in\n     * the `constructor`, the decimals returned wiil be `0`. Otherwise `18` is the common value.\n     *\n     * @custom:notice This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {balanceOf} and {transfer}.\n     *\n     * @return the number of decimals. If `0` is returned, the asset is non-divisible.\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Returns the number of existing tokens that have been minted in this contract.\n     * @return The number of existing tokens.\n     */\n    function totalSupply() external view returns (uint256);\n\n    // --- Token owner queries\n\n    /**\n     * @dev Get the number of tokens owned by `tokenOwner`.\n     * If the token is divisible (the {decimals} function returns `18`), the amount returned should be divided\n     * by 1e18 to get a better picture of the actual balance of the `tokenOwner`.\n     *\n     * _Example:_\n     *\n     * ```\n     * balanceOf(someAddress) -> 42_000_000_000_000_000_000 / 1e18 = 42 tokens\n     * ```\n     *\n     * @param tokenOwner The address of the token holder to query the balance for.\n     * @return The amount of tokens owned by `tokenOwner`.\n     */\n    function balanceOf(address tokenOwner) external view returns (uint256);\n\n    // --- Operator functionality\n\n    /**\n     * @dev Sets an `amount` of tokens that an `operator` has access from the caller's balance (allowance). See {authorizedAmountFor}.\n     * Notify the operator based on the LSP1-UniversalReceiver standard\n     *\n     * @param operator The address to authorize as an operator.\n     * @param amount The allowance amount of tokens operator has access to.\n     * @param operatorNotificationData The data to notify the operator about via LSP1.\n     *\n     * @custom:requirements\n     * - `operator` cannot be the zero address.\n     *\n     * @custom:events {OperatorAuthorizationChanged} when allowance is given to a new operator or\n     * an existing operator's allowance is updated.\n     */\n    function authorizeOperator(\n        address operator,\n        uint256 amount,\n        bytes memory operatorNotificationData\n    ) external;\n\n    /**\n     * @dev Enables `tokenOwner` to remove `operator` for its tokens, disallowing it to send any amount of tokens on its behalf.\n     * This function also allows the `operator` to remove itself if it is the caller of this function\n     *\n     * @param operator The address to revoke as an operator.\n     * @param tokenOwner The address of the token owner.\n     * @param notify Boolean indicating whether to notify the operator or not.\n     * @param operatorNotificationData The data to notify the operator about via LSP1.\n     *\n     * @custom:requirements\n     * - caller MUST be `operator` or `tokenOwner`\n     * - `operator` cannot be the zero address.\n     *\n     * @custom:events {OperatorRevoked} event with address of the operator being revoked for the caller (token holder).\n     */\n    function revokeOperator(\n        address operator,\n        address tokenOwner,\n        bool notify,\n        bytes memory operatorNotificationData\n    ) external;\n\n    /**\n     * @custom:info This function in the LSP7 contract can be used as a prevention mechanism\n     * against double spending allowance vulnerability.\n     *\n     * @notice Increase the allowance of `operator` by +`addedAmount`\n     *\n     * @dev Atomically increases the allowance granted to `operator` by the caller.\n     * This is an alternative approach to {authorizeOperator} that can be used as a mitigation\n     * for the double spending allowance problem.\n     * Notify the operator based on the LSP1-UniversalReceiver standard\n     *\n     * @param operator The operator to increase the allowance for `msg.sender`\n     * @param addedAmount The additional amount to add on top of the current operator's allowance\n     *\n     * @custom:requirements\n     *  - `operator` cannot be the same address as `msg.sender`\n     *  - `operator` cannot be the zero address.\n     *\n     * @custom:events {OperatorAuthorizationChanged} indicating the updated allowance\n     */\n    function increaseAllowance(\n        address operator,\n        uint256 addedAmount,\n        bytes memory operatorNotificationData\n    ) external;\n\n    /**\n     * @custom:info This function in the LSP7 contract can be used as a prevention mechanism\n     * against the double spending allowance vulnerability.\n     *\n     * @notice Decrease the allowance of `operator` by -`subtractedAmount`\n     *\n     * @dev Atomically decreases the allowance granted to `operator` by the caller.\n     * This is an alternative approach to {authorizeOperator} that can be used as a mitigation\n     * for the double spending allowance problem.\n     * Notify the operator based on the LSP1-UniversalReceiver standard\n     *\n     * @custom:events\n     *  - {OperatorAuthorizationChanged} event indicating the updated allowance after decreasing it.\n     *  - {OperatorRevoked} event if `subtractedAmount` is the full allowance,\n     *    indicating `operator` does not have any alauthorizedAmountForlowance left for `msg.sender`.\n     *\n     * @param operator The operator to decrease allowance for `msg.sender`\n     * @param tokenOwner The address of the token owner.\n     * @param subtractedAmount The amount to decrease by in the operator's allowance.\n     *\n     * @custom:requirements\n     *  - `operator` cannot be the zero address.\n     *  - `operator` must have allowance for the caller of at least `subtractedAmount`.\n     */\n    function decreaseAllowance(\n        address operator,\n        address tokenOwner,\n        uint256 subtractedAmount,\n        bytes memory operatorNotificationData\n    ) external;\n\n    /**\n     * @dev Get the amount of tokens `operator` address has access to from `tokenOwner`.\n     * Operators can send and burn tokens on behalf of their owners.\n     *\n     * @param operator The operator's address to query the authorized amount for.\n     * @param tokenOwner The token owner that `operator` has allowance on.\n     *\n     * @return The amount of tokens the `operator`'s address has access on the `tokenOwner`'s balance.\n     *\n     * @custom:info If this function is called with the same address for `operator` and `tokenOwner`, it will simply read the `tokenOwner`'s balance\n     * (since a tokenOwner is its own operator).\n     */\n    function authorizedAmountFor(\n        address operator,\n        address tokenOwner\n    ) external view returns (uint256);\n\n    /**\n     * @dev Returns all `operator` addresses that are allowed to transfer or burn on behalf of `tokenOwner`.\n     *\n     * @param tokenOwner The token owner to get the operators for.\n     * @return An array of operators allowed to transfer or burn tokens on behalf of `tokenOwner`.\n     */\n    function getOperatorsOf(\n        address tokenOwner\n    ) external view returns (address[] memory);\n\n    // --- Transfer functionality\n\n    /**\n     * @dev Transfers an `amount` of tokens from the `from` address to the `to` address and notify both sender and recipients via the LSP1 {`universalReceiver(...)`} function.\n     * If the tokens are transferred by an operator on behalf of a token holder, the allowance for the operator will be decreased by `amount` once the token transfer\n     * has been completed (See {authorizedAmountFor}).\n     *\n     * @param from The sender address.\n     * @param to The recipient address.\n     * @param amount The amount of tokens to transfer.\n     * @param force When set to `true`, the `to` address CAN be any address. When set to `false`, the `to` address MUST be a contract that supports the LSP1 UniversalReceiver standard.\n     * @param data Any additional data the caller wants included in the emitted event, and sent in the hooks of the `from` and `to` addresses.\n     *\n     * @custom:requirements\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` and `to` cannot be the same address (`from` cannot send tokens to itself).\n     * - `from` MUST have a balance of at least `amount` tokens.\n     * - If the caller is not `from`, it must be an operator for `from` with an allowance of at least `amount` of tokens.\n     *\n     * @custom:events\n     * - {Transfer} event when tokens get successfully transferred.\n     * - if the transfer is triggered by an operator, either the {OperatorAuthorizationChanged} event will be emitted with the updated allowance or the {OperatorRevoked}\n     * event will be emitted if the operator has no more allowance left.\n     *\n     * @custom:hint The `force` parameter **MUST be set to `true`** to transfer tokens to Externally Owned Accounts (EOAs)\n     * or contracts that do not implement the LSP1 Universal Receiver Standard. Otherwise the function will revert making the transfer fail.\n     *\n     * @custom:info if the `to` address is a contract that implements LSP1, it will always be notified via its `universalReceiver(...)` function, regardless if `force` is set to `true` or `false`.\n     *\n     * @custom:warning Be aware that when either the sender or the recipient can have logic that revert in their `universalReceiver(...)` function when being notified.\n     * This even if the `force` was set to `true`.\n     */\n    function transfer(\n        address from,\n        address to,\n        uint256 amount,\n        bool force,\n        bytes memory data\n    ) external;\n\n    /**\n     * @dev Same as {`transfer(...)`} but transfer multiple tokens based on the arrays of `from`, `to`, `amount`.\n     *\n     * @custom:info If any transfer in the batch fail or revert, the whole call will revert.\n     *\n     * @param from An array of sending addresses.\n     * @param to An array of receiving addresses.\n     * @param amount An array of amount of tokens to transfer for each `from -> to` transfer.\n     * @param force For each transfer, when set to `true`, the `to` address CAN be any address. When set to `false`, the `to` address MUST be a contract that supports the LSP1 UniversalReceiver standard.\n     * @param data An array of additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.\n     *\n     * @custom:requirements\n     * - `from`, `to`, `amount` lists MUST be of the same length.\n     * - no values in `from` can be the zero address.\n     * - no values in `to` can be the zero address.\n     * - each `amount` tokens MUST be owned by `from`.\n     * - for each transfer, if the caller is not `from`, it MUST be an operator for `from` with access to at least `amount` tokens.\n     *\n     * @custom:events {Transfer} event **for each token transfer**.\n     */\n    function transferBatch(\n        address[] memory from,\n        address[] memory to,\n        uint256[] memory amount,\n        bool[] memory force,\n        bytes[] memory data\n    ) external;\n\n    /**\n     * @notice Executing the following batch of abi-encoded function calls on the contract: `data`.\n     *\n     * @dev Allows a caller to batch different function calls in one call. Perform a `delegatecall` on self, to call different functions with preserving the context.\n     * @param data An array of ABI encoded function calls to be called on the contract.\n     * @return results An array of abi-encoded data returned by the functions executed.\n     */\n    function batchCalls(\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n}\n"},"node_modules/@erc725/smart-contracts/contracts/interfaces/IERC725Y.sol":{"content":"// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.0;\n\n// interfaces\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @title The interface for ERC725Y sub-standard, a generic data key/value store.\n * @dev ERC725Y provides the ability to set arbitrary data key/value pairs that can be changed over time.\n * It is intended to standardise certain data key/value pairs to allow automated read and writes from/to the contract storage.\n */\ninterface IERC725Y is IERC165 {\n    /**\n     * @notice The following data key/value pair has been changed in the ERC725Y storage: Data key: `dataKey`, data value: `dataValue`.\n     * @dev Emitted when data at a specific `dataKey` was changed to a new value `dataValue`.\n     * @param dataKey The data key for which a bytes value is set.\n     * @param dataValue The value to set for the given data key.\n     */\n    event DataChanged(bytes32 indexed dataKey, bytes dataValue);\n\n    /**\n     * @notice Reading the ERC725Y storage for data key `dataKey` returned the following value: `dataValue`.\n     * @dev Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.\n     * @param dataKey The data key for which to retrieve the value.\n     * @return dataValue The bytes value stored under the specified data key.\n     */\n    function getData(\n        bytes32 dataKey\n    ) external view returns (bytes memory dataValue);\n\n    /**\n     * @notice Reading the ERC725Y storage for data keys `dataKeys` returned the following values: `dataValues`.\n     * @dev Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.\n     * @param dataKeys The array of keys which values to retrieve\n     * @return dataValues The array of data stored at multiple keys\n     */\n    function getDataBatch(\n        bytes32[] memory dataKeys\n    ) external view returns (bytes[] memory dataValues);\n\n    /**\n     * @notice Setting the following data key value pair in the ERC725Y storage. Data key: `dataKey`, data value: `dataValue`.\n     *\n     * @dev Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`.\n     * The function is marked as payable to enable flexibility on child contracts. For instance to implement\n     * a fee mechanism for setting specific data.\n     *\n     * @param dataKey The data key for which to set a new value.\n     * @param dataValue The new bytes value to set.\n     */\n    function setData(bytes32 dataKey, bytes memory dataValue) external payable;\n\n    /**\n     * @notice Setting the following data key value pairs in the ERC725Y storage. Data keys: `dataKeys`, data values: `dataValues`.\n     *\n     * @dev Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.\n     *\n     * @param dataKeys An array of data keys to set bytes values for.\n     * @param dataValues An array of bytes values to set for each `dataKeys`.\n     */\n    function setDataBatch(\n        bytes32[] memory dataKeys,\n        bytes[] memory dataValues\n    ) external payable;\n}\n"}},"settings":{"remappings":["ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/","erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/","forge-std/=lib/forge-std/src/","openzeppelin-contracts/=lib/openzeppelin-contracts/","@openzeppelin/contracts/=lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/","@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/","@lukso/=node_modules/@lukso/","@erc725/=node_modules/@erc725/","halmos-cheatcodes/=lib/openzeppelin-contracts-upgradeable/lib/halmos-cheatcodes/src/","openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/","openzeppelin-foundry-upgrades/=lib/openzeppelin-foundry-upgrades/src/","solidity-stringutils/=lib/openzeppelin-foundry-upgrades/lib/solidity-stringutils/"],"optimizer":{"enabled":true,"runs":200},"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"*":{"":["ast"],"*":["abi","evm.bytecode.object","evm.bytecode.sourceMap","evm.bytecode.linkReferences","evm.deployedBytecode.object","evm.deployedBytecode.sourceMap","evm.deployedBytecode.linkReferences","evm.deployedBytecode.immutableReferences","evm.methodIdentifiers","metadata","storageLayout"]}},"evmVersion":"cancun","viaIR":false,"libraries":{}}}
