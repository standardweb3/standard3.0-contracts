{
    "language": "Solidity",
    "sources": {
        "contracts/mock/MockBTC.sol": {
            "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol\";\n\ncontract MockBTC is ERC20PresetMinterPauser {\n    constructor(string memory name, string memory symbol) ERC20PresetMinterPauser(name, symbol) {}\n\n    function decimals() public pure override returns (uint8) {\n        return 8;\n    }\n}\n"
        },
        "contracts/mock/MockBase.sol": {
            "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol\";\n\ncontract MockBase is ERC20PresetMinterPauser {\n    constructor(string memory name, string memory symbol) ERC20PresetMinterPauser(name, symbol) {}\n}\n"
        },
        "contracts/mock/MockQuote.sol": {
            "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol\";\n\ncontract MockQuote is ERC20PresetMinterPauser {\n    constructor(string memory name, string memory symbol) ERC20PresetMinterPauser(name, symbol) {}\n}\n"
        },
        "contracts/mock/MockToken.sol": {
            "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol\";\n\ncontract MockToken is ERC20PresetMinterPauser {\n    constructor(string memory name, string memory symbol) ERC20PresetMinterPauser(name, symbol) {}\n}\n"
        },
        "contracts/mock/MockTokenOver18Decimals.sol": {
            "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol\";\n\ncontract ErrToken is ERC20PresetMinterPauser {\n    constructor(string memory name, string memory symbol) ERC20PresetMinterPauser(name, symbol) {}\n\n    function decimals() public pure override returns (uint8) {\n        return 20;\n    }\n}\n"
        },
        "contracts/mock/WETH9.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract WETH9 is ERC20 {\n    constructor() ERC20(\"Wrapped Ether\", \"WETH\") {}\n\n    receive() external payable {\n        deposit();\n    }\n\n    function deposit() public payable {\n        _mint(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 amount) public {\n        require(balanceOf(msg.sender) >= amount, \"Insufficient balance\");\n        _burn(msg.sender, amount);\n        payable(msg.sender).transfer(amount);\n    }\n}\n"
        },
        "contracts/sabt/BlockAccountant.sol": {
            "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.17;\n\nimport {BlockAccountantLib, IAccountant} from \"./libraries/BlockAccountantLib.sol\";\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/// @author Hyungsuk Kang <hskang9@gmail.com>\n/// @title Standard Membership Accountant to report membership points\ncontract BlockAccountant is AccessControl, Initializable {\n    using BlockAccountantLib for BlockAccountantLib.Storage;\n\n    bytes32 public constant REPORTER_ROLE = keccak256(\"REPORTER_ROLE\");\n\n    BlockAccountantLib.Storage private _accountant;\n\n    error InvalidRole(bytes32 role, address sender);\n    error NotTreasury(address sender, address treasury);\n    error SPBCannotBeZero(uint32 spb_);\n\n    constructor() {\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    function initialize(address membership, address engine, address stablecoin, uint32 spb_) external initializer {\n        if (!hasRole(DEFAULT_ADMIN_ROLE, _msgSender())) {\n            revert InvalidRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        }\n        if (spb_ == 0) {\n            revert SPBCannotBeZero(spb_);\n        }\n        _accountant.membership = membership;\n        _accountant.engine = engine;\n        _accountant.stablecoin = stablecoin;\n        _accountant.stc1 = 10 ** IAccountant(stablecoin).decimals();\n        _accountant.fb = block.number;\n        _accountant.spb = spb_;\n        _accountant.era = uint32(30 days / spb_);\n    }\n\n    function setStablecoin(address stablecoin) external {\n        if (!hasRole(DEFAULT_ADMIN_ROLE, _msgSender())) {\n            revert InvalidRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        }\n        _accountant.stablecoin = stablecoin;\n    }\n\n    // TODO: migrate point from one era to other uid for multiple membership holders\n    /// @dev migrate: Migrate the membership point from one era to other uid\n    /// @param fromUid_ The uid to migrate from\n    /// @param toUid_ The uid to migrate to\n    /// @param nthEra_ The era to migrate\n    /// @param amount_ The amount of the point to migrate\n    function migrate(uint32 fromUid_, uint32 toUid_, uint32 nthEra_, uint256 amount_) external {\n        _accountant._migrate(fromUid_, toUid_, nthEra_, amount_);\n    }\n\n    /**\n     * @dev report: Report the membership point of the member to update\n     * @param uid The member uid\n     * @param token The token address\n     * @param amount The amount of the membership point\n     * @param isAdd The flag to add or subtract the point\n     */\n    function report(uint32 uid, address token, uint256 amount, bool isAdd) external {\n        if (!hasRole(REPORTER_ROLE, _msgSender())) {\n            revert InvalidRole(REPORTER_ROLE, _msgSender());\n        }\n        if (_accountant._isSubscribed(uid)) {\n            _accountant._report(uid, token, amount, isAdd);\n        }\n    }\n\n    function subtractTP(uint32 uid, uint32 nthEra, uint64 point) external {\n        if (msg.sender != _accountant.treasury) {\n            revert NotTreasury(msg.sender, _accountant.treasury);\n        }\n        _accountant._subtractTP(uid, nthEra, point);\n    }\n\n    function getTotalPoints(uint32 nthEra) external view returns (uint256) {\n        return _accountant._totalPoints(nthEra);\n    }\n\n    function getStablecoin() external view returns (address) {\n        return _accountant.stablecoin;\n    }\n\n    function fb() external view returns (uint256) {\n        return _accountant.fb;\n    }\n\n    function getCurrentEra() external view returns (uint32) {\n        return _accountant._getEra();\n    }\n\n    function getTotalTokens(uint32 nthEra, address token) external view returns (uint256) {\n        return _accountant._totalTokens(token, nthEra);\n    }\n\n    function pointOf(uint32 uid, uint32 nthEra) external view returns (uint256) {\n        return _accountant._getTP(uid, nthEra);\n    }\n\n    function getSpb() external view returns (uint256) {\n        return _accountant.spb;\n    }\n\n    function getTI(uint32 uid) external view returns (uint256) {\n        return _accountant._getTI(uid, _accountant._getEra());\n    }\n\n    function levelOf(uint32 uid) external view returns (uint8) {\n        return _accountant._getLevel(uid, _accountant._getEra());\n    }\n\n    function feeOf(uint32 uid, bool isMaker) external view returns (uint32) {\n        return _accountant._getFeeRate(uid, _accountant._getEra(), isMaker);\n    }\n}\n"
        },
        "contracts/sabt/Membership.sol": {
            "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.17;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {MembershipLib} from \"./libraries/MembershipLib.sol\";\nimport {IWETH} from \"./interfaces/IWETH.sol\";\n\n/// @author Hyungsuk Kang <hskang9@gmail.com>\n/// @title Standard Membership registration and subscription\ncontract Membership is AccessControl {\n    using MembershipLib for MembershipLib.Member;\n\n    bytes32 public constant PROMOTER_ROLE = keccak256(\"PROMOTER_ROLE\");\n\n    MembershipLib.Member private _membership;\n\n    error InvalidMeta(uint8 metaId_, address sender);\n    error InvalidRole(bytes32 role, address sender);\n\n    constructor() {\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    function initialize(address sabt_, address foundation_, address weth_) external {\n        if (!hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {\n            revert InvalidRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        }\n        _membership.sabt = sabt_;\n        _membership.foundation = foundation_;\n        _membership.weth = weth_;\n    }\n\n    /// @dev setFees: Set fees for registration and subscription and token address\n    /// @param feeToken_ The address of the token to pay the fee\n    /// @param regFee_ The registration fee per block in one token\n    /// @param subFee_ The subscription fee per block in one token\n    /// @param metaId_ The meta id of the token to pay the fee\n    /// @param quotas_ The number of tokens to be issued for registration\n    function setMembership(uint8 metaId_, address feeToken_, uint32 regFee_, uint32 subFee_, uint32 quotas_) external {\n        if (!hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {\n            revert InvalidRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        }\n        if (metaId_ == 0) {\n            revert InvalidMeta(metaId_, msg.sender);\n        }\n        _membership._setMembership(metaId_, feeToken_, regFee_, subFee_, quotas_);\n    }\n\n    function setFoundation(address foundation_) external {\n        if (!hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {\n            revert InvalidRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        }\n        _membership.foundation = foundation_;\n    }\n\n    function setQuota(uint8 metaId_, uint32 quota_) external {\n        if (!hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {\n            revert InvalidRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        }\n        _membership._setQuota(metaId_, quota_);\n    }\n\n    function setMeta(uint32 uid_, uint8 metaId_) external {\n        if (!hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {\n            revert InvalidRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        }\n        _membership._setMeta(uid_, metaId_);\n    }\n\n    function setSTND(address stnd) external {\n        if (!hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {\n            revert InvalidRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        }\n        _membership._setSTND(stnd);\n    }\n\n    function setFees(uint8 metaId_, address feeToken_, uint256 regFee_, uint256 subFee_) external {\n        if (!hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {\n            revert InvalidRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        }\n        _membership._setFees(metaId_, feeToken_, regFee_, subFee_);\n    }\n\n    /// @dev register: Register as a member\n    function register(uint8 metaId_, address feeToken_) external returns (uint32 uid) {\n        // check if metaId is valid, meta only supports 1~11\n        if (metaId_ == 0 || _membership.metas[metaId_].metaId != metaId_) {\n            revert InvalidMeta(metaId_, msg.sender);\n        }\n        // check if early adoptor, foundation, beta account is only used by admin\n        if ((metaId_ == 9 || metaId_ == 10 || metaId_ == 11) && !hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {\n            revert InvalidRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        }\n        return _membership._register(metaId_, feeToken_);\n    }\n\n    function registerETH(uint8 metaId_) external payable returns (uint32 uid) {\n        require(msg.value > 0, \"Membership: zero value\");\n        IWETH(_membership.weth).deposit{value: msg.value}();\n        return _membership._register(metaId_, _membership.weth);\n    }\n\n    /**\n     * @dev subscribe: Subscribe to the membership until certain block height\n     * @param uid_ The uid of the ABT to subscribe with\n     * @param blocks_ The number of blocks to remain subscribed\n     * @param feeToken_ The address of the token to pay the fee\n     */\n    function subscribe(uint32 uid_, uint64 blocks_, address feeToken_) external {\n        _membership._subscribe(uid_, blocks_, feeToken_);\n    }\n\n    function subscribeETH(uint32 uid_, uint64 blocks_) external payable {\n        require(msg.value > 0, \"Membership: zero value\");\n        IWETH(_membership.weth).deposit{value: msg.value}();\n        _membership._subscribe(uid_, blocks_, _membership.weth);\n    }\n\n    function offerBonus(uint32 uid_, address holder_, uint256 blocks_) external {\n        if (!hasRole(PROMOTER_ROLE, msg.sender)) {\n            revert InvalidRole(PROMOTER_ROLE, msg.sender);\n        }\n        _membership._offerBonus(uid_, holder_, blocks_);\n    }\n\n    /// @dev unsubscribe: Unsubscribe from the membership\n    /// @param uid_ The id of the ABT to unsubscribe with\n    function unsubscribe(uint32 uid_) external {\n        _membership._unsubscribe(uid_);\n    }\n\n    function balanceOf(address who, uint32 uid_) external view returns (uint256) {\n        return _membership._balanceOf(who, uid_);\n    }\n\n    function getSubSTND(uint32 uid_) external view returns (uint64) {\n        return _membership._getSubSTND(uid_);\n    }\n\n    function getMeta(uint8 metaId_) external view returns (MembershipLib.Meta memory) {\n        return _membership.metas[metaId_];\n    }\n\n    function getLvl(uint32 uid_) external view returns (uint8 lvl) {\n        return _membership._getLvl(uid_);\n    }\n\n    function isSubscribed(uint32 uid_) external view returns (bool) {\n        return _membership._isSubscribed(uid_);\n    }\n\n    function isReportable(address sender, uint32 uid_) external view returns (bool) {\n        return _membership._balanceOf(sender, uid_) > 0 && _membership._isSubscribed(uid_);\n    }\n}\n"
        },
        "contracts/sabt/Metadata.sol": {
            "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.17;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\n\n/// @author Hyungsuk Kang <hskang9@github.com>\n/// @title Metadata contract for SABT\ncontract Metadata is AccessControl {\n    function uri(uint256 id_) public view virtual returns (string memory) {\n        return \"https://arts.standard.tech/\";\n    }\n}\n"
        },
        "contracts/sabt/SABT.sol": {
            "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.17;\n\nimport {IERC1155, ERC1155, IERC1155MetadataURI} from \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport {AccessControl, IAccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\n/// @author Hyungsuk Kang <hskang9@github.com>\n/// @title Standard Account Bound Token\ncontract SABT is ERC1155, AccessControl, Initializable {\n    using Strings for uint256;\n\n    address public membership;\n    address public metadata;\n    string baseURI;\n\n    uint32 public index;\n\n    mapping(uint32 => uint8) public metaIds;\n\n    error NotMembership(address membership_, address sender);\n    error MembershipFull(uint32 uid_);\n    error InvalidRole(bytes32 role, address sender);\n\n    constructor() ERC1155(\"https://arts.standard.tech/\") {\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        index = 1;\n    }\n\n    function initialize(address membership_) external initializer {\n        if (!hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {\n            revert InvalidRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        }\n        membership = membership_;\n        baseURI = \"https://raw.githubusercontent.com/standardweb3/nft-arts/main/nfts/sabt\";\n    }\n\n    function setURI(string memory uri_) public {\n        if (!hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {\n            revert InvalidRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        }\n        baseURI = uri_;\n    }\n\n    function uri(uint256 tokenId) public view override returns (string memory) {\n        uint256 meta = metaIds[uint32(tokenId)];\n        return string(abi.encodePacked(baseURI, \"/\", meta.toString()));\n    }\n\n    /// @dev mint: Mint a new SABT for customized membership\n    /// @param to_ The address to mint the token to\n    /// @param metaId_ The id of the token to mint\n    function mint(address to_, uint8 metaId_) public returns (uint32) {\n        if (msg.sender != membership) {\n            revert NotMembership(membership, msg.sender);\n        }\n        if (index >= 4294967295 /* 2**32 -1 */ ) {\n            revert MembershipFull(index);\n        }\n        metaIds[index] = metaId_;\n        _mint(to_, index, 1, abi.encode(metaId_));\n        index++;\n        return index - 1;\n    }\n\n    /// @dev metaId: Return the metaId of the membership token\n    /// @param uid_ The uid of the token to get the metaId of\n    function metaId(uint32 uid_) external view returns (uint8) {\n        return metaIds[uid_];\n    }\n\n    function setMetaId(uint32 uid_, uint8 metaId_) public {\n        if (msg.sender != membership) {\n            revert NotMembership(membership, msg.sender);\n        }\n        metaIds[uid_] = metaId_;\n    }\n\n    function transfer(address _to, uint256 _id) public {\n        super.safeTransferFrom(msg.sender, _to, _id, 1, \"\");\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override (AccessControl, ERC1155)\n        returns (bool)\n    {\n        return interfaceId == type(IERC1155).interfaceId || interfaceId == type(IERC1155MetadataURI).interfaceId\n            || interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
        },
        "contracts/sabt/Treasury.sol": {
            "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.17;\n\nimport {TreasuryLib, TransferHelper} from \"./libraries/TreasuryLib.sol\";\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\ninterface IRevenue {\n    function report(\n        uint32 uid,\n        address token,\n        uint256 amount,\n        bool isAdd\n    ) external;\n\n    function isReportable(\n        address token,\n        uint32 uid\n    ) external view returns (bool);\n\n    function refundFee(address to, address token, uint256 amount) external;\n\n    function feeOf(uint32 uid, bool isMaker) external returns (uint32 feeNum);\n}\n\n/// @author Hyungsuk Kang <hskang9@github.com>\n/// @title Standard Membership Treasury to exchange membership points with rewards\ncontract Treasury is AccessControl, IRevenue {\n    using TreasuryLib for TreasuryLib.Storage;\n\n    bytes32 public constant REPORTER_ROLE = keccak256(\"REPORTER_ROLE\");\n\n    TreasuryLib.Storage private _treasury;\n    address private _membership;\n\n    error InvalidRole(bytes32 role, address sender);\n\n    constructor() {\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n\n    function set(address membership, address accountant, address sabt) external {\n        if (!hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {\n            revert InvalidRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        }\n        _membership = membership;\n        _treasury.accountant = accountant;\n        _treasury.sabt = sabt;\n    }\n\n    function report(\n        uint32 uid,\n        address token,\n        uint256 amount,\n        bool isAdd\n    ) external override {\n        IRevenue(_treasury.accountant).report(uid, token, amount, isAdd);\n    }\n\n    function isReportable(\n        address token,\n        uint32 uid\n    ) external view override returns (bool) {\n        return IRevenue(_membership).isReportable(token, uid);\n    }\n\n    function feeOf(uint32 uid, bool isMaker) external override returns (uint32 feeNum) {\n        return IRevenue(_treasury.accountant).feeOf(uid, isMaker);\n    }\n\n    /// @dev For subscribers, exchange point to reward\n    function exchange(address token, uint32 nthEra, uint32 uid, uint64 point) external {\n        _treasury._exchange(token, nthEra, uid, point);\n    }\n\n    /// @dev for investors, claim the reward with allocated revenue percentage\n    function claim(address token, uint32 nthEra, uint32 uid) external {\n        _treasury._claim(token, nthEra, uid);\n    }\n\n    /// @dev for dev, settle the revenue with allocated revenue percentage\n    function settle(address token, uint32 nthEra, uint32 uid) external {\n        _treasury._settle(token, nthEra, uid);\n    }\n\n    function setClaim(uint32 uid, uint32 num) external {\n        if (!hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {\n            revert InvalidRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        }\n        _treasury._setClaim(uid, num);\n    }\n\n    function setSettlement(uint32 uid) external {\n        if (!hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {\n            revert InvalidRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        }\n        _treasury._setSettlement(uid);\n    }\n\n    function refundFee(address to, address token, uint256 amount) external {\n        if (!hasRole(REPORTER_ROLE, msg.sender)) {\n            revert InvalidRole(REPORTER_ROLE, msg.sender);\n        }\n        TransferHelper.safeTransfer(token, to, amount);\n    }\n\n    function getReward(address token, uint32 nthEra, uint256 point) external view returns (uint256) {\n        return _treasury._getReward(token, nthEra, point);\n    }\n\n    function getClaim(address token, uint32 uid, uint32 nthEra) external view returns (uint256) {\n        return _treasury._getClaim(token, uid, nthEra);\n    }\n\n    function getSettlement(address token, uint32 nthEra) external view returns (uint256) {\n        return _treasury._getSettlement(token, nthEra);\n    }\n}\n"
        },
        "contracts/sabt/interfaces/IAccountant.sol": {
            "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.17;\n\ninterface IAccountant {\n    function convert(address base, address quote, uint256 amount, bool isBid)\n        external\n        view\n        returns (uint256 converted);\n\n    function isSubscribed(uint32 uid_) external view returns (bool);\n\n    function decimals() external view returns (uint8);\n\n    function balanceOf(address owner, uint256 id) external view returns (uint256);\n\n    function subtractTP(address account, uint256 nthEra, uint256 amount) external;\n\n    function getSubSTND(uint32 uid_) external view returns (uint64 sub);\n\n    function getMeta(uint32 uid_) external view returns (uint8 meta);\n}\n"
        },
        "contracts/sabt/interfaces/IMetadata.sol": {
            "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.17;\n\ninterface IMetadata {\n    function meta(uint256 _id) external view returns (string memory);\n}\n"
        },
        "contracts/sabt/interfaces/ISABT.sol": {
            "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.17;\n\ninterface ISABT {\n    function mint(address to_, uint8 metaId_) external returns (uint32);\n\n    function balanceOf(address owner_, uint256 uid_) external view returns (uint256);\n\n    function setRegistered(uint256 id_, bool yesOrNo) external;\n\n    function metaId(uint32 uid_) external view returns (uint8);\n}\n"
        },
        "contracts/sabt/interfaces/IWETH.sol": {
            "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function withdraw(uint256) external;\n}\n"
        },
        "contracts/sabt/libraries/BlockAccountantLib.sol": {
            "content": "// SPDX-License-Idenlevelfier: BUSL-1.1\npragma solidity ^0.8.17;\n\ninterface IAccountant {\n    function convert(address base, address quote, uint256 amount, bool isBid)\n        external\n        view\n        returns (uint256 converted);\n\n    function isSubscribed(uint32 uid_) external view returns (bool);\n\n    function sabt() external view returns (address);\n\n    function decimals() external view returns (uint8);\n\n    function balanceOf(address owner, uint32 id) external view returns (uint256);\n\n    function subtractTP(address account, uint256 nthEra, uint256 amount) external;\n\n    function getSubSTND(uint32 uid_) external view returns (uint64 sub);\n\n    function getLvl(uint32 uid_) external view returns (uint8 lvl);\n}\n\n/// @author Hyungsuk Kang <hskang9@gmail.com>\n/// @title Standard Membership Accountant to report membership points\nlibrary BlockAccountantLib {\n    struct Storage {\n        uint256 fb;\n        /// @dev pointOf: The mapping of the month to the mapping of the member UID to the point, each accountant can account 4,294,967,295 eras, each era is 28 days\n        mapping(uint32 => mapping(uint32 => uint64)) pointOf;\n        /// @dev totalPointsOn: The mapping of the month to the total point of the month\n        mapping(uint32 => uint64) totalPointsOn;\n        /// @dev totalTokensOn: The mapping of the token address to the mapping of the month to the total token amount of the month\n        mapping(bytes32 => uint256) totalTokensOn;\n        /// @dev refundOf: The mapping of the member UID to the refund amount\n        mapping(uint32 => uint256) refundOf;\n        /// @dev membership: The address of the membership contract\n        address membership;\n        /// @dev engine: The address of the orderbook dex entry point\n        address engine;\n        /// @dev treasury: The address of the treasury contract\n        address treasury;\n        /// @dev stablecoin: The address of the stablecoin contract\n        address stablecoin;\n        /// @dev stc1: One stablecoin with decimals\n        uint256 stc1;\n        /// @dev spb: The number of seconds per a block\n        uint32 spb;\n        /// @dev era: The number of blocks per an era\n        uint32 era;\n    }\n\n    error NotTheSameOwner(uint32 fromUid, uint32 toUid, address owner);\n    error InsufficientPoint(uint32 nthEra, uint32 uid, uint256 balance, uint256 amount);\n\n    function _setTotalTokens(Storage storage self, address token, uint32 era, uint256 amount, bool isAdd) internal {\n        bytes32 key = keccak256(abi.encodePacked(token, era));\n        isAdd ? self.totalTokensOn[key] += amount : self.totalTokensOn[key] -= amount;\n    }\n\n    function _totalTokens(Storage storage self, address token, uint32 era) internal view returns (uint256) {\n        bytes32 key = keccak256(abi.encodePacked(token, era));\n        return self.totalTokensOn[key];\n    }\n\n    function _getEra(Storage storage self) internal view returns (uint32 nthEra) {\n        return (block.number - self.fb) > self.era ? uint32((block.number - self.fb) / self.era) : 0;\n    }\n\n    /**\n     * @dev reportAdd: Report the membership point of the member\n     * @param uid The member UID\n     * @param token The token address\n     * @param amount The amount of the membership point\n     * @param isAdd The flag to add or subtract the point\n     */\n    function _report(Storage storage self, uint32 uid, address token, uint256 amount, bool isAdd) internal {\n        // check if the asset has pair in the orderbook dex between stablecoin\n        try IAccountant(self.engine).convert(token, self.stablecoin, amount, true) returns (uint256 converted) {\n            if (converted == 0) {\n                // if price is zero, return as the asset cannot be accounted\n                return;\n            } else {\n                // if it is, get USD level then calculate the point by 5 decimals\n                uint32 nthEra = (block.number - self.fb) > self.era ? uint32((block.number - self.fb) / self.era) : 0;\n                uint256 result = (converted * 1e5) / self.stc1;\n                uint64 point = result > type(uint64).max ? type(uint64).max : uint64(result);\n                isAdd ? self.pointOf[nthEra][uid] += point : self.pointOf[nthEra][uid] -= point;\n                isAdd ? self.totalPointsOn[nthEra] += point : self.totalPointsOn[nthEra] -= point;\n                _setTotalTokens(self, token, nthEra, amount, isAdd);\n            }\n        } catch {\n            return;\n        }\n    }\n\n    /// @dev migrate: Migrate the membership point from one era to other uid\n    /// @param fromUid_ The uid to migrate from\n    /// @param toUid_ The uid to migrate to\n    /// @param nthEra_ The era to migrate\n    /// @param amount_ The amount of the point to migrate\n    function _migrate(Storage storage self, uint32 fromUid_, uint32 toUid_, uint32 nthEra_, uint256 amount_) internal {\n        if (\n            IAccountant(self.membership).balanceOf(msg.sender, fromUid_) == 0\n                || IAccountant(self.membership).balanceOf(msg.sender, toUid_) == 0\n        ) {\n            revert NotTheSameOwner(fromUid_, toUid_, msg.sender);\n        }\n        if (self.pointOf[nthEra_][fromUid_] < amount_) {\n            revert InsufficientPoint(nthEra_, fromUid_, self.pointOf[nthEra_][fromUid_], amount_);\n        }\n        self.pointOf[nthEra_][fromUid_] -= uint64(amount_);\n        self.pointOf[nthEra_][toUid_] += uint64(amount_);\n    }\n\n    function _isSubscribed(Storage storage self, uint32 uid) internal view returns (bool) {\n        return IAccountant(self.membership).isSubscribed(uid);\n    }\n\n    function _subtractTP(Storage storage self, uint32 uid, uint32 nthEra, uint64 point) internal {\n        if (self.pointOf[nthEra][uid] < point) {\n            revert InsufficientPoint(nthEra, uid, self.pointOf[nthEra][uid], self.pointOf[nthEra][uid]);\n        }\n        self.pointOf[nthEra][uid] -= point;\n    }\n\n    function _totalPoints(Storage storage self, uint32 nthEra) internal view returns (uint64) {\n        return self.totalPointsOn[nthEra];\n    }\n\n    function _getTP(Storage storage self, uint32 uid, uint32 nthEra) internal view returns (uint64) {\n        return self.pointOf[nthEra][uid];\n    }\n\n    function _getTI(Storage storage self, uint32 uid, uint32 nthEra) internal view returns (uint8) {\n        return\n            self.totalPointsOn[nthEra] > 0 ? uint8((self.pointOf[nthEra][uid] * 100) / self.totalPointsOn[nthEra]) : 0;\n    }\n\n    function _getLevel(Storage storage self, uint32 uid, uint32 nthEra) internal view returns (uint8) {\n        // check if the uid is linked with premium\n        uint8 level = IAccountant(self.membership).getLvl(uid);\n        if (level == 9 || level == 10) {\n            return 8;\n        } else {\n            uint8 ti = self.totalPointsOn[nthEra] > 0\n                ? uint8((self.pointOf[nthEra][uid] * 100) / self.totalPointsOn[nthEra])\n                : 0;\n            if (ti >= 8) {\n                return 8;\n            } else {\n                return level >= ti ? level : ti;\n            }\n        }\n    }\n\n    function _getFeeRate(Storage storage self, uint32 uid, uint32 nthEra, bool isMaker)\n        internal\n        view\n        returns (uint32 feeNum)\n    {\n        uint8 level = _getLevel(self, uid, nthEra);\n        // get subscribed STND tokens\n        uint64 subSTND = IAccountant(self.membership).getSubSTND(uid);\n        // Perform different aclevelons based on the level\n        if (level == 0) {\n            if (subSTND >= 10000) {\n                // 0.0750% / 0.0750%\n                return 750;\n            } else {\n                // 0.1% / 0.1%\n                return 1000;\n            }\n        } else if (level == 1) {\n            if (subSTND >= 25000) {\n                // 0.0675 / 0.0750%\n                return isMaker ? 675 : 750;\n            } else {\n                // 0.09 / 0.1%\n                return isMaker ? 900 : 1000;\n            }\n        } else if (level == 2) {\n            if (subSTND >= 100000) {\n                // 0.0600% / 0.0750%\n                return isMaker ? 600 : 750;\n            } else {\n                // 0.0800% / 0.1000%\n                return isMaker ? 800 : 1000;\n            }\n        } else if (level == 3) {\n            if (subSTND >= 250000) {\n                // 0.0525% / 0.0750%\n                return isMaker ? 525 : 750;\n            } else {\n                // 0.0700% / 0.1000%\n                return isMaker ? 700 : 1000;\n            }\n        } else if (level == 4) {\n            if (subSTND >= 500000) {\n                // 0.045% / 0.0600%\n                return isMaker ? 450 : 600;\n            } else {\n                // 0.0600% / 0.0800%\n                return isMaker ? 600 : 800;\n            }\n        } else if (level == 5) {\n            if (subSTND >= 750000) {\n                // 0.0375% / 0.0525%\n                return isMaker ? 375 : 525;\n            } else {\n                // 0.0500% / 0.0700%\n                return isMaker ? 500 : 700;\n            }\n        } else if (level == 6) {\n            if (subSTND >= 1000000) {\n                // 0.03% / 0.045%\n                return isMaker ? 300 : 450;\n            } else {\n                // 0.0400% / 0.0600%\n                return isMaker ? 400 : 600;\n            }\n        } else if (level == 7) {\n            if (subSTND >= 1250000) {\n                // 0.0225% / 0.0375%\n                return isMaker ? 225 : 375;\n            } else {\n                // 0.0300% / 0.0500%\n                return isMaker ? 300 : 500;\n            }\n        } else if (level >= 8) {\n            if (subSTND >= 1500000) {\n                // 0.0150% / 0.0300%\n                return isMaker ? 150 : 300;\n            } else {\n                // 0.0200% / 0.0400%\n                return isMaker ? 200 : 400;\n            }\n        } else if (level >= 11) {\n            // when beta account is used, fee rate is zero\n            return 0;\n        }\n    }\n}\n"
        },
        "contracts/sabt/libraries/MembershipLib.sol": {
            "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.17;\n\nimport {TransferHelper} from \"./TransferHelper.sol\";\n\ninterface ISABT {\n    function mint(address to_, uint8 metaId_) external returns (uint32);\n\n    function balanceOf(address owner_, uint256 uid_) external view returns (uint256);\n\n    function setRegistered(uint256 id_, bool yesOrNo) external;\n\n    function metaId(uint32 uid_) external view returns (uint8);\n\n    function setMeta(uint32 uid_, uint8 meta_) external;\n\n    function getLvl(uint32 uid_) external view returns (uint8);\n}\n\nlibrary MembershipLib {\n    struct Member {\n        /// @dev mapping of member id to subscription status\n        mapping(uint32 => SubStatus) subscriptions;\n        /// @dev mapping of subscribed STND of member id\n        mapping(uint32 => uint64) subSTND;\n        /// @dev mapping of meta id to register fee status\n        mapping(uint8 => Meta) metas;\n        /// @dev mapping of meta id to register fee status\n        mapping(uint8 => mapping(address => Fees)) fees;\n        /// @dev address of SABT\n        address sabt;\n        /// @dev address of STND\n        address stnd;\n        /// @dev address of foundation\n        address foundation;\n        /// @dev address of WETH\n        address weth;\n    }\n\n    struct SubStatus {\n        uint256 at;\n        uint256 until;\n        uint256 bonus;\n        address with;\n    }\n\n    struct Meta {\n        uint8 metaId;\n        uint32 quota;\n    }\n\n    struct Fees {\n        address feeToken;\n        uint256 regFee;\n        uint256 subFee;\n    }\n\n    error InvalidFeeToken(address feeToken_, uint8 metaId_);\n    error MembershipNotOwned(uint32 uid, address owner);\n    error NoMultiTokenAccounting(address subscribedWith, address feeToken_);\n\n    function _setMembership(\n        Member storage self,\n        uint8 metaId_,\n        address feeToken_,\n        uint32 regFee_,\n        uint32 subFee_,\n        uint32 quota_\n    ) internal {\n        self.metas[metaId_].metaId = metaId_;\n        uint8 decimals = TransferHelper.decimals(feeToken_);\n        self.fees[metaId_][feeToken_].regFee = regFee_ * 10 ** decimals;\n        self.fees[metaId_][feeToken_].subFee = subFee_ * 10 ** decimals;\n        self.metas[metaId_].quota = quota_;\n    }\n\n    function _setQuota(Member storage self, uint8 metaId_, uint32 quota_) internal {\n        self.metas[metaId_].quota = quota_;\n    }\n\n    function _setMeta(Member storage self, uint32 uid_, uint8 metaId_) internal {\n        ISABT(self.sabt).setMeta(uid_, metaId_);\n    }\n\n    function _setSTND(Member storage self, address stnd) internal {\n        self.stnd = stnd;\n    }\n\n    function _setFees(Member storage self, uint8 metaId_, address feeToken_, uint256 regFee_, uint256 subFee_)\n        internal\n    {\n        uint8 decimals = TransferHelper.decimals(feeToken_);\n        self.fees[metaId_][feeToken_].regFee = regFee_ * 10 ** decimals;\n        self.fees[metaId_][feeToken_].subFee = subFee_ * 10 ** decimals;\n    }\n\n    function _register(Member storage self, uint8 metaId_, address feeToken_) internal returns (uint32 uid) {\n        uint256 regFee = self.fees[metaId_][feeToken_].regFee;\n        // check if the fee token is supported\n        if (regFee == 0) {\n            revert InvalidFeeToken(feeToken_, metaId_);\n        }\n        // Transfer required fund\n        TransferHelper.safeTransferFrom(feeToken_, msg.sender, address(this), regFee);\n        TransferHelper.safeTransfer(feeToken_, self.foundation, regFee);\n        // issue membership from SABT and get id\n        return ISABT(self.sabt).mint(msg.sender, metaId_);\n    }\n\n    /// @dev subscribe: Subscribe to the membership until certain block height\n    /// @param uid_ The uid of the ABT to subscribe with\n    /// @param blocks_ The number of blocks to subscribe\n    function _subscribe(Member storage self, uint32 uid_, uint64 blocks_, address feeToken_) internal {\n        // check if the member has the ABT with input id\n        if (ISABT(self.sabt).balanceOf(msg.sender, uid_) == 0) {\n            revert MembershipNotOwned(uid_, msg.sender);\n        }\n        uint256 bh = block.number;\n        uint8 metaId = ISABT(self.sabt).metaId(uid_);\n        SubStatus memory sub = self.subscriptions[uid_];\n        Fees memory fees = self.fees[metaId][feeToken_];\n        // check if previous subscription was done with the same token\n        if (sub.with != address(0) && sub.with != feeToken_) {\n            // if not, Ask user to unsubscribed with the previous token subscription\n            revert NoMultiTokenAccounting(sub.with, feeToken_);\n        }\n        // Transfer what has been already paid\n        TransferHelper.safeTransfer(\n            feeToken_,\n            self.foundation,\n            sub.until > bh ? fees.subFee * uint256(bh - sub.at) : fees.subFee * uint256(sub.until - sub.at)\n        );\n        // Transfer the tokens to this contract\n        TransferHelper.safeTransferFrom(feeToken_, msg.sender, address(this), fees.subFee * uint256(blocks_));\n\n        // subscribe for certain block\n        self.subscriptions[uid_].at = bh;\n        self.subscriptions[uid_].until = bh + blocks_;\n        self.subscriptions[uid_].with = feeToken_;\n        // if feeToken is STND, add it to the subSTND;\n        if (feeToken_ == self.stnd) {\n            self.subSTND[uid_] += uint64((fees.subFee * blocks_) / 1e18);\n        }\n    }\n\n    /// @dev unsubscribe: Unsubscribe from the membership\n    /// @param uid_ The id of the ABT to unsubscribe with\n    function _unsubscribe(Member storage self, uint32 uid_) internal {\n        // check if the member has the ABT with input id\n        if (ISABT(self.sabt).balanceOf(msg.sender, uid_) == 0) {\n            revert MembershipNotOwned(uid_, msg.sender);\n        }\n        uint256 bh = block.number;\n        uint8 metaId = ISABT(self.sabt).metaId(uid_);\n        SubStatus memory sub = self.subscriptions[uid_];\n        Fees memory fees = self.fees[metaId][sub.with];\n        if (sub.until > bh) {\n            // Transfer what has been already paid to foundation\n            TransferHelper.safeTransfer(sub.with, self.foundation, fees.subFee * (bh - sub.at));\n            if (sub.until - bh > sub.bonus) {\n                // Refund the tokens for future subscription to this contract\n                TransferHelper.safeTransfer(sub.with, msg.sender, fees.subFee * (sub.until - bh - sub.bonus));\n            }\n        }\n        // unsubscribe\n        self.subscriptions[uid_].until = 0;\n        self.subscriptions[uid_].at = 0;\n        self.subscriptions[uid_].bonus = 0;\n        self.subscriptions[uid_].with = address(0);\n        // subtract subSTND if STND was used to subscribe\n        if (sub.with == self.stnd) {\n            self.subSTND[uid_] -= uint64((fees.subFee * (sub.until - bh - sub.bonus)) / 1e18);\n        }\n    }\n\n    /// @dev offerBonus: Offer bonus blocks to the subscription by promoters\n    function _offerBonus(Member storage self, uint32 uid_, address holder_, uint256 blocks_) internal {\n        // check if the member has the ABT with input id\n        if (ISABT(self.sabt).balanceOf(holder_, uid_) == 0) {\n            revert MembershipNotOwned(uid_, holder_);\n        }\n        // Add the bonus blocks to the subscription\n        self.subscriptions[uid_].until += blocks_;\n        // Mark added bonus blocks in the subscription\n        self.subscriptions[uid_].bonus += blocks_;\n    }\n\n    function _balanceOf(Member storage self, address owner_, uint32 uid_) internal view returns (uint256) {\n        return ISABT(self.sabt).balanceOf(owner_, uid_);\n    }\n\n    function _isSubscribed(Member storage self, uint32 uid_) internal view returns (bool) {\n        return self.subscriptions[uid_].until > block.number;\n    }\n\n    function _getSubSTND(Member storage self, uint32 uid_) internal view returns (uint64) {\n        return self.subSTND[uid_];\n    }\n\n    function _getLvl(Member storage self, uint32 uid_) internal view returns (uint8) {\n        return ISABT(self.sabt).metaId(uid_);\n    }\n}\n"
        },
        "contracts/sabt/libraries/TransferHelper.sol": {
            "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.17;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint256 value) internal {\n        // bytes4(keccak256(bytes(\"approve(address,uint256)\")));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"AF\");\n    }\n\n    function safeTransfer(address token, address to, uint256 value) internal {\n        // bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TF\");\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint256 value) internal {\n        // bytes4(keccak256(bytes(\"transferFrom(address,address,uint256)\")));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TFF\");\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success,) = to.call{value: value}(new bytes(0));\n        require(success, \"ETF\");\n    }\n\n    function decimals(address token) internal view returns (uint8) {\n        // bytes4(keccak256(bytes(\"decimals()\")));\n        (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(0x313ce567));\n        require(success, \"DF\");\n        return abi.decode(data, (uint8));\n    }\n}\n"
        },
        "contracts/sabt/libraries/TreasuryLib.sol": {
            "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.17;\n\nimport {TransferHelper} from \"./TransferHelper.sol\";\n\ninterface ITreasury {\n    function balanceOf(address owner_, uint256 id_) external view returns (uint256);\n\n    function metaId(uint32 id_) external view returns (uint16);\n\n    function getTotalPoints(uint32 nthEra_) external view returns (uint256);\n\n    function getTotalTokens(uint32 nthEra_, address token_) external view returns (uint256);\n\n    function subtractTP(uint32 uid_, uint32 nthEra_, uint64 point_) external;\n\n    function getCurrentEra() external view returns (uint32);\n}\n\nlibrary TreasuryLib {\n    struct Storage {\n        address accountant;\n        address sabt;\n        mapping(uint32 => uint32) claims;\n        uint32 totalClaim;\n        uint32 settlementId;\n    }\n\n    uint8 internal constant USER_META_ID = 1;\n    uint8 internal constant EARLYADOPTER_META_ID = 9;\n    uint8 internal constant FOUNDATION_META_ID = 10;\n\n    uint32 internal constant DENOM = 100000;\n\n    struct Claim {\n        uint32 num;\n        uint32 denom;\n    }\n\n    error MembershipNotOwned(uint32 uid, address owner);\n    error InvalidMetaId(uint16 metaId, uint32 uid, uint16 real);\n    error EraNotPassed(uint32 nthEra, uint32 currentEra);\n    error NoTotalTP(uint32 nthEra, uint256 point);\n    error NoTotalTokens(uint32 nthEra, address token);\n\n    function _checkMembership(Storage storage self, uint32 uid_, uint16 metaId_) internal view {\n        // the sender owns the membership with UID\n        if (ITreasury(self.sabt).balanceOf(msg.sender, uid_) == 0) {\n            revert MembershipNotOwned(uid_, msg.sender);\n        }\n        uint16 uMeta = ITreasury(self.sabt).metaId(uid_);\n        if (uMeta != metaId_) {\n            revert InvalidMetaId(metaId_, uid_, uMeta);\n        }\n    }\n\n    function _checkEraPassed(Storage storage self, uint32 nthEra_) internal view {\n        // get current Era\n        uint32 currentEra = ITreasury(self.accountant).getCurrentEra();\n        if (nthEra_ >= currentEra) {\n            revert EraNotPassed(nthEra_, currentEra);\n        }\n    }\n\n    function _exchange(Storage storage self, address token, uint32 nthEra, uint32 uid, uint64 point) internal {\n        // check if the sender owns the membership with UID\n        if (ITreasury(self.sabt).balanceOf(msg.sender, uid) == 0) {\n            revert MembershipNotOwned(uid, msg.sender);\n        }\n        // check if the era has already passed\n        _checkEraPassed(self, nthEra);\n        // subtract membership point in accountant\n        ITreasury(self.accountant).subtractTP(uid, nthEra, point);\n        // exchange membership point with reward\n        uint256 reward = _getReward(self, token, nthEra, point);\n        // exchange reward with token\n        TransferHelper.safeTransfer(token, msg.sender, reward);\n    }\n\n    function _claim(Storage storage self, address token, uint32 nthEra, uint32 uid) internal {\n        // check if the sender has UID with early adoptor meta id\n        _checkMembership(self, uid, EARLYADOPTER_META_ID);\n        // check if the era has already passed\n        _checkEraPassed(self, nthEra);\n        // get reward from accountant\n        uint256 claim = _getClaim(self, token, uid, nthEra);\n        // exchange reward with token\n        TransferHelper.safeTransfer(token, msg.sender, claim);\n    }\n\n    function _settle(Storage storage self, address token, uint32 nthEra, uint32 uid) internal {\n        // check if the sender has UID with foundation meta id\n        _checkMembership(self, uid, FOUNDATION_META_ID);\n        // check if the era has already passed\n        _checkEraPassed(self, nthEra);\n        uint256 settlement = _getSettlement(self, token, nthEra);\n        TransferHelper.safeTransfer(token, msg.sender, settlement);\n    }\n\n    error ShareLimitExceeded(uint32 totalClaim, uint32 limit);\n\n    function _setClaim(Storage storage self, uint32 uid, uint32 num) internal {\n        self.claims[uid] = num;\n        self.totalClaim += num;\n        // check if total claim is less than or equal to 60.0000%\n        if (self.totalClaim > 600000) {\n            revert ShareLimitExceeded(self.totalClaim, 600000);\n        }\n    }\n\n    function _setSettlement(Storage storage self, uint32 uid) internal {\n        self.settlementId = uid;\n    }\n\n    function _getReward(Storage storage self, address token, uint32 nthEra, uint256 point)\n        internal\n        view\n        returns (uint256)\n    {\n        // get reward from Treasury ratio\n        // 1. get total supply of mp\n        uint256 totalTP = ITreasury(self.accountant).getTotalPoints(nthEra);\n        if (totalTP == 0) {\n            revert NoTotalTP(nthEra, totalTP);\n        }\n        // 2. get fee collected on nthEra\n        uint256 totalTokens = ITreasury(self.accountant).getTotalTokens(nthEra, token);\n        if (totalTokens == 0) {\n            revert NoTotalTokens(nthEra, token);\n        }\n        // 3. get reward from community Treasury ratio\n        return ((point * totalTokens * 4) / 10) / totalTP;\n    }\n\n    function _getClaim(Storage storage self, address token, uint32 uid, uint32 nthEra)\n        internal\n        view\n        returns (uint256)\n    {\n        // check if sender has UID\n        if (ITreasury(self.sabt).balanceOf(msg.sender, uid) == 0) {\n            revert MembershipNotOwned(uid, msg.sender);\n        }\n        // 1. get fee collected on nthEra\n        uint256 totalTokens = ITreasury(self.accountant).getTotalTokens(nthEra, token);\n        if (totalTokens == 0) {\n            revert NoTotalTokens(nthEra, token);\n        }\n        // 2. get reward from community Treasury ratio\n        return ((totalTokens * (self.claims[uid])) / DENOM);\n    }\n\n    function _getSettlement(Storage storage self, address token, uint32 nthEra) internal view returns (uint256) {\n        // check if sender has UID\n        if (ITreasury(self.sabt).balanceOf(msg.sender, self.settlementId) == 0) {\n            revert MembershipNotOwned(self.settlementId, msg.sender);\n        }\n        // 1. get fee collected on nthEra\n        uint256 totalTokens = ITreasury(self.accountant).getTotalTokens(nthEra, token);\n        if (totalTokens == 0) {\n            revert NoTotalTokens(nthEra, token);\n        }\n        // 2. get reward from community Treasury ratio\n        return ((totalTokens * (600000 - self.totalClaim)) / DENOM);\n    }\n}\n"
        },
        "contracts/safex/MatchingEngine.sol": {
            "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\nimport {IOrderbookFactory} from \"./interfaces/IOrderbookFactory.sol\";\nimport {IOrderbook, ExchangeOrderbook} from \"./interfaces/IOrderbook.sol\";\nimport {TransferHelper} from \"./libraries/TransferHelper.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {IWETH} from \"./interfaces/IWETH.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ninterface IRevenue {\n    function report(\n        uint32 uid,\n        address token,\n        uint256 amount,\n        bool isAdd\n    ) external;\n\n    function isReportable(\n        address token,\n        uint32 uid\n    ) external view returns (bool);\n\n    function refundFee(address to, address token, uint256 amount) external;\n\n    function feeOf(uint32 uid, bool isMaker) external returns (uint32 feeNum);\n}\n\n// Onchain Matching engine for the orders\ncontract MatchingEngine is Initializable, ReentrancyGuard {\n    // fee recipient\n    address private feeTo;\n    // fee denominator\n    uint32 public immutable feeDenom = 1000000;\n    // Factories\n    address public orderbookFactory;\n    // WETH\n    address public WETH;\n    struct OrderData {\n        uint256 withoutFee;\n        address orderbook;\n        uint256 lmp;\n        bool clear;\n    }\n\n    event OrderDeposit(\n        address sender,\n        address asset,\n        uint256 fee\n    );\n    \n    event OrderCanceled(\n        address orderbook,\n        uint256 id,\n        bool isBid,\n        address indexed owner,\n        uint256 amount\n    );\n\n    /**\n    * @dev This event is emitted when an order is successfully matched with a counterparty.\n    * @param orderbook The address of the order book contract to get base and quote asset contract address.\n    * @param id The unique identifier of the canceled order in bid/ask order database.\n    * @param isBid A boolean indicating whether the matched order is a bid (true) or ask (false).\n    * @param sender The address initiating the match.\n    * @param owner The address of the order owner whose order is matched with the sender.\n    * @param price The price at which the order is matched.\n    * @param amount The matched amount of the asset being traded in the match. if isBid==true, it is base asset, if isBid==false, it is quote asset.\n    */\n    event OrderMatched(\n        address orderbook,\n        uint256 id,\n        bool isBid,\n        address sender,\n        address owner,\n        uint256 price,\n        uint256 amount\n    );\n\n    \n    event OrderPlaced(\n        address orderbook,\n        uint256 id,\n        address owner,\n        bool isBid,\n        uint256 price,\n        uint256 amount\n    );\n\n    event PairAdded(address orderbook, address base, address quote);\n\n    error TooManyMatches(uint256 n);\n    error InvalidFeeRate(uint256 feeNum, uint256 feeDenom);\n    error NotContract(address newImpl);\n    error InvalidRole(bytes32 role, address sender);\n    error OrderSizeTooSmall(uint256 amount, uint256 minRequired);\n    error NoOrderMade(address base, address quote);\n    error InvalidPair(address base, address quote, address pair);\n\n    constructor() {\n    }\n\n    receive() external payable {\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\n    }\n\n    /**\n     * @dev Initialize the matching engine with orderbook factory and listing requirements.\n     * It can be called only once.\n     * @param orderbookFactory_ address of orderbook factory\n     * @param treasury_ address of treasury contract\n     * @param WETH_ address of wrapped ether contract\n     *\n     * Requirements:\n     * - `msg.sender` must have the default admin role.\n     */\n    function initialize(\n        address orderbookFactory_,\n        address treasury_,\n        address WETH_\n    ) external initializer {\n        orderbookFactory = orderbookFactory_;\n        feeTo = treasury_;\n        WETH = WETH_;\n    }\n\n    /**\n     * @dev Executes a market buy order,\n     * buys the base asset using the quote asset at the best available price in the orderbook up to `n` orders,\n     * and make an order at the market price.\n     * @param base The address of the base asset for the trading pair\n     * @param quote The address of the quote asset for the trading pair\n     * @param quoteAmount The amount of quote asset to be used for the market buy order\n     * @param isMaker Boolean indicating if a order should be made at the market price in orderbook\n     * @param n The maximum number of orders to match in the orderbook\n     * @param recipient The address of the order owner\n     * @return makePrice price where the order is placed\n     * @return matched matched amount\n     * @return placed placed amount\n     */\n    function marketBuy(\n        address base,\n        address quote,\n        uint256 quoteAmount,\n        bool isMaker,\n        uint32 n,\n        uint32 uid,\n        address recipient\n    )\n        public\n        nonReentrant\n        returns (uint256 makePrice, uint256 matched, uint256 placed)\n    {\n        OrderData memory orderData;\n        // reuse quoteAmount variable as minRequired from _deposit to avoid stack too deep error\n        (orderData.withoutFee, orderData.orderbook) = _deposit(\n            base,\n            quote,\n            0,\n            quoteAmount,\n            true,\n            uid,\n            isMaker\n        );\n\n        if (orderData.lmp == 0) {\n            orderData.lmp = mktPrice(base, quote);\n        }\n\n        // reuse withoutFee variable due to stack too deep error\n        (orderData.withoutFee, orderData.lmp, orderData.clear) = _limitOrder(\n            orderData.orderbook,\n            orderData.withoutFee,\n            quote,\n            recipient,\n            true,\n            type(uint256).max,\n            n\n        );\n\n        // add make order on market price\n        _detMake(\n            base,\n            quote,\n            orderData.orderbook,\n            orderData.withoutFee,\n            orderData.lmp,\n            true,\n            isMaker,\n            recipient\n        );\n\n        return (\n            orderData.lmp,\n            quoteAmount - orderData.withoutFee,\n            orderData.withoutFee\n        );\n    }\n\n    /**\n     * @dev Executes a market sell order,\n     * sells the base asset for the quote asset at the best available price in the orderbook up to `n` orders,\n     * and make an order at the market price.\n     * @param base The address of the base asset for the trading pair\n     * @param quote The address of the quote asset for the trading pair\n     * @param baseAmount The amount of base asset to be sold in the market sell order\n     * @param isMaker Boolean indicating if an order should be made at the market price in orderbook\n     * @param n The maximum number of orders to match in the orderbook\n     * @return makePrice price where the order is placed\n     * @return matched matched amount\n     * @return placed placed amount\n     */\n    function marketSell(\n        address base,\n        address quote,\n        uint256 baseAmount,\n        bool isMaker,\n        uint32 n,\n        uint32 uid,\n        address recipient\n    )\n        public\n        nonReentrant\n        returns (uint256 makePrice, uint256 matched, uint256 placed)\n    {\n        OrderData memory orderData;\n        (orderData.withoutFee, orderData.orderbook) = _deposit(\n            base,\n            quote,\n            0,\n            baseAmount,\n            false,\n            uid,\n            isMaker\n        );\n\n        if (orderData.lmp == 0) {\n            orderData.lmp = mktPrice(base, quote);\n        }\n\n        // reuse withoutFee variable for storing remaining amount after matching due to stack too deep error\n        (orderData.withoutFee, orderData.lmp, orderData.clear) = _limitOrder(\n            orderData.orderbook,\n            orderData.withoutFee,\n            base,\n            recipient,\n            false,\n            0,\n            n\n        );\n\n        _detMake(\n            base,\n            quote,\n            orderData.orderbook,\n            orderData.withoutFee,\n            orderData.lmp,\n            false,\n            isMaker,\n            recipient\n        );\n        return (\n            orderData.lmp,\n            baseAmount - orderData.withoutFee,\n            orderData.withoutFee\n        );\n    }\n\n    /**\n     * @dev Executes a market buy order,\n     * buys the base asset using the quote asset at the best available price in the orderbook up to `n` orders,\n     * and make an order at the market price with quote asset as native Ethereum(or other network currencies).\n     * @param base The address of the base asset for the trading pair\n     * @param isMaker Boolean indicating if a order should be made at the market price in orderbook\n     * @param n The maximum number of orders to match in the orderbook\n     * @param recipient The address of the recipient to receive traded asset and claim ownership of made order\n     * @return makePrice price where the order is placed\n     * @return matched matched amount\n     * @return placed placed amount\n     */\n    function marketBuyETH(\n        address base,\n        bool isMaker,\n        uint32 n,\n        uint32 uid,\n        address recipient\n    )\n        external\n        payable\n        returns (uint256 makePrice, uint256 matched, uint256 placed)\n    {\n        IWETH(WETH).deposit{value: msg.value}();\n        return marketBuy(base, WETH, msg.value, isMaker, n, uid, recipient);\n    }\n\n    /**\n     * @dev Executes a market sell order,\n     * sells the base asset for the quote asset at the best available price in the orderbook up to `n` orders,\n     * and make an order at the market price with base asset as native Ethereum(or other network currencies).\n     * @param quote The address of the quote asset for the trading pair\n     * @param isMaker Boolean indicating if an order should be made at the market price in orderbook\n     * @param n The maximum number of orders to match in the orderbook\n     * @param recipient The address of the recipient to receive traded asset and claim ownership of made order\n     * @return makePrice price where the order is placed\n     * @return matched matched amount\n     * @return placed placed amount\n     */\n    function marketSellETH(\n        address quote,\n        bool isMaker,\n        uint32 n,\n        uint32 uid,\n        address recipient\n    )\n        external\n        payable\n        returns (uint256 makePrice, uint256 matched, uint256 placed)\n    {\n        IWETH(WETH).deposit{value: msg.value}();\n        return marketSell(WETH, quote, msg.value, isMaker, n, uid, recipient);\n    }\n\n    /**\n     * @dev Executes a limit buy order,\n     * places a limit order in the orderbook for buying the base asset using the quote asset at a specified price,\n     * and make an order at the limit price.\n     * @param base The address of the base asset for the trading pair\n     * @param quote The address of the quote asset for the trading pair\n     * @param price The price, base/quote regardless of decimals of the assets in the pair represented with 8 decimals (if 1000, base is 1000x quote)\n     * @param quoteAmount The amount of quote asset to be used for the limit buy order\n     * @param isMaker Boolean indicating if an order should be made at the limit price\n     * @param n The maximum number of orders to match in the orderbook\n     * @param recipient The address of the recipient to receive traded asset and claim ownership of made order\n     * @return makePrice price where the order is placed\n     * @return matched matched amount\n     * @return placed placed amount\n     */\n    function limitBuy(\n        address base,\n        address quote,\n        uint256 price,\n        uint256 quoteAmount,\n        bool isMaker,\n        uint32 n,\n        uint32 uid,\n        address recipient\n    )\n        public\n        nonReentrant\n        returns (uint256 makePrice, uint256 matched, uint256 placed)\n    {\n        OrderData memory orderData;\n        (orderData.withoutFee, orderData.orderbook) = _deposit(\n            base,\n            quote,\n            price,\n            quoteAmount,\n            true,\n            uid,\n            isMaker\n        );\n        // reuse withoutFee variable for storing remaining amount after matching due to stack too deep error\n        (orderData.withoutFee, orderData.lmp, orderData.clear) = _limitOrder(\n            orderData.orderbook,\n            orderData.withoutFee,\n            quote,\n            recipient,\n            true,\n            price,\n            n\n        );\n\n        _detMake(\n            base,\n            quote,\n            orderData.orderbook,\n            orderData.withoutFee,\n            orderData.clear ? price : orderData.lmp == 0\n                ? price\n                : orderData.lmp,\n            true,\n            isMaker,\n            recipient\n        );\n        return (\n            orderData.lmp,\n            quoteAmount - orderData.withoutFee,\n            orderData.withoutFee\n        );\n    }\n\n    /**\n     * @dev Executes a limit sell order,\n     * places a limit order in the orderbook for selling the base asset for the quote asset at a specified price,\n     * and makes an order at the limit price.\n     * @param base The address of the base asset for the trading pair\n     * @param quote The address of the quote asset for the trading pair\n     * @param price The price, base/quote regardless of decimals of the assets in the pair represented with 8 decimals (if 1000, base is 1000x quote)\n     * @param baseAmount The amount of base asset to be used for the limit sell order\n     * @param isMaker Boolean indicating if an order should be made at the limit price\n     * @param n The maximum number of orders to match in the orderbook\n     * @return makePrice price where the order is placed\n     * @return matched matched amount\n     * @return placed placed amount\n     */\n    function limitSell(\n        address base,\n        address quote,\n        uint256 price,\n        uint256 baseAmount,\n        bool isMaker,\n        uint32 n,\n        uint32 uid,\n        address recipient\n    )\n        public\n        nonReentrant\n        returns (uint256 makePrice, uint256 matched, uint256 placed)\n    {\n        OrderData memory orderData;\n        (orderData.withoutFee, orderData.orderbook) = _deposit(\n            base,\n            quote,\n            price,\n            baseAmount,\n            false,\n            uid,\n            isMaker\n        );\n        // reuse withoutFee variable for storing remaining amount after matching due to stack too deep error\n        (orderData.withoutFee, orderData.lmp, orderData.clear) = _limitOrder(\n            orderData.orderbook,\n            orderData.withoutFee,\n            base,\n            recipient,\n            false,\n            price,\n            n\n        );\n        _detMake(\n            base,\n            quote,\n            orderData.orderbook,\n            orderData.withoutFee,\n            orderData.clear ? price : orderData.lmp == 0\n                ? price\n                : orderData.lmp,\n            false,\n            isMaker,\n            recipient\n        );\n        return (\n            orderData.lmp,\n            baseAmount - orderData.withoutFee,\n            orderData.withoutFee\n        );\n    }\n\n    /**\n     * @dev Executes a limit buy order,\n     * places a limit order in the orderbook for buying the base asset using the quote asset at a specified price,\n     * and make an order at the limit price with quote asset as native Ethereum(or network currencies).\n     * @param base The address of the base asset for the trading pair\n     * @param isMaker Boolean indicating if a order should be made at the market price in orderbook\n     * @param n The maximum number of orders to match in the orderbook\n     * @param recipient The address of the recipient to receive traded asset and claim ownership of made order\n     * @return makePrice price where the order is placed\n     * @return matched matched amount\n     * @return placed placed amount\n     */\n    function limitBuyETH(\n        address base,\n        uint256 price,\n        bool isMaker,\n        uint32 n,\n        uint32 uid,\n        address recipient\n    )\n        external\n        payable\n        returns (uint256 makePrice, uint256 matched, uint256 placed)\n    {\n        IWETH(WETH).deposit{value: msg.value}();\n        return\n            limitBuy(base, WETH, price, msg.value, isMaker, n, uid, recipient);\n    }\n\n    /**\n     * @dev Executes a limit sell order,\n     * places a limit order in the orderbook for selling the base asset for the quote asset at a specified price,\n     * and makes an order at the limit price with base asset as native Ethereum(or network currencies).\n     * @param quote The address of the quote asset for the trading pair\n     * @param isMaker Boolean indicating if an order should be made at the market price in orderbook\n     * @param n The maximum number of orders to match in the orderbook\n     * @param recipient The address of the recipient to receive traded asset and claim ownership of made order\n     * @return makePrice price where the order is placed\n     * @return matched matched amount\n     * @return placed placed amount\n     */\n    function limitSellETH(\n        address quote,\n        uint256 price,\n        bool isMaker,\n        uint32 n,\n        uint32 uid,\n        address recipient\n    )\n        external\n        payable\n        returns (uint256 makePrice, uint256 matched, uint256 placed)\n    {\n        IWETH(WETH).deposit{value: msg.value}();\n        return\n            limitSell(\n                WETH,\n                quote,\n                price,\n                msg.value,\n                isMaker,\n                n,\n                uid,\n                recipient\n            );\n    }\n\n    /**\n     * @dev Creates an orderbook for a new trading pair and returns its address\n     * @param base The address of the base asset for the trading pair\n     * @param quote The address of the quote asset for the trading pair\n     * @return book The address of the newly created orderbook\n     */\n    function addPair(\n        address base,\n        address quote\n    ) public returns (address book) {\n        // create orderbook for the pair\n        address orderBook = IOrderbookFactory(orderbookFactory).createBook(\n            base,\n            quote\n        );\n        emit PairAdded(orderBook, base, quote);\n        return orderBook;\n    }\n\n    /**\n     * @dev Cancels an order in an orderbook by the given order ID and order type.\n     * @param base The address of the base asset for the trading pair\n     * @param quote The address of the quote asset for the trading pair\n     * @param isBid Boolean indicating if the order to cancel is an ask order\n     * @param orderId The ID of the order to cancel\n     * @return refunded Refunded amount from order\n     */\n    function cancelOrder(\n        address base,\n        address quote,\n        bool isBid,\n        uint32 orderId,\n        uint32 uid\n    ) public nonReentrant returns (uint256 refunded) {\n        address orderbook = IOrderbookFactory(orderbookFactory).getPair(\n            base,\n            quote\n        );\n\n        if (orderbook == address(0)) {\n            revert InvalidPair(base, quote, orderbook);\n        }\n\n        uint256 remaining = IOrderbook(orderbook).cancelOrder(\n            isBid,\n            orderId,\n            msg.sender\n        );\n        // decrease point from orderbook\n        if (uid != 0 && IRevenue(feeTo).isReportable(msg.sender, uid)) {\n            // report cancelation to accountant\n            IRevenue(feeTo).report(uid, isBid ? quote : base, remaining, false);\n            // refund fee from treasury to sender\n            IRevenue(feeTo).refundFee(\n                msg.sender,\n                isBid ? quote : base,\n                (remaining * 100) / feeDenom\n            );\n        }\n\n        emit OrderCanceled(orderbook, orderId, isBid, msg.sender, remaining);\n        return remaining;\n    }\n\n    function cancelOrders(\n        address[] memory base,\n        address[] memory quote,\n        bool[] memory isBid,\n        uint32[] memory orderIds,\n        uint32 uid\n    ) external returns (uint256[] memory refunded) {\n        refunded = new uint256[](orderIds.length);\n        for (uint32 i = 0; i < orderIds.length; i++) {\n            refunded[i] = cancelOrder(\n                base[i],\n                quote[i],\n                isBid[i],\n                orderIds[i],\n                uid\n            );\n        }\n        return refunded;\n    }\n\n    /**\n     * @dev Cancels an order in an orderbook by the given order ID and order type.\n     * @param base The address of the base asset for the trading pair\n     * @param quote The address of the quote asset for the trading pair\n     * @param price The price of the order to rematch\n     * @param orderId The ID of the order to cancel\n     * @param isBid Boolean indicating if the order to cancel is an ask order\n     * @param uid The ID of the user\n     * @return makePrice price where the order is placed\n     * @return matched matched amount of an order\n     * @return placed placed amount of an order\n     */\n    function rematchOrder(\n        address base,\n        address quote,\n        uint256 price,\n        bool isBid,\n        uint32 orderId,\n        bool isMarket,\n        bool isMaker,\n        uint32 n,\n        uint32 uid\n    )\n        external\n        nonReentrant\n        returns (uint256 makePrice, uint256 matched, uint256 placed)\n    {\n        address orderbook = IOrderbookFactory(orderbookFactory).getPair(\n            base,\n            quote\n        );\n        uint256 remaining = IOrderbook(orderbook).cancelOrder(\n            isBid,\n            orderId,\n            msg.sender\n        );\n        if (isBid) {\n            if (isMarket) {\n                return\n                    marketBuy(\n                        base,\n                        quote,\n                        remaining,\n                        isMaker,\n                        n,\n                        uid,\n                        msg.sender\n                    );\n            } else {\n                return\n                    limitBuy(\n                        base,\n                        quote,\n                        price,\n                        remaining,\n                        isMaker,\n                        n,\n                        uid,\n                        msg.sender\n                    );\n            }\n        } else {\n            if (isMarket) {\n                return\n                    marketSell(\n                        base,\n                        quote,\n                        remaining,\n                        isMaker,\n                        n,\n                        uid,\n                        msg.sender\n                    );\n            } else {\n                return\n                    limitSell(\n                        base,\n                        quote,\n                        price,\n                        remaining,\n                        isMaker,\n                        n,\n                        uid,\n                        msg.sender\n                    );\n            }\n        }\n    }\n\n    /**\n     * @dev Returns the address of the orderbook with the given ID.\n     * @param id The ID of the orderbook to retrieve.\n     * @return The address of the orderbook.\n     */\n    function getOrderbookById(uint256 id) external view returns (address) {\n        return IOrderbookFactory(orderbookFactory).getBook(id);\n    }\n\n    /**\n     * @dev Returns the base and quote asset addresses for the given orderbook.\n     * @param orderbook The address of the orderbook to retrieve the base and quote asset addresses for.\n     * @return base The address of the base asset.\n     * @return quote The address of the quote asset.\n     */\n    function getBaseQuote(\n        address orderbook\n    ) external view returns (address base, address quote) {\n        return IOrderbookFactory(orderbookFactory).getBaseQuote(orderbook);\n    }\n    \n    /**\n     * @dev returns addresses of pairs in OrderbookFactory registry\n     * @return pairs list of pairs from start to end\n     */\n    function getPairs(\n        uint256 start,\n        uint256 end\n    ) external view returns (IOrderbookFactory.Pair[] memory pairs) {\n        return IOrderbookFactory(orderbookFactory).getPairs(start, end);\n    }\n\n    /**\n     * @dev returns addresses of pairs in OrderbookFactory registry\n     * @return pairs list of pairs from start to end\n     */\n    function getPairsWithIds(\n        uint256[] memory ids\n    ) external view returns (IOrderbookFactory.Pair[] memory pairs) {\n        return IOrderbookFactory(orderbookFactory).getPairsWithIds(ids);\n    }\n\n    /**\n     * @dev returns addresses of pairs in OrderbookFactory registry\n     * @return names list of pair names from start to end\n     */\n    function getPairNames(\n        uint256 start,\n        uint256 end\n    ) external view returns (string[] memory names) {\n        return IOrderbookFactory(orderbookFactory).getPairNames(start, end);\n    }\n\n    /**\n     * @dev returns addresses of pairs in OrderbookFactory registry\n     * @return names list of pair names from start to end\n     */\n    function getPairNamesWithIds(\n        uint256[] memory ids\n    ) external view returns (string[] memory names) {\n        return IOrderbookFactory(orderbookFactory).getPairNamesWithIds(ids);\n    }\n\n    /**\n     * @dev returns addresses of pairs in OrderbookFactory registry\n     * @return mktPrices list of mktPrices from start to end\n     */\n    function getMktPrices(\n        uint256 start,\n        uint256 end\n    ) external view returns (uint256[] memory mktPrices) {\n        IOrderbookFactory.Pair[] memory pairs = IOrderbookFactory(\n            orderbookFactory\n        ).getPairs(start, end);\n        mktPrices = new uint256[](pairs.length);\n        for (uint256 i = 0; i < pairs.length; i++) {\n            try this.mktPrice(pairs[i].base, pairs[i].quote) returns (\n                uint256 price\n            ) {\n                uint256 p = price;\n                mktPrices[i] = p;\n            } catch {\n                uint256 p = 0;\n                mktPrices[i] = p;\n            }\n        }\n        return mktPrices;\n    }\n\n    /**\n     * @dev returns addresses of pairs in OrderbookFactory registry\n     * @return mktPrices list of mktPrices from start to end\n     */\n    function getMktPricesWithIds(\n        uint256[] memory ids\n    ) external view returns (uint256[] memory mktPrices) {\n        IOrderbookFactory.Pair[] memory pairs = IOrderbookFactory(\n            orderbookFactory\n        ).getPairsWithIds(ids);\n        mktPrices = new uint256[](pairs.length);\n        for (uint256 i = 0; i < pairs.length; i++) {\n            try this.mktPrice(pairs[i].base, pairs[i].quote) returns (\n                uint256 price\n            ) {\n                uint256 p = price;\n                mktPrices[i] = p;\n            } catch {\n                uint256 p = 0;\n                mktPrices[i] = p;\n            }\n        }\n        return mktPrices;\n    }\n\n    /**\n     * @dev Returns prices in the ask/bid orderbook for the given trading pair.\n     * @param base The address of the base asset for the trading pair.\n     * @param quote The address of the quote asset for the trading pair.\n     * @param isBid Boolean indicating if the orderbook to retrieve prices from is an ask orderbook.\n     * @param n The number of prices to retrieve.\n     */\n    function getPrices(\n        address base,\n        address quote,\n        bool isBid,\n        uint32 n\n    ) external view returns (uint256[] memory) {\n        address orderbook = getPair(base, quote);\n        return IOrderbook(orderbook).getPrices(isBid, n);\n    }\n\n    /**\n     * @dev Returns orders in the ask/bid orderbook for the given trading pair in a price.\n     * @param base The address of the base asset for the trading pair.\n     * @param quote The address of the quote asset for the trading pair.\n     * @param isBid Boolean indicating if the orderbook to retrieve orders from is an ask orderbook.\n     * @param price The price to retrieve orders from.\n     * @param n The number of orders to retrieve.\n     */\n    function getOrders(\n        address base,\n        address quote,\n        bool isBid,\n        uint256 price,\n        uint32 n\n    ) external view returns (ExchangeOrderbook.Order[] memory) {\n        address orderbook = getPair(base, quote);\n        return IOrderbook(orderbook).getOrders(isBid, price, n);\n    }\n\n    /**\n     * @dev Returns an order in the ask/bid orderbook for the given trading pair with order id.\n     * @param base The address of the base asset for the trading pair.\n     * @param quote The address of the quote asset for the trading pair.\n     * @param isBid Boolean indicating if the orderbook to retrieve orders from is an ask orderbook.\n     * @param orderId The order id to retrieve.\n     */\n    function getOrder(\n        address base,\n        address quote,\n        bool isBid,\n        uint32 orderId\n    ) external view returns (ExchangeOrderbook.Order memory) {\n        address orderbook = getPair(base, quote);\n        return IOrderbook(orderbook).getOrder(isBid, orderId);\n    }\n\n    /**\n     * @dev Returns order ids in the ask/bid orderbook for the given trading pair in a price.\n     * @param base The address of the base asset for the trading pair.\n     * @param quote The address of the quote asset for the trading pair.\n     * @param isBid Boolean indicating if the orderbook to retrieve orders from is an ask orderbook.\n     * @param price The price to retrieve orders from.\n     * @param n The number of order ids to retrieve.\n     */\n    function getOrderIds(\n        address base,\n        address quote,\n        bool isBid,\n        uint256 price,\n        uint32 n\n    ) external view returns (uint32[] memory) {\n        address orderbook = getPair(base, quote);\n        return IOrderbook(orderbook).getOrderIds(isBid, price, n);\n    }\n\n    /**\n     * @dev Returns the address of the orderbook for the given base and quote asset addresses.\n     * @param base The address of the base asset for the trading pair.\n     * @param quote The address of the quote asset for the trading pair.\n     * @return book The address of the orderbook.\n     */\n    function getPair(\n        address base,\n        address quote\n    ) public view returns (address book) {\n        return IOrderbookFactory(orderbookFactory).getPair(base, quote);\n    }\n\n    function heads(\n        address base,\n        address quote\n    ) external view returns (uint256 bidHead, uint256 askHead) {\n        address orderbook = getPair(base, quote);\n        return IOrderbook(orderbook).heads();\n    }\n\n    function mktPrice(\n        address base,\n        address quote\n    ) public view returns (uint256) {\n        address orderbook = getPair(base, quote);\n        return IOrderbook(orderbook).mktPrice();\n    }\n\n    /**\n     * @dev return converted amount from base to quote or vice versa\n     * @param base address of base asset\n     * @param quote address of quote asset\n     * @param amount amount of base or quote asset\n     * @param isBid if true, amount is quote asset, otherwise base asset\n     * @return converted converted amount from base to quote or vice versa.\n     * if true, amount is quote asset, otherwise base asset\n     * if orderbook does not exist, return 0\n     */\n    function convert(\n        address base,\n        address quote,\n        uint256 amount,\n        bool isBid\n    ) public view returns (uint256 converted) {\n        address orderbook = getPair(base, quote);\n        if (base == quote) {\n            return amount;\n        } else if (orderbook == address(0)) {\n            return 0;\n        } else {\n            return IOrderbook(orderbook).assetValue(amount, isBid);\n        }\n    }\n\n    /**\n     * @dev Internal function which makes an order on the orderbook.\n     * @param orderbook The address of the orderbook contract for the trading pair\n     * @param withoutFee The remaining amount of the asset after the market order has been executed\n     * @param price The price, base/quote regardless of decimals of the assets in the pair represented with 8 decimals (if 1000, base is 1000x quote)\n     * @param isBid Boolean indicating if the order is a buy (false) or a sell (true)\n     * @param recipient The address of the recipient to receive traded asset and claim ownership of made order\n     */\n    function _makeOrder(\n        address orderbook,\n        uint256 withoutFee,\n        uint256 price,\n        bool isBid,\n        address recipient\n    ) internal {\n        uint32 id;\n        // create order\n        if (isBid) {\n            id = IOrderbook(orderbook).placeBid(recipient, price, withoutFee);\n        } else {\n            id = IOrderbook(orderbook).placeAsk(recipient, price, withoutFee);\n        }\n\n        emit OrderPlaced(orderbook, id, recipient, isBid, price, withoutFee);\n    }\n\n    /**\n     * @dev Match bid if `isBid` is true, match ask if `isBid` is false.\n     */\n    function _matchAt(\n        address orderbook,\n        address give,\n        address recipient,\n        bool isBid,\n        uint256 amount,\n        uint256 price,\n        uint32 i,\n        uint32 n\n    ) internal returns (uint256 remaining, uint32 k) {\n        if (n > 20) {\n            revert TooManyMatches(n);\n        }\n        remaining = amount;\n        while (\n            remaining > 0 &&\n            !IOrderbook(orderbook).isEmpty(!isBid, price) &&\n            i < n\n        ) {\n            // fpop OrderLinkedList by price, if ask you get bid order, if bid you get ask order. Get quote asset on bid order on buy, base asset on ask order on sell\n            (uint32 orderId, uint256 required) = IOrderbook(orderbook).fpop(\n                !isBid,\n                price,\n                remaining\n            );\n            // order exists, and amount is not 0\n            if (remaining <= required) {\n                // set last matching price\n                IOrderbook(orderbook).setLmp(price);\n                // execute order\n                TransferHelper.safeTransfer(give, orderbook, remaining);\n                address owner = IOrderbook(orderbook).execute(\n                    orderId,\n                    !isBid,\n                    recipient,\n                    remaining\n                );\n                // emit event order matched\n                emit OrderMatched(\n                    orderbook,\n                    orderId,\n                    isBid,\n                    recipient,\n                    owner,\n                    price,\n                    remaining\n                );\n                // end loop as remaining is 0\n                return (0, n);\n            }\n            // order is null\n            else if (required == 0) {\n                ++i;\n                continue;\n            }\n            // remaining >= depositAmount\n            else {\n                remaining -= required;\n                TransferHelper.safeTransfer(give, orderbook, required);\n                address owner = IOrderbook(orderbook).execute(\n                    orderId,\n                    !isBid,\n                    recipient,\n                    required\n                );\n                // emit event order matched\n                emit OrderMatched(\n                    orderbook,\n                    orderId,\n                    isBid,\n                    recipient,\n                    owner,\n                    price,\n                    required\n                );\n                ++i;\n            }\n        }\n        k = i;\n        return (remaining, k);\n    }\n\n    /**\n     * @dev Executes limit order by matching orders in the orderbook based on the provided limit price.\n     * @param orderbook The address of the orderbook to execute the limit order on.\n     * @param amount The amount of asset to trade.\n     * @param give The address of the asset to be traded.\n     * @param recipient The address to receive asset after matching a trade\n     * @param isBid True if the order is an ask (sell) order, false if it is a bid (buy) order.\n     * @param limitPrice The maximum price at which the order can be executed.\n     * @param n The maximum number of matches to execute.\n     * @return remaining The remaining amount of asset that was not traded.\n     */\n    function _limitOrder(\n        address orderbook,\n        uint256 amount,\n        address give,\n        address recipient,\n        bool isBid,\n        uint256 limitPrice,\n        uint32 n\n    ) internal returns (uint256 remaining, uint256 lmp, bool clear) {\n        remaining = amount;\n        lmp = 0;\n        uint32 i = 0;\n        if (isBid) {\n            // check if there is any matching ask order until matching ask order price is lower than the limit bid Price\n            uint256 askHead = IOrderbook(orderbook).clearEmptyHead(false);\n            while (\n                remaining > 0 && askHead != 0 && askHead <= limitPrice && i < n\n            ) {\n                lmp = askHead;\n                (remaining, i) = _matchAt(\n                    orderbook,\n                    give,\n                    recipient,\n                    isBid,\n                    remaining,\n                    askHead,\n                    i,\n                    n\n                );\n                // i == 0 when orders are all empty and only head price is left\n                askHead = i == 0\n                    ? 0\n                    : IOrderbook(orderbook).clearEmptyHead(false);\n            }\n            // set last match price\n            if (lmp != 0) {\n                IOrderbook(orderbook).setLmp(lmp);\n            }\n            return (remaining, lmp, askHead == 0);\n        } else {\n            // check if there is any maching bid order until matching bid order price is higher than the limit ask price\n            uint256 bidHead = IOrderbook(orderbook).clearEmptyHead(true);\n            while (\n                remaining > 0 && bidHead != 0 && bidHead >= limitPrice && i < n\n            ) {\n                lmp = bidHead;\n                (remaining, i) = _matchAt(\n                    orderbook,\n                    give,\n                    recipient,\n                    isBid,\n                    remaining,\n                    bidHead,\n                    i,\n                    n\n                );\n                // i == 0 when orders are all empty and only head price is left\n                bidHead = i == 0\n                    ? 0\n                    : IOrderbook(orderbook).clearEmptyHead(true);\n            }\n            // set last match price\n            if (lmp != 0) {\n                IOrderbook(orderbook).setLmp(lmp);\n            }\n            return (remaining, lmp, bidHead == 0);\n        }\n    }\n\n    /**\n     * @dev Determines if an order can be made at the market price,\n     * and if so, makes the an order on the orderbook.\n     * If an order cannot be made, transfers the remaining asset to either the orderbook or the user.\n     * @param base The address of the base asset for the trading pair\n     * @param quote The address of the quote asset for the trading pair\n     * @param orderbook The address of the orderbook contract for the trading pair\n     * @param remaining The remaining amount of the asset after the market order has been taken\n     * @param price The price used to determine if an order can be made\n     * @param isBid Boolean indicating if the order was a buy (true) or a sell (false)\n     * @param isMaker Boolean indicating if an order is for storing in orderbook\n     * @param recipient The address to receive asset after matching a trade and making an order\n     */\n    function _detMake(\n        address base,\n        address quote,\n        address orderbook,\n        uint256 remaining,\n        uint256 price,\n        bool isBid,\n        bool isMaker,\n        address recipient\n    ) internal {\n        if (remaining > 0) {\n            address stopTo = isMaker ? orderbook : recipient;\n            TransferHelper.safeTransfer(\n                isBid ? quote : base,\n                stopTo,\n                remaining\n            );\n            if (isMaker)\n                _makeOrder(orderbook, remaining, price, isBid, recipient);\n        }\n    }\n\n    /**\n     * @dev Deposit amount of asset to the contract with the given asset information and subtracts the fee.\n     * @param base The address of the base asset.\n     * @param quote The address of the quote asset.\n     * @param amount The amount of asset to deposit.\n     * @param isBid Whether it is an ask order or not.\n     * If ask, the quote asset is transferred to the contract.\n     * @return withoutFee The amount of asset without the fee.\n     * @return book The address of the orderbook for the given asset pair.\n     */\n    function _deposit(\n        address base,\n        address quote,\n        uint256 price,\n        uint256 amount,\n        bool isBid,\n        uint32 uid,\n        bool isMaker\n    ) internal returns (uint256 withoutFee, address book) {\n        // get orderbook address from the base and quote asset\n        book = getPair(base, quote);\n        if (book == address(0)) {\n            book = addPair(base, quote);\n        }\n        // check if amount is valid in case of both market and limit\n        uint256 converted = _convert(book, price, amount, !isBid);\n\n        if (converted == 0) {\n            revert OrderSizeTooSmall(amount, _convert(book, price, 1, isBid));\n        }\n        // check if sender has uid\n        uint256 fee = _fee(base, quote, amount, isBid, uid, isMaker);\n        withoutFee = amount - fee;\n        if (isBid) {\n            // transfer input asset give user to this contract\n            if (quote != WETH) {\n                TransferHelper.safeTransferFrom(\n                    quote,\n                    msg.sender,\n                    address(this),\n                    amount\n                );\n            }\n            TransferHelper.safeTransfer(quote, feeTo, fee);\n        } else {\n            // transfer input asset give user to this contract\n            if (base != WETH) {\n                TransferHelper.safeTransferFrom(\n                    base,\n                    msg.sender,\n                    address(this),\n                    amount\n                );\n            }\n            TransferHelper.safeTransfer(base, feeTo, fee);\n        }\n        emit OrderDeposit(msg.sender, isBid ? quote : base, fee);\n        return (withoutFee, book);\n    }\n\n    function _fee(\n        address base,\n        address quote,\n        uint256 amount,\n        bool isBid,\n        uint32 uid,\n        bool isMaker\n    ) internal returns (uint256 fee) {\n        if (uid != 0 && IRevenue(feeTo).isReportable(msg.sender, uid)) {\n            uint32 feeNum = IRevenue(feeTo).feeOf(uid, isMaker);\n            // report fee to accountant\n            IRevenue(feeTo).report(uid, isBid ? quote : base, amount, true);\n            return (amount * feeNum) / feeDenom;\n        } else {\n            return amount / 1000;\n        }\n    }\n\n    /**\n     * @dev return converted amount from base to quote or vice versa\n     * @param orderbook address of orderbook\n     * @param price price of base/quote regardless of decimals of the assets in the pair represented with 8 decimals (if 1000, base is 1000x quote) proposed by a trader\n     * @param amount amount of base or quote asset\n     * @param isBid if true, amount is quote asset, otherwise base asset\n     * @return converted converted amount from base to quote or vice versa.\n     * if true, amount is quote asset, otherwise base asset\n     * if orderbook does not exist, return 0\n     */\n    function _convert(\n        address orderbook,\n        uint256 price,\n        uint256 amount,\n        bool isBid\n    ) internal view returns (uint256 converted) {\n        if (orderbook == address(0)) {\n            return 0;\n        } else {\n            return\n                price == 0\n                    ? IOrderbook(orderbook).assetValue(amount, isBid)\n                    : IOrderbook(orderbook).convert(price, amount, isBid);\n        }\n    }\n}\n"
        },
        "contracts/safex/airdrops/TokenDispenser.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title TokenDispenser\n * @dev A contract that dispenses specific amounts of tokens to users on request.\n * Only an admin can set the amount for each token.\n */\ncontract TokenDispenser is AccessControl {\n\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n    mapping(address => uint256) public tokenAmounts;\n    mapping(address => mapping(address => bool)) public received;\n\n    // Custom error types\n    error NotAdmin();\n    error TokenNotSupported();\n    error TokensAlreadyReceived();\n    error TokenTransferFailed();\n\n    /**\n     * @dev Constructor that gives the deployer the default admin role.\n     */\n    constructor() {\n        _setupRole(ADMIN_ROLE, msg.sender);\n    }\n\n    /**\n     * @dev Sets the amount of a specific token to dispense.\n     * Only callable by admins.\n     * @param _token The address of the token.\n     * @param _amount The amount to dispense.\n     */\n    function setTokenAmount(address _token, uint256 _amount) external {\n        if (!hasRole(ADMIN_ROLE, msg.sender)) revert NotAdmin();\n        tokenAmounts[_token] = _amount;\n    }\n\n    /**\n     * @dev Request tokens. User specifies which token they want.\n     * Can only receive tokens once per token.\n     * @param _token The address of the token to request.\n     */\n    function requestTokens(address _token) external {\n        if (tokenAmounts[_token] == 0) revert TokenNotSupported();\n        if (received[msg.sender][_token]) revert TokensAlreadyReceived();\n\n        received[msg.sender][_token] = true;\n\n        bool success = IERC20(_token).transfer(msg.sender, tokenAmounts[_token]);\n        if (!success) revert TokenTransferFailed();\n    }\n\n    /**\n     * @dev Grants the admin role to another address.\n     * Only callable by current admins.\n     * @param _account The address to grant the admin role.\n     */\n    function grantAdmin(address _account) external {\n        if (!hasRole(ADMIN_ROLE, msg.sender)) revert NotAdmin();\n        grantRole(ADMIN_ROLE, _account);\n    }\n\n    /**\n     * @dev Revokes the admin role from an address.\n     * Only callable by current admins.\n     * @param _account The address from which to revoke the admin role.\n     */\n    function revokeAdmin(address _account) external {\n        if (!hasRole(ADMIN_ROLE, msg.sender)) revert NotAdmin();\n        revokeRole(ADMIN_ROLE, _account);\n    }\n\n    function left(address _token) external view returns (uint256) {\n        return IERC20(_token).balanceOf(address(this));\n    }\n}\n"
        },
        "contracts/safex/interfaces/IEngine.sol": {
            "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\ninterface IEngine {\n    function mktPrice(\n        address base,\n        address quote\n    ) external view returns (uint256 mktPrice);\n\n    function getOrderbook(uint256 bookId) external view returns (address);\n\n    function marketBuy(\n        address base,\n        address quote,\n        uint256 quoteAmount,\n        bool isMaker,\n        uint32 n,\n        uint32 uid\n    ) external;\n\n    function marketSell(\n        address base,\n        address quote,\n        uint256 baseAmount,\n        bool isMaker,\n        uint32 n,\n        uint32 uid\n    ) external;\n\n    function marketBuyETH(\n        address base,\n        bool isMaker,\n        uint32 n,\n        uint32 uid\n    ) external payable returns (bool);\n\n    function marketSellETH(\n        address quote,\n        bool isMaker,\n        uint32 n,\n        uint32 uid\n    ) external payable returns (bool);\n\n    function limitBuy(\n        address base,\n        address quote,\n        uint256 price,\n        uint256 quoteAmount,\n        bool isMaker,\n        uint32 n,\n        uint32 uid\n    ) external;\n\n    function limitSell(\n        address base,\n        address quote,\n        uint256 price,\n        uint256 baseAmount,\n        bool isMaker,\n        uint32 n,\n        uint32 uid\n    ) external;\n\n    function addPair(\n        address base,\n        address quote\n    ) external returns (address book);\n\n    function getPair(\n        address base,\n        address quote\n    ) external view returns (address book);\n}\n"
        },
        "contracts/safex/interfaces/IOrderbook.sol": {
            "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nimport \"../libraries/ExchangeOrderbook.sol\";\n\ninterface IOrderbook {\n    function initialize(uint256 id, address base_, address quote_, address engine_) external;\n\n    function fpop(bool isBid, uint256 price, uint256 remaining) external returns (uint32 orderId, uint256 required);\n\n    function setLmp(uint256 lmp) external;\n\n    function mktPrice() external view returns (uint256);\n\n    function assetValue(uint256 amount, bool isBid) external view returns (uint256 converted);\n\n    function isEmpty(bool isBid, uint256 price) external view returns (bool);\n\n    function getRequired(bool isBid, uint256 price, uint32 orderId) external view returns (uint256 required);\n\n    function clearEmptyHead(bool isBid) external returns (uint256 head);\n\n    function convert(uint256 price, uint256 amount, bool isBid) external view returns (uint256 converted);\n\n    function placeAsk(address owner, uint256 price, uint256 amount) external returns (uint32 orderId);\n\n    function placeBid(address owner, uint256 price, uint256 amount) external returns (uint32 orderId);\n\n    function cancelOrder(bool isBid, uint32 orderId, address owner)\n        external\n        returns (uint256 remaining);\n\n    function execute(uint32 orderId, bool isBid, address sender, uint256 amount)\n        external\n        returns (address owner);\n\n    function heads() external view returns (uint256 bidHead, uint256 askHead);\n\n    function askHead() external view returns (uint256);\n\n    function bidHead() external view returns (uint256);\n\n    function getPrices(bool isBid, uint32 n) external view returns (uint256[] memory);\n\n    function getOrders(bool isBid, uint256 price, uint32 n) external view returns (ExchangeOrderbook.Order[] memory);\n\n    function getOrder(bool isBid, uint32 orderId) external view returns (ExchangeOrderbook.Order memory);\n\n    function getOrderIds(bool isBid, uint256 price, uint32 n) external view returns (uint32[] memory);\n\n    function getBaseQuote() external view returns(address base, address quote);\n}\n"
        },
        "contracts/safex/interfaces/IOrderbookFactory.sol": {
            "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\ninterface IOrderbookFactory {\n    struct Pair {\n        address base;\n        address quote;\n    }\n\n    function createBook(address bid_, address ask_) external returns (address orderbook);\n\n    function getBook(uint256 bookId_) external view returns (address orderbook);\n\n    function getPair(address base, address quote) external view returns (address);\n\n    function getBaseQuote(address orderbook) external view returns (address base, address quote);\n\n    function allPairsLength() external view returns (uint256);\n\n    /// Address of a manager\n    function engine() external view returns (address);\n\n    function getPairs(uint256 start, uint256 end) external view returns (Pair[] memory);\n\n    function getPairsWithIds(uint256[] memory ids) external view returns (Pair[] memory);\n\n    function getPairNames(uint256 start, uint256 end) external view returns (string[] memory names);\n\n    function getPairNamesWithIds(uint256[] memory ids) external view returns (string[] memory names);\n}\n"
        },
        "contracts/safex/interfaces/IWETH.sol": {
            "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function withdraw(uint256) external;\n}\n"
        },
        "contracts/safex/libraries/CloneFactory.sol": {
            "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nlibrary CloneFactory {\n    function _createClone(address target) internal returns (address result) {\n        // convert address to 20 bytes\n        bytes20 targetBytes = bytes20(target);\n\n        // actual code //\n        // 3d602d80600a3d3981f3363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3\n\n        // creation code //\n        // copy runtime code into memory and return it\n        // 3d602d80600a3d3981f3\n\n        // runtime code //\n        // code to delegatecall to address\n        // 363d3d373d3d3d363d73 address 5af43d82803e903d91602b57fd5bf3\n\n        assembly {\n            /*\n            reads the 32 bytes of memory starting at pointer stored in 0x40\n\n            In solidity, the 0x40 slot in memory is special: it contains the \"free memory pointer\"\n            which points to the end of the currently allocated memory.\n            */\n            let clone := mload(0x40)\n            // store 32 bytes to memory starting at \"clone\"\n            mstore(\n                clone,\n                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\n            )\n\n            /*\n              |              20 bytes                |\n            0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\n                                                      ^\n                                                      pointer\n            */\n            // store 32 bytes to memory starting at \"clone\" + 20 bytes\n            // 0x14 = 20\n            mstore(add(clone, 0x14), targetBytes)\n\n            /*\n              |               20 bytes               |                 20 bytes              |\n            0x3d602d80600a3d3981f3363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe\n                                                                                              ^\n                                                                                              pointer\n            */\n            // store 32 bytes to memory starting at \"clone\" + 40 bytes\n            // 0x28 = 40\n            mstore(\n                add(clone, 0x28),\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\n            )\n\n            /*\n              |               20 bytes               |                 20 bytes              |           15 bytes          |\n            0x3d602d80600a3d3981f3363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3\n            */\n            // create new contract\n            // send 0 Ether\n            // code starts at pointer stored in \"clone\"\n            // code size 0x37 (55 bytes)\n            result := create(0, clone, 0x37)\n        }\n    }\n\n    function _isClone(\n        address target,\n        address query\n    ) internal view returns (bool result) {\n        bytes20 targetBytes = bytes20(target);\n        assembly {\n            let clone := mload(0x40)\n            mstore(\n                clone,\n                0x363d3d373d3d3d363d7300000000000000000000000000000000000000000000\n            )\n            mstore(add(clone, 0xa), targetBytes)\n            mstore(\n                add(clone, 0x1e),\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\n            )\n\n            let other := add(clone, 0x40)\n            extcodecopy(query, other, 0, 0x2d)\n            result := and(\n                eq(mload(clone), mload(other)),\n                eq(mload(add(clone, 0xd)), mload(add(other, 0xd)))\n            )\n        }\n    }\n\n    function _createCloneWithSalt(\n        address target,\n        bytes32 salt\n    ) internal returns (address result) {\n        bytes20 targetBytes = bytes20(target);\n        assembly {\n            let clone := mload(0x40)\n            mstore(\n                clone,\n                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\n            )\n            mstore(add(clone, 0x14), targetBytes)\n            mstore(\n                add(clone, 0x28),\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\n            )\n\n            // Use create2 with the provided salt\n            result := create2(0, clone, 0x37, salt)\n            if iszero(extcodesize(result)) {\n                revert(0, 0)\n            }\n        }\n    }\n\n    function predictAddressWithSalt(address deployer, address target, bytes32 salt) internal pure returns (address) {\n    // Create the expected bytecode of the minimal proxy\n    bytes memory bytecode = abi.encodePacked(\n        hex\"3d602d80600a3d3981f3363d3d373d3d3d363d73\",\n        target,\n        hex\"5af43d82803e903d91602b57fd5bf3\"\n    );\n    \n    bytes32 bytecodeHash = keccak256(bytecode);\n\n    bytes32 _data = keccak256(\n        abi.encodePacked(\n            bytes1(0xff),\n            deployer,\n            salt,\n            bytecodeHash\n        )\n    );\n    return address(uint160(uint256(_data)));\n}\n\n}\n"
        },
        "contracts/safex/libraries/ExchangeLinkedList.sol": {
            "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nlibrary ExchangeLinkedList {\n    error NoMatchPrice(uint256 askHead, uint256 bidHead, uint256 lmp);\n\n    struct PriceLinkedList {\n        /// Hashmap-style linked list of prices to route orders\n        // key: price, value: next_price (next_price > price)\n        mapping(uint256 => uint256) askPrices;\n        // key: price, value: next_price (next_price < price)\n        mapping(uint256 => uint256) bidPrices;\n        // Head of the bid price linked list(i.e. highest bid price)\n        uint256 askHead;\n        // Head of the ask price linked list(i.e. lowest ask price)\n        uint256 bidHead;\n        // Last matched price\n        uint256 lmp;\n    }\n\n    error ZeroPrice(uint256 price);\n    error NoHeadBelow(bool isBid, uint256 head);\n    error PriceOutOfRange(uint256 price, uint256 np);\n    error PriceNoneInRange(uint256 price, uint256 np);\n\n    function _setLmp(PriceLinkedList storage self, uint256 lmp_) internal {\n        self.lmp = lmp_;\n    }\n\n    function _heads(\n        PriceLinkedList storage self\n    ) internal view returns (uint256, uint256) {\n        return (self.bidHead, self.askHead);\n    }\n\n    function _askHead(\n        PriceLinkedList storage self\n    ) internal view returns (uint256) {\n        return self.askHead;\n    }\n\n    function _bidHead(\n        PriceLinkedList storage self\n    ) internal view returns (uint256) {\n        return self.bidHead;\n    }\n\n    function _mktPrice(\n        PriceLinkedList storage self\n    ) internal view returns (uint256) {\n        if (self.lmp == 0) {\n            if (self.bidHead == 0 && self.askHead == 0) {\n                revert NoMatchPrice(self.bidHead, self.askHead, self.lmp);\n            } else if (self.bidHead != 0 && self.askHead != 0) {\n                return (self.bidHead + self.askHead) / 2;\n            } else {\n                return self.askHead == 0 ? self.bidHead : self.askHead;\n            }\n        } else {\n            if (self.lmp < self.bidHead) {\n                return self.bidHead;\n            } else if (self.lmp > self.askHead && self.askHead != 0) {\n                return self.askHead;\n            } else {\n                return self.lmp;\n            }\n        }\n    }\n\n    function _next(\n        PriceLinkedList storage self,\n        bool isBid,\n        uint256 price\n    ) internal view returns (uint256) {\n        if (isBid) {\n            return self.bidPrices[price];\n        } else {\n            return self.askPrices[price];\n        }\n    }\n\n    // for bidPrices, lower ones are next, for askPrices, higher ones are next\n    function _insert(\n        PriceLinkedList storage self,\n        bool isBid,\n        uint256 price\n    ) internal {\n        if (isBid) {\n            uint256 last = 0;\n            uint256 head = self.bidHead;\n            // insert bid price to the linked list\n            // if the list is empty\n            if (head == 0 || price > head) {\n                self.bidHead = price;\n                self.bidPrices[price] = head;\n                return;\n            }\n            while (head != 0) {\n                uint256 next = self.bidPrices[head];\n                if (price < next) {\n                    // Keep traversing\n                    head = self.bidPrices[head];\n                    last = next;\n                } else if (price > next) {\n                    if (next == 0) {\n                        // Insert price at the end of the list\n                        self.bidPrices[head] = price;\n                        self.bidPrices[price] = 0;\n                        return;\n                    }\n                    // Insert price in the middle of the list\n                    self.bidPrices[head] = price;\n                    self.bidPrices[price] = next;\n                    return;\n                } else {\n                    // price is already included in the queue as it is equal to next\n                    // End traversal as there is no need to traverse further\n                    return;\n                }\n            }\n        }\n        // insert ask price to the linked list\n        else {\n            uint256 last = 0;\n            uint256 head = self.askHead;\n            // insert order to the linked list\n            // if the list is empty and price is the lowest ask\n            if (head == 0 || price < head) {\n                self.askHead = price;\n                self.askPrices[price] = head;\n                return;\n            }\n            // traverse the list\n            while (head != 0) {\n                uint256 next = self.askPrices[head];\n                // Keep traversing\n                if (price > next) {\n                    if (next == 0) {\n                        // Insert price in the middle of the list\n                        self.askPrices[head] = price;\n                        self.askPrices[price] = 0;\n                        return;\n                    }\n                    head = self.askPrices[head];\n                    last = next;\n                } else if (price < next) {\n                    // Insert price in the middle of the list\n                    self.askPrices[head] = price;\n                    self.askPrices[price] = next;\n                    return;\n                } else {\n                    // price is already included in the queue as it is equal to next\n                    // End traversal as there is no need to traverse further\n                    return;\n                }\n            }\n        }\n    }\n\n    function _clearHead(\n        PriceLinkedList storage self,\n        bool isBid\n    ) internal returns (uint256 newHead) {\n        if (isBid) {\n            self.bidHead = self.bidPrices[self.bidHead];\n        } else {\n            self.askHead = self.askPrices[self.askHead];\n        }\n        return isBid ? self.bidHead : self.askHead;\n    }\n\n    function _delete(\n        PriceLinkedList storage self,\n        bool isBid,\n        uint256 price\n    ) internal returns (bool) {\n        // traverse the list\n        if (price == 0) {\n            // revert ZeroPrice(price);\n            return false;\n        }\n\n        if (isBid) {\n            uint256 last = 0;\n            uint256 head = self.bidHead;\n            // insert bid price to the linked list\n            // if the list is empty\n            if (head == 0 || price > head) {\n                // revert NoHeadBelow(isBid, head);\n                return false;\n            }\n            while (head != 0 && price > head) {\n                uint256 next = self.bidPrices[head];\n                // price is below head bid price, traversing to lower end\n                if (price < next) {\n                    // Keep traversing\n                    head = self.bidPrices[head];\n                    last = next;\n                }\n                // price is above lowest bid price, and the search price is head which is right before next\n                else if (price > next) {\n                    // the search price is at the end\n                    if (next == 0) {\n                        // if there is only one price left, check if it is the price we are looking for\n                        if (head == price) {\n                            // remove price at the end\n                            self.bidPrices[last] = 0;\n                            delete self.bidPrices[head];\n                            return true;\n                        }\n                        // Price does not exist in price list\n                        // revert PriceOutOfRange(head, price);\n                        return false;\n                    } \n                    // the search price is right above the next price which is not zero\n                    else {\n                        if (head == price) {\n                            self.bidPrices[last] = next;\n                            delete self.bidPrices[head];\n                            return true;\n                        }\n                    }\n                    // Price does not exist within range of prices\n                    // revert PriceNoneInRange(head, price);\n                    return false;\n                } \n                // price is above lowest bid price, and the search price is next price\n                else {\n                    // price is already included in the queue as it is equal to next. price exists in the orderbook\n                    // End traversal as there is no need to traverse further\n                    // remove price in next, connect next next to the head\n                    self.bidPrices[head] = self.bidPrices[next];\n                    delete self.bidPrices[next];\n                    return true;\n                }\n            }\n        }\n        // insert ask price to the linked list\n        else {\n            uint256 last = 0;\n            uint256 head = self.askHead;\n            // insert order to the linked list\n            // if the list is empty and price is the lowest ask\n            if (head == 0 || price < head) {\n                // revert NoHeadBelow(isBid, head);\n                return false;\n            }\n            // traverse the list\n            while (head != 0 && price < head) {\n                uint256 next = self.askPrices[head];\n                // price is above head price, traversing to end\n                if (price > next) {\n                    // the price is at the end of range\n                    if (next == 0) {\n                        // if there is only one price left, check if it is the price we are looking for\n                        if (head == price) {\n                            self.askPrices[last] = 0;\n                            delete self.askPrices[head];\n                            return true;\n                        }\n                        // Price does not exist in price list\n                        //revert PriceOutOfRange(head, price);\n                        return false;\n                    } \n                    // Keep traversing\n                    head = self.askPrices[head];\n                    last = next;\n                }\n                // price is below highest ask, and the search price is head which is right before next\n                else if (price < next) {\n                    // Price does exist within range of prices\n                    if (head == price) {\n                        // price is already included in the queue as it is equal to next\n                        // End traversal as there is no need to traverse further\n                        self.askPrices[last] = self.askPrices[next];\n                        delete self.askPrices[head];\n                        return true;\n                    } else {\n                      // revert PriceNoneInRange(head, price);\n                      return false;\n                    }\n                    //return false;\n                }\n                // price is below highest ask, and the search price is next price\n                else {\n                    // price is already included in the queue as it is equal to next\n                    // End traversal as there is no need to traverse further\n                    self.askPrices[head] = self.askPrices[next];\n                    delete self.askPrices[next];\n                    return true;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    // show n prices shown in the orderbook\n    function _getPrices(\n        PriceLinkedList storage self,\n        bool isBid,\n        uint256 n\n    ) internal view returns (uint256[] memory) {\n        uint256 i = 0;\n        uint256[] memory prices = new uint256[](n);\n        for (\n            uint256 price = isBid ? self.bidHead : self.askHead;\n            price != 0 && i < n;\n            price = isBid ? self.bidPrices[price] : self.askPrices[price]\n        ) {\n            prices[i] = price;\n            i++;\n        }\n        return prices;\n    }\n\n    function _checkPriceExists(\n        PriceLinkedList storage self,\n        bool isBid,\n        uint256 price\n    ) internal view returns (bool) {\n        // traverse the list\n        if (price == 0) {\n            revert ZeroPrice(price);\n            //return false;\n        }\n\n        if (isBid) {\n            uint256 last = 0;\n            uint256 head = self.bidHead;\n            // insert bid price to the linked list\n            // if the list is empty\n            if (head == 0 || price > head) {\n                revert NoHeadBelow(isBid, head);\n            } else if (head == price) {\n                return true;\n            }\n\n            while (head != 0 && price > head) {\n                uint256 next = self.bidPrices[head];\n                if (price < next) {\n                    // Keep traversing\n                    head = self.bidPrices[head];\n                    last = next;\n                }\n                // within the price range\n                else if (price > next) {\n                    // if next is end of the list\n                    if (next == 0) {\n                        // if there is only one price left, check if it is the price we are looking for\n                        if (head == price) {\n                            return true;\n                        }\n                        // Price does not exist in price list\n                        revert PriceOutOfRange(head, price);\n                    }\n                    // if next is lower bid than the price\n                    else {\n                        if (head == price) {\n                            return true;\n                        }\n                        // Price does not exist within range of prices\n                        revert PriceNoneInRange(head, price);\n                    }\n                } else {\n                    // price is already included in the queue as it is equal to next. price exists in the orderbook\n                    // End traversal as there is no need to traverse further\n                    return true;\n                }\n            }\n        }\n        // insert ask price to the linked list\n        else {\n            uint256 last = 0;\n            uint256 head = self.askHead;\n            // insert order to the linked list\n            // if the list is empty and price is the lowest ask\n            if (head == 0 || price < head) {\n                revert NoHeadBelow(isBid, head);\n            } else if (head == price) {\n                return true;\n            }\n            // traverse the list\n            while (head != 0) {\n                uint256 next = self.askPrices[head];\n                // Keep traversing\n                if (price > next) {\n                    if (next == 0) {\n                        // if there is only one price left, check if it is the price we are looking for\n                        if (head == price) {\n                            return true;\n                        }\n                        // Price does not exist in price list\n                        revert PriceOutOfRange(head, price);\n                    }\n                    head = self.askPrices[head];\n                    last = next;\n                } else if (price < next) {\n                    if (head == price) {\n                        return true;\n                    }\n                    // Price does not exist within range of prices\n                    revert PriceNoneInRange(head, price);\n                } else {\n                    // price is already included in the queue as it is equal to next\n                    // End traversal as there is no need to traverse further\n                    return true;\n                }\n            }\n        }\n\n        return true;\n    }\n}\n"
        },
        "contracts/safex/libraries/ExchangeOrderbook.sol": {
            "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nlibrary ExchangeOrderbook {\n  // Order struct\n  struct Order {\n    address owner;\n    uint256 price;\n    uint256 depositAmount;\n  }\n\n  // Order Linked List\n  struct OrderStorage {\n    /// Hashmap-style linked list of prices to route orders\n    // key: price, value: order indices linked hashmap\n    mapping(uint256 => mapping(uint32 => uint32)) list;\n    mapping(uint32 => Order) orders;\n    mapping(uint32 => bool) canceled;\n    // Head of the linked list(i.e. lowest ask price / highest bid price)\n    mapping(uint256 => uint32) head;\n    // count of the orders, used for array allocation\n    uint32 count;\n    address engine;\n  }\n\n  error OrderIdIsZero(uint32 id);\n\n  // for orders, lower depositAmount are next, higher depositAmount comes first\n  function _insertId(\n    OrderStorage storage self,\n    uint256 price,\n    uint32 id,\n    uint256 amount\n  ) internal {\n    uint32 last = 0;\n    uint32 head = self.head[price];\n    mapping(uint32 => uint32) storage list = self.list[price];\n    mapping(uint32 => Order) storage orders = self.orders;\n    // insert order to the linked list\n    // if the list is empty\n    if (head == 0 || amount > self.orders[head].depositAmount) {\n      self.head[price] = id;\n      list[id] = head;\n      return;\n    }\n    // Traverse through list until we find the right spot where id's deposit amount is higher than next\n    while (head != 0) {\n      // what if order deposit amount is bigger than the next order's deposit amount?\n      uint32 next = list[head];\n      if (amount < orders[next].depositAmount) {\n        // Keep traversing\n        head = list[head];\n        last = next;\n      } else if (amount > orders[next].depositAmount) {\n        // This is either order is cancelled or order is at the end of the list\n        if (orders[next].depositAmount == 0) {\n          // what if next order is canceled and order id still stays in the list?\n          // if order is canceled and stays in the list, there is at least a next order in the list\n          if (self.canceled[next]) {\n            // remove index of cancelled order\n            list[head] = list[next];\n            delete list[next];\n            delete self.canceled[next];\n            // skip canceled order\n            last = head;\n            head = list[head];\n          } else {\n            // Insert order at the end of the list\n            list[head] = id;\n            list[id] = 0;\n            return;\n          }\n        }\n        // Insert order in the middle of the list\n        list[head] = id;\n        list[id] = next;\n        return;\n      }\n      // what if there is same order with same deposit amount?\n      else if (amount == orders[next].depositAmount) {\n        list[id] = list[next];\n        list[next] = id;\n        return;\n      }\n    }\n  }\n\n  // pop front\n  function _fpop(\n    OrderStorage storage self,\n    uint256 price\n  ) internal returns (uint256) {\n    uint32 first = self.head[price];\n    if (first == 0) {\n      return 0;\n    }\n    uint32 next = self.list[price][first];\n    self.head[price] = next;\n    delete self.list[price][first];\n    return first;\n  }\n\n  function _createOrder(\n    OrderStorage storage self,\n    address owner,\n    uint256 price,\n    uint256 depositAmount\n  ) internal returns (uint32 id) {\n    Order memory order = Order({ owner: owner, price: price, depositAmount: depositAmount });\n    // prevent order overflow, order id must start from 1\n    self.count = self.count == 0 || self.count == type(uint32).max\n      ? 1\n      : self.count + 1;\n    self.orders[self.count] = order;\n    return self.count;\n  }\n\n  function _decreaseOrder(\n    OrderStorage storage self,\n    uint32 id,\n    uint256 amount,\n    uint256 dust\n  ) internal returns (uint256) {\n    uint256 decreased = self.orders[id].depositAmount - amount;\n    // remove dust\n    if (decreased <= dust || amount == 0) {\n      decreased = self.orders[id].depositAmount;\n      _deleteOrder(self, id);\n      return decreased;\n    } else {\n      self.orders[id].depositAmount = decreased;\n      return amount;\n    }\n  }\n\n  function _deleteOrder(\n    OrderStorage storage self,\n    uint32 id\n  ) internal {\n    uint256 price = self.orders[id].price;\n    uint32 last = 0;\n    uint32 head = self.head[price];\n    uint32 next;\n    uint16 i;\n    mapping(uint32 => uint32) storage list = self.list[price];\n    // delete id in the order linked list\n    if (head == id) {\n      self.head[price] = list[head];\n      delete list[id];\n    } else {\n      // search for the order id in the linked list\n      while (head != 0) {\n        next = list[head];\n        if (next == id) {\n          list[head] = list[next];\n          delete list[id];\n          break;\n        }\n        last = head;\n        head = next;\n        ++i;\n      }\n    }\n    // delete order\n    delete self.orders[id];\n    return;\n  }\n\n  // show n order ids at the price in the orderbook\n  function _getOrderIds(\n    OrderStorage storage self,\n    uint256 price,\n    uint32 n\n  ) internal view returns (uint32[] memory) {\n    uint32 head = self.head[price];\n    uint32[] memory orders = new uint32[](n);\n    uint32 i = 0;\n    while (head != 0 && i < n) {\n      orders[i] = head;\n      head = self.list[price][head];\n      i++;\n    }\n    return orders;\n  }\n\n  function _getOrders(\n    OrderStorage storage self,\n    uint256 price,\n    uint32 n\n  ) internal view returns (Order[] memory) {\n    uint32 head = self.head[price];\n    Order[] memory orders = new Order[](n);\n    uint32 i = 0;\n    while (head != 0 && i < n) {\n      orders[i] = self.orders[head];\n      head = self.list[price][head];\n      i++;\n    }\n    return orders;\n  }\n\n  function _head(\n    OrderStorage storage self,\n    uint256 price\n  ) internal view returns (uint32) {\n    return self.head[price];\n  }\n\n  function _isEmpty(\n    OrderStorage storage self,\n    uint256 price\n  ) internal view returns (bool) {\n    return self.head[price] == 0;\n  }\n\n  function _next(\n    OrderStorage storage self,\n    uint256 price,\n    uint32 curr\n  ) internal view returns (uint32) {\n    return self.list[price][curr];\n  }\n\n  function _getOrder(\n    OrderStorage storage self,\n    uint32 id\n  ) internal view returns (Order memory) {\n    if(id == 0) {\n      revert OrderIdIsZero(id);\n    }\n    return self.orders[id];\n  }\n}\n"
        },
        "contracts/safex/libraries/TransferHelper.sol": {
            "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint256 value) internal {\n        // bytes4(keccak256(bytes(\"approve(address,uint256)\")));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"AF\");\n    }\n\n    function safeTransfer(address token, address to, uint256 value) internal {\n        // bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TF\");\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint256 value) internal {\n        // bytes4(keccak256(bytes(\"transferFrom(address,address,uint256)\")));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TFF\");\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success,) = to.call{value: value}(new bytes(0));\n        require(success, \"ETF\");\n    }\n\n    function decimals(address token) internal view returns (uint8) {\n        // bytes4(keccak256(bytes(\"decimals()\")));\n        (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(0x313ce567));\n        require(success, \"DF\");\n        return abi.decode(data, (uint8));\n    }\n}\n"
        },
        "contracts/safex/orderbooks/Orderbook.sol": {
            "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nimport {IOrderbook} from \"../interfaces/IOrderbook.sol\";\nimport {Initializable} from \"../../security/Initializable.sol\";\nimport {TransferHelper} from \"../libraries/TransferHelper.sol\";\nimport {ExchangeLinkedList} from \"../libraries/ExchangeLinkedList.sol\";\nimport {ExchangeOrderbook} from \"../libraries/ExchangeOrderbook.sol\";\n\ninterface IWETHMinimal {\n    function WETH() external view returns (address);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function withdraw(uint256) external;\n}\n\ncontract Orderbook is IOrderbook, Initializable {\n    using ExchangeLinkedList for ExchangeLinkedList.PriceLinkedList;\n    using ExchangeOrderbook for ExchangeOrderbook.OrderStorage;\n\n    // Pair Struct\n    struct Pair {\n        uint256 id;\n        address base;\n        address quote;\n        address engine;\n    }\n\n    Pair private pair;\n\n    uint64 private decDiff;\n    bool private baseBquote;\n\n    ExchangeLinkedList.PriceLinkedList private priceLists;\n    ExchangeOrderbook.OrderStorage private _askOrders;\n    ExchangeOrderbook.OrderStorage private _bidOrders;\n\n    error InvalidDecimals(uint8 base, uint8 quote);\n    error InvalidAccess(address sender, address allowed);\n    error OrderSizeTooSmall(uint256 amount, uint256 minRequired);\n\n    function initialize(\n        uint256 id_,\n        address base_,\n        address quote_,\n        address engine_\n    ) external initializer {\n        uint8 baseD = TransferHelper.decimals(base_);\n        uint8 quoteD = TransferHelper.decimals(quote_);\n        if (baseD > 18 || quoteD > 18) {\n            revert InvalidDecimals(baseD, quoteD);\n        }\n        (uint8 diff, bool baseBquote_) = _absdiff(baseD, quoteD);\n        decDiff = uint64(10 ** diff);\n        baseBquote = baseBquote_;\n        pair = Pair(id_, base_, quote_, engine_);\n    }\n\n    modifier onlyEngine() {\n        if (msg.sender != pair.engine) {\n            revert InvalidAccess(msg.sender, pair.engine);\n        }\n        _;\n    }\n\n    function setLmp(uint256 price) external onlyEngine {\n        priceLists._setLmp(price);\n    }\n\n    function placeAsk(\n        address owner,\n        uint256 price,\n        uint256 amount\n    ) external onlyEngine returns (uint32 id) {\n        id = _askOrders._createOrder(owner, price, amount);\n        // check if the price is new in the list. if not, insert id to the list\n        if (_askOrders._isEmpty(price)) {\n            priceLists._insert(false, price);\n        }\n        _askOrders._insertId(price, id, amount);\n        return id;\n    }\n\n    function placeBid(\n        address owner,\n        uint256 price,\n        uint256 amount\n    ) external onlyEngine returns (uint32 id) {\n        id = _bidOrders._createOrder(owner, price, amount);\n        // check if the price is new in the list. if not, insert id to the list\n        if (_bidOrders._isEmpty(price)) {\n            priceLists._insert(true, price);\n        }\n        _bidOrders._insertId(price, id, amount);\n        return id;\n    }\n\n    function cancelOrder(\n        bool isBid,\n        uint32 orderId,\n        address owner\n    ) external onlyEngine returns (uint256 remaining) {\n        // check order owner\n        ExchangeOrderbook.Order memory order = isBid\n            ? _bidOrders._getOrder(orderId)\n            : _askOrders._getOrder(orderId);\n\n        // check before the price had an order not being empty\n        bool wasEmpty = isEmpty(isBid, order.price);\n        \n        if (order.owner != owner) {\n            revert InvalidAccess(owner, order.owner);\n        }\n\n        isBid\n            ? _bidOrders._deleteOrder(orderId)\n            : _askOrders._deleteOrder(orderId);\n        isBid\n            ? _sendFunds(pair.quote, owner, order.depositAmount)\n            : _sendFunds(pair.base, owner, order.depositAmount);\n\n        // check if the canceled order was the last order in the list\n        if (!wasEmpty && isEmpty(isBid, order.price)) {\n            priceLists._delete(isBid, order.price);\n        }\n\n        return (order.depositAmount);\n    }\n\n    function execute(\n        uint32 orderId,\n        bool isBid,\n        address sender,\n        uint256 amount\n    ) external onlyEngine returns (address owner) {\n        ExchangeOrderbook.Order memory order = isBid\n            ? _bidOrders._getOrder(orderId)\n            : _askOrders._getOrder(orderId);\n        uint256 converted = convert(order.price, amount, isBid);\n        uint256 dust = convert(order.price, 1, isBid);\n        // if isBid == true, sender is matching ask order with bid order(i.e. selling base to receive quote), otherwise sender is matching bid order with ask order(i.e. buying base with quote)\n        if (isBid) {\n            // decrease remaining amount of order\n            uint256 withDust = _bidOrders._decreaseOrder(\n                orderId,\n                converted,\n                dust\n            );\n            // sender is matching ask order for base asset with quote asset\n            _sendFunds(pair.base, order.owner, amount);\n            // send converted amount of quote asset from owner to sender\n            _sendFunds(pair.quote, sender, withDust);\n        }\n        // if the order is bid order on the base/quote pair\n        else {\n            // decrease remaining amount of order\n            uint256 withDust = _askOrders._decreaseOrder(\n                orderId,\n                converted,\n                dust\n            );\n            // sender is matching bid order for quote asset with base asset\n            // send deposited amount of quote asset from sender to owner\n            _sendFunds(pair.quote, order.owner, amount);\n            // send converted amount of base asset from owner to sender\n            _sendFunds(pair.base, sender, withDust);\n        }\n        return order.owner;\n    }\n\n    function clearEmptyHead(bool isBid) external returns (uint256 head) {\n        head = isBid ? priceLists._bidHead() : priceLists._askHead();\n        uint32 orderId = isBid\n            ? _bidOrders._head(head)\n            : _askOrders._head(head);\n        while (orderId == 0 && head != 0) {\n            orderId = isBid ? _bidOrders._head(head) : _askOrders._head(head);\n            if (orderId == 0) {\n                head = priceLists._clearHead(isBid);\n            }\n        }\n        return head;\n    }\n\n    function fpop(\n        bool isBid,\n        uint256 price,\n        uint256 remaining\n    ) external onlyEngine returns (uint32 orderId, uint256 required) {\n        orderId = isBid ? _bidOrders._head(price) : _askOrders._head(price);\n        ExchangeOrderbook.Order memory order = isBid\n            ? _bidOrders._getOrder(orderId)\n            : _askOrders._getOrder(orderId);\n        required = convert(price, order.depositAmount, !isBid);\n        if (required <= remaining) {\n            isBid ? _bidOrders._fpop(price) : _askOrders._fpop(price);\n            if (isEmpty(isBid, price)) {\n                isBid\n                    ? priceLists.bidHead = priceLists._next(isBid, price)\n                    : priceLists.askHead = priceLists._next(isBid, price);\n            }\n        }\n        return (orderId, required);\n    }\n\n    function _sendFunds(\n        address token,\n        address to,\n        uint256 amount\n    ) internal returns (bool) {\n        address weth = IWETHMinimal(pair.engine).WETH();\n        if (token == weth) {\n            IWETHMinimal(weth).withdraw(amount);\n            return payable(to).send(amount);\n        } else {\n            TransferHelper.safeTransfer(token, to, amount);\n            return true;\n        }\n    }\n\n    function _absdiff(uint8 a, uint8 b) internal pure returns (uint8, bool) {\n        return (a > b ? a - b : b - a, a > b);\n    }\n\n    // get required amount for executing the order\n    function getRequired(\n        bool isBid,\n        uint256 price,\n        uint32 orderId\n    ) external view returns (uint256 required) {\n        ExchangeOrderbook.Order memory order = isBid\n            ? _bidOrders._getOrder(orderId)\n            : _askOrders._getOrder(orderId);\n        if (order.depositAmount == 0) {\n            return 0;\n        }\n        /* if ask, required base amount is quoteAmount / price,\n         * converting the number converting decimal from quote to base,\n         * otherwise quote amount is baseAmount * price, converting decimal from base to quote\n         */\n        return convert(price, order.depositAmount, isBid);\n    }\n\n    /////////////////////////////////\n    /// Price linked list methods ///\n    /////////////////////////////////\n\n    function heads() external view returns (uint256, uint256) {\n        return priceLists._heads();\n    }\n\n    function askHead() external view returns (uint256) {\n        return priceLists._askHead();\n    }\n\n    function bidHead() external view returns (uint256) {\n        return priceLists._bidHead();\n    }\n\n    function mktPrice() external view returns (uint256) {\n        return priceLists._mktPrice();\n    }\n\n    function getPrices(\n        bool isBid,\n        uint32 n\n    ) external view returns (uint256[] memory) {\n        return priceLists._getPrices(isBid, n);\n    }\n\n    function getOrderIds(\n        bool isBid,\n        uint256 price,\n        uint32 n\n    ) external view returns (uint32[] memory) {\n        return\n            isBid\n                ? _bidOrders._getOrderIds(price, n)\n                : _askOrders._getOrderIds(price, n);\n    }\n\n    function getOrders(\n        bool isBid,\n        uint256 price,\n        uint32 n\n    ) external view returns (ExchangeOrderbook.Order[] memory) {\n        return\n            isBid\n                ? _bidOrders._getOrders(price, n)\n                : _askOrders._getOrders(price, n);\n    }\n\n    function getOrder(\n        bool isBid,\n        uint32 orderId\n    ) external view returns (ExchangeOrderbook.Order memory) {\n        return\n            isBid\n                ? _bidOrders._getOrder(orderId)\n                : _askOrders._getOrder(orderId);\n    }\n\n    function getBaseQuote()\n        external\n        view\n        returns (address base, address quote)\n    {\n        return (pair.base, pair.quote);\n    }\n\n    /**\n     * @dev get asset value in quote asset if isBid is true, otherwise get asset value in base asset\n     * @param amount amount of asset in base asset if isBid is true, otherwise in quote asset\n     * @param isBid if true, get asset value in quote asset, otherwise get asset value in base asset\n     * @return converted asset value in quote asset if isBid is true, otherwise asset value in base asset\n     */\n    function assetValue(\n        uint256 amount,\n        bool isBid\n    ) external view returns (uint256 converted) {\n        return convert(priceLists._mktPrice(), amount, isBid);\n    }\n\n    function isEmpty(bool isBid, uint256 price) public view returns (bool) {\n        return isBid ? _bidOrders._isEmpty(price) : _askOrders._isEmpty(price);\n    }\n\n    function convert(\n        uint256 price,\n        uint256 amount,\n        bool isBid\n    ) public view returns (uint256 converted) {\n        if (isBid) {\n            // convert quote to base\n            return\n                baseBquote\n                    ? ((amount * price) / 1e8) / decDiff\n                    : ((amount * price) / 1e8) * decDiff;\n        } else {\n            // convert base to quote\n            return\n                baseBquote\n                    ? ((amount * 1e8) / price) * decDiff\n                    : ((amount * 1e8) / price) / decDiff;\n        }\n    }\n\n    receive() external payable {\n        assert(msg.sender == IWETHMinimal(pair.engine).WETH());\n    }\n}\n"
        },
        "contracts/safex/orderbooks/OrderbookFactory.sol": {
            "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.17;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {Orderbook, IOrderbook} from \"./Orderbook.sol\";\nimport {CloneFactory} from \"../libraries/CloneFactory.sol\";\nimport {IOrderbookFactory} from \"../interfaces/IOrderbookFactory.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\ninterface IERC20 {\n    function symbol() external view returns (string memory);\n}\n\ncontract OrderbookFactory is IOrderbookFactory, Initializable {\n    // Orderbooks\n    address[] public allPairs;\n    /// Address of manager\n    address public override engine;\n    /// version number of impl\n    uint32 public version;\n    /// address of order impl\n    address public impl;\n\n    error InvalidAccess(address sender, address allowed);\n    error PairAlreadyExists(address base, address quote, address pair);\n    error SameBaseQuote(address base, address quote);\n\n    constructor() {\n    }\n\n    function createBook(\n        address base_,\n        address quote_\n    ) external override returns (address orderbook) {\n        if (msg.sender != engine) {\n            revert InvalidAccess(msg.sender, engine);\n        }\n\n        if (base_ == quote_) {\n            revert SameBaseQuote(base_, quote_);\n        }\n\n        address pair = _predictAddress(base_, quote_);\n\n        // Check if the address has code\n        uint32 size;\n        assembly {\n            size := extcodesize(pair)\n        }\n\n        // If the address has code and it's a clone of impl, revert.\n        if (size > 0 || CloneFactory._isClone(impl, pair)) {\n            revert PairAlreadyExists(base_, quote_, pair);\n        }\n\n        address proxy = CloneFactory._createCloneWithSalt(\n            impl,\n            _getSalt(base_, quote_)\n        );\n        IOrderbook(proxy).initialize(\n            allPairsLength(),\n            base_,\n            quote_,\n            engine\n        );\n        allPairs.push(proxy);\n        return (proxy);\n    }\n\n    function isClone(address vault) external view returns (bool cloned) {\n        cloned = CloneFactory._isClone(impl, vault);\n    }\n\n    function getBook(uint256 bookId_) external view override returns (address) {\n        return allPairs[bookId_];\n    }\n\n    function getPair(\n        address base,\n        address quote\n    ) external view override returns (address book) {\n        book = _predictAddress(base, quote);\n        return address(book).code.length > 0 ? book : address(0);\n    }\n\n    function getPairs(\n        uint256 start,\n        uint256 end\n    ) public view override returns (IOrderbookFactory.Pair[] memory) {\n        uint256 last = end > allPairs.length ? allPairs.length : end;\n        IOrderbookFactory.Pair[] memory pairs = new IOrderbookFactory.Pair[](\n            last - start\n        );\n        for (uint256 i = start; i < last; i++) {\n            (address base, address quote) = IOrderbook(allPairs[i])\n                .getBaseQuote();\n            pairs[i] = Pair(base, quote);\n        }\n        return pairs;\n    }\n\n    function getPairsWithIds(\n        uint256[] memory ids\n    ) public view override returns (IOrderbookFactory.Pair[] memory pairs) {\n        pairs = new IOrderbookFactory.Pair[](ids.length);\n        for (uint256 i = 0; i < ids.length; i++) {\n            (address base, address quote) = IOrderbook(allPairs[i])\n                .getBaseQuote();\n            pairs[i] = Pair(base, quote);\n        }\n        return pairs;\n    }\n\n    function getPairNames(\n        uint256 start,\n        uint256 end\n    ) external view override returns (string[] memory names) {\n        IOrderbookFactory.Pair[] memory pairs = getPairs(start, end);\n        names = new string[](pairs.length);\n        for (uint256 i = 0; i < pairs.length; i++) {\n            string memory baseName = IERC20(pairs[i].base).symbol();\n            string memory quoteName = IERC20(pairs[i].quote).symbol();\n            names[i] = string(abi.encodePacked(baseName, \"/\", quoteName));\n        }\n        return names;\n    }\n\n    function getPairNamesWithIds(\n        uint256[] memory ids\n    ) external view override returns (string[] memory names) {\n        names = new string[](ids.length);\n        for (uint256 i = 0; i < ids.length; i++) {\n            (address base, address quote) = IOrderbook(allPairs[i])\n                .getBaseQuote();\n            string memory baseName = IERC20(base).symbol();\n            string memory quoteName = IERC20(quote).symbol();\n            names[i] = string(abi.encodePacked(baseName, \"/\", quoteName));\n        }\n        return names;\n    }\n\n    function getBaseQuote(\n        address orderbook\n    ) external view override returns (address base, address quote) {\n        return IOrderbook(orderbook).getBaseQuote();\n    }\n\n    /**\n     * @dev Initialize orderbook factory contract with engine address, reinitialize if engine is reset.\n     * @param engine_ The address of the engine contract\n     */\n    function initialize(address engine_) public initializer {\n        engine = engine_;\n        _createImpl();\n    }\n\n    function allPairsLength() public view returns (uint256) {\n        return allPairs.length;\n    }\n\n    // Set immutable, consistant, one rule for orderbook implementation\n    function _createImpl() internal {\n        address addr;\n        bytes memory bytecode = type(Orderbook).creationCode;\n        bytes32 salt = keccak256(abi.encodePacked(\"orderbook\", version));\n        assembly {\n            addr := create2(0, add(bytecode, 0x20), mload(bytecode), salt)\n            if iszero(extcodesize(addr)) {\n                revert(0, 0)\n            }\n        }\n        impl = addr;\n    }\n\n    function _predictAddress(\n        address base_,\n        address quote_\n    ) internal view returns (address) {\n        bytes32 salt = _getSalt(base_, quote_);\n        return CloneFactory.predictAddressWithSalt(address(this), impl, salt);\n    }\n\n    function _getSalt(\n        address base_,\n        address quote_\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(base_, quote_));\n    }\n}\n"
        },
        "contracts/safu/Bond.sol": {
            "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IERC20Minimal.sol\";\nimport \"./libraries/TransferHelper.sol\";\nimport \"./interfaces/IBond.sol\";\nimport \"./interfaces/INetworkState.sol\";\nimport \"./interfaces/IERC721Minimal.sol\";\nimport \"./interfaces/ICoupon.sol\";\nimport \"./interfaces/IWETH.sol\";\nimport \"./interfaces/IEngine.sol\";\nimport \"./interfaces/ISAFU.sol\";\n\ncontract Bond {\n    /// Address of the state\n    address public state;\n    /// Address of debt;\n    address public debt;\n    /// Address of vault ownership registry\n    address public coupon;\n    /// Address of a collateral\n    address public collateral;\n    /// Bond global identifier\n    uint128 public id;\n    /// Borrowed amount\n    uint256 public borrow;\n    /// Created block timestamp\n    uint256 public createdAt;\n\n    constructor() public {\n        state = msg.sender;\n        createdAt = block.timestamp;\n    }\n\n    error NotBondOwner(address caller, address owner);\n    error InvalidAccess(address caller, address gov);\n\n    modifier onlyBondOwner() {\n        address owner = IERC721Minimal(coupon).ownerOf(id);\n        if (owner != msg.sender) {\n            revert NotBondOwner(msg.sender, owner);\n        }\n        _;\n    }\n\n    modifier onlyState() {\n        if (state != msg.sender) {\n            revert InvalidAccess(msg.sender, state);\n        }\n        _;\n    }\n\n    // called once by the factory at time of deployment\n    function initialize(\n        uint128 vaultId_,\n        address collateral_,\n        address debt_,\n        address coupon_,\n        uint256 amount_\n    ) external onlyState {\n        id = vaultId_;\n        collateral = collateral_;\n        debt = debt_;\n        coupon = coupon_;\n        borrow = amount_;\n    }\n\n    /// liquidate\n    function liquidate() external {\n        require(\n            !INetworkState(state).isValidCDP(\n                collateral,\n                debt,\n                IERC20Minimal(collateral).balanceOf(address(this)),\n                IERC20Minimal(debt).balanceOf(address(this))\n            ),\n            \"Vault: Position is still safe\"\n        );\n        // check the pair if it exists\n        address market = INetworkState(state).market();\n        address pair = IEngine(market).getPair(collateral, debt);\n        require(pair != address(0), \"Vault: Liquidating pair not supported\");\n        uint256 balance = IERC20Minimal(collateral).balanceOf(address(this));\n        uint256 lfr = INetworkState(state).getLFR(collateral);\n        uint256 liquidationFee = (lfr * balance) / 100;\n        uint256 left = _sendFee(collateral, balance, liquidationFee);\n        // Distribute collaterals\n        IEngine(market).marketSell(collateral, debt, left, true, 10, 0);\n        // burn vault nft\n        _burnV1FromVault();\n        //emit Liquidated(address(this), collateral, balance);\n        // self destruct the contract, send remaining balance if collateral is native currency\n        selfdestruct(payable(msg.sender));\n    }\n\n    /// Deposit collateral\n    function depositCollateral(uint256 amount_) external onlyBondOwner {\n        TransferHelper.safeTransferFrom(\n            collateral,\n            msg.sender,\n            address(this),\n            amount_\n        );\n    }\n\n    /// Withdraw collateral\n    function withdrawCollateral(uint256 amount_) external onlyBondOwner {\n        require(\n            IERC20Minimal(collateral).balanceOf(address(this)) >= amount_,\n            \"Vault: Not enough collateral\"\n        );\n        if (borrow != 0) {\n            require(\n                INetworkState(state).isValidCDP(\n                    collateral,\n                    debt,\n                    IERC20Minimal(collateral).balanceOf(address(this)) -\n                        amount_,\n                    borrow\n                ),\n                \"Vault: below MCR\"\n            );\n        }\n        TransferHelper.safeTransfer(collateral, msg.sender, amount_);\n    }\n\n    /// Payback debt\n    function payDebt(uint256 amount_) external onlyBondOwner {\n        // calculate debt with interest\n        uint256 fee = _calculateFee();\n        require(amount_ != 0, \"Vault: amount is zero\");\n        // send M1 to the vault\n        TransferHelper.safeTransferFrom(\n            debt,\n            msg.sender,\n            address(this),\n            amount_\n        );\n        uint256 left = _sendFee(debt, amount_, fee);\n        _burnM1FromVault(left);\n        borrow -= left;\n        //emit PayBack(vaultId, borrow, fee);\n    }\n\n    /// Close CDP\n    function redeemBond(uint256 amount_) external onlyBondOwner {\n        // calculate debt with interest\n        uint256 fee = _calculateFee();\n        require(\n            fee + borrow == amount_,\n            \"Vault: not enough balance to payback\"\n        );\n        // send M1 to the vault\n        TransferHelper.safeTransferFrom(\n            debt,\n            msg.sender,\n            address(this),\n            amount_\n        );\n        // send fee to the pool\n        uint256 left = _sendFee(debt, amount_, fee);\n        // burn M1 debt with interest\n        _burnM1FromVault(left);\n        // burn vault nft\n        _burnV1FromVault();\n        //emit CloseVault(address(this), amount_, fee);\n        // self destruct the contract, send remaining balance if collateral is native currency\n        selfdestruct(payable(msg.sender));\n    }\n\n    /// get amount left to borrow\n    function getMargin(uint256 mcr) external view returns (uint256 available) {\n        return\n            ((IERC20Minimal(collateral).balanceOf(address(this)) / mcr) *\n                100000) - borrow;\n    }\n\n    /// burn vault v1\n    function _burnV1FromVault() internal {\n        ICoupon(coupon).burnFromVault(id);\n    }\n\n    /// burn vault M1\n    function _burnM1FromVault(uint256 amount_) internal {\n        ISAFU(debt).burnFrom(msg.sender, amount_);\n    }\n\n    function _calculateFee() internal returns (uint256) {\n        uint256 assetValue = INetworkState(state).getAssetValue(debt, borrow);\n        uint256 sfr = INetworkState(state).getSFR(collateral);\n        /// (sfr * assetValue/100) * (duration in months)\n        uint256 sfrTimesV = sfr * assetValue;\n        // get duration in months\n        uint256 duration = (block.timestamp - createdAt) / 60 / 60 / 24 / 30;\n        require(sfrTimesV >= assetValue); // overflow check\n        return (sfrTimesV / 100) * duration;\n    }\n\n    function getDebt() external returns (uint256) {\n        return _calculateFee() + borrow;\n    }\n\n    function _sendFee(\n        address asset_,\n        uint256 amount_,\n        uint256 fee_\n    ) internal returns (uint256 left) {\n        address dividend = INetworkState(state).dividend();\n        address feeTo = INetworkState(state).feeTo();\n        address treasury = INetworkState(state).treasury();\n        bool feeOn = feeTo != address(0);\n        bool treasuryOn = treasury != address(0);\n        bool dividendOn = dividend != address(0);\n        // send fee to the pool\n        if (feeOn) {\n            if (dividendOn) {\n                uint256 half = fee_ / 2;\n                TransferHelper.safeTransfer(asset_, dividend, half);\n                TransferHelper.safeTransfer(asset_, feeTo, half);\n            } else if (dividendOn && treasuryOn) {\n                uint256 third = fee_ / 3;\n                TransferHelper.safeTransfer(asset_, dividend, third);\n                TransferHelper.safeTransfer(asset_, feeTo, third);\n                TransferHelper.safeTransfer(asset_, treasury, third);\n            } else {\n                TransferHelper.safeTransfer(asset_, feeTo, fee_);\n            }\n        }\n        return amount_ - fee_;\n    }\n}\n"
        },
        "contracts/safu/Coupon.sol": {
            "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"./interfaces/ICoupon.sol\";\nimport \"./interfaces/INetworkState.sol\";\n\ncontract Coupon is ERC721, AccessControl  {\n     // Create a new role identifier for the minter role\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant BURNER_ROLE = keccak256(\"BURNER_ROLE\");\n\n    address manager;\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, AccessControl) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n\n    constructor(address manager_)\n    ERC721(\"SAFU BOND COUPON\", \"COUPON\") {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(MINTER_ROLE, manager);\n        _setupRole(BURNER_ROLE, _msgSender());\n        manager = manager_;\n    }\n    \n    function setManager(address manager_) public {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"MTRV1: Caller is not a default admin\");\n        manager = manager_;\n    }\n\n    function mint(address to, uint256 tokenId_) external  {\n        // Check that the calling account has the minter role\n        require(hasRole(MINTER_ROLE, msg.sender), \"MTRV1: Caller is not a minter\");\n        _mint(to, tokenId_);\n    }\n\n    function burn(uint256 tokenId_) external {\n        require(hasRole(BURNER_ROLE, _msgSender()), \"MTRV1: must have burner role to burn\");\n\n        _burn(tokenId_);\n    }\n\n    function burnFromVault(uint vaultId_) external{\n        require(INetworkState(manager).getVault(vaultId_)  == _msgSender(), \"MTRV1: Caller is not vault\");\n        _burn(vaultId_);\n    }\n\n    function exists(uint256 tokenId_) external view  returns (bool) {\n        return _exists(tokenId_);\n    }\n}\n\n"
        },
        "contracts/safu/NetworkState.sol": {
            "content": "pragma solidity ^0.8.17;\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {NetworkStateLibrary} from \"./libraries/NetworkStateLibrary.sol\";\nimport {IWETH} from \"./interfaces/IWETH.sol\";\nimport {TransferHelper} from \"./libraries/TransferHelper.sol\";\nimport {IERC721Minimal} from \"./interfaces/IERC721Minimal.sol\";\nimport {IBond} from \"./interfaces/IBond.sol\";\nimport {IERC20Minimal} from \"./interfaces/IERC20Minimal.sol\";\n\ncontract NetworkState is Initializable {\n    using NetworkStateLibrary for NetworkStateLibrary.State;\n    using NetworkStateLibrary for NetworkStateLibrary.CDP;\n\n    NetworkStateLibrary.State private state;\n\n    // CDP set events\n    event CDPSet(\n        address indexed collateral,\n        uint32 mcr,\n        uint32 rfr,\n        uint32 lfr\n    );\n\n    // Bond state events\n    event BondCreated(\n        uint128 indexed id,\n        address indexed collateral,\n        uint256 cAmount,\n        uint256 dAmount\n    );\n\n    event BondRedeemed(uint128 indexed id, uint256 indexed dAmount);\n\n    event BondLiquidated(\n        uint128 indexed id,\n        address indexed collateral,\n        uint256 cAmount,\n        uint256 dAmount\n    );\n\n    // Bond CDP state events\n    event DepositCollateral(uint128 id, uint256 amount);\n    event WithdrawCollateral(uint128 id, uint256 amount);\n    event BorrowMore(uint128 id, uint256 amount);\n    event PayBackDebt(uint128 id, uint256 amount);\n\n    // Bond errors\n    error NotBondOwner(address caller, address owner);\n    error InvalidAccess(address caller, address gov);\n\n    function initialize(\n        address coupon_,\n        address currency_,\n        address market_,\n        address weth_\n    ) external initializer {\n        state._initialize(coupon_, currency_, market_, weth_);\n    }\n\n    function setCDP(\n        address collateral_,\n        uint32 mcr_,\n        uint32 rfr_,\n        uint32 lfr_\n    ) external {\n        state._setCDP(collateral_, mcr_, rfr_, lfr_);\n    }\n\n    function getCDP(\n        address collateral_\n    ) external view returns (NetworkStateLibrary.CDP memory cdp) {\n        return state._getCDP(collateral_);\n    }\n\n    function borrow(\n        address collateral_,\n        uint cAmount_,\n        uint dAmount_,\n        uint128 id_\n    ) external returns (address bond) {\n        if (id_ == 0) {\n            // create bond\n            bond = state._createBond(collateral_, cAmount_, dAmount_);\n            IERC20Minimal(state.currency).mint(msg.sender, dAmount_);\n        } else {\n            // borrow more from existing bond\n            bond = state._predictAddress(collateral_, state.currency, id_);\n            // TODO: get margin from bond and check if it exceeeds the amount\n        }\n    }\n\n    function createBondETH(\n        uint dAmount_\n    ) public payable returns (address bond) {\n        IWETH(state.weth).deposit{value: msg.value}();\n        return state._createBond(state.weth, msg.value, dAmount_);\n    }\n\n    function isValidCDP(\n        address collateral_,\n        address debt_,\n        uint256 cAmount_,\n        uint256 dAmount_\n    ) external view returns (bool) {\n        return state._isValidCDP(collateral_, debt_, cAmount_, dAmount_);\n    }\n\n    function _takeFee(uint256 amount) internal {\n        // state._takeFee();\n    }\n\n    modifier onlyBondOwner(uint256 id) {\n        address owner = IERC721Minimal(state.coupon).ownerOf(id);\n        if (owner != msg.sender) {\n            revert NotBondOwner(msg.sender, owner);\n        }\n        _;\n    }\n\n    function depositCollateral(\n        uint128 id,\n        address collateral,\n        uint256 amount\n    ) public onlyBondOwner(id) returns (bool success) {\n        address bond = state._predictAddress(collateral, state.currency, id);\n        TransferHelper.safeTransferFrom(\n            collateral,\n            msg.sender,\n            address(this),\n            amount\n        );\n        TransferHelper.safeTransfer(collateral, bond, amount);\n        //return state._depositCollateral(id, amount);\n    }\n\n    function depositCollateralETH(\n        uint128 id,\n        address collateral,\n        uint256 amount\n    ) external payable onlyBondOwner(id) returns (bool success) {\n        address bond = state._predictAddress(collateral, state.currency, id);\n        IWETH(state.weth).deposit{value: msg.value}();\n        TransferHelper.safeTransfer(collateral, bond, amount);\n    }\n\n    function withdrawCollateral(\n        uint128 id,\n        address collateral,\n        uint256 amount\n    ) external onlyBondOwner(id) returns (bool success) {\n        address bond = state._predictAddress(collateral, state.currency, id);\n        IBond(bond).withdrawCollateral(amount);\n        TransferHelper.safeTransfer(collateral, msg.sender, amount);\n    }\n\n    function borrowMore(\n        uint128 id,\n        address collateral,\n        uint256 amount\n    ) external onlyBondOwner(id) returns (bool success) {\n        address bond = state._predictAddress(collateral, state.currency, id);\n        return state._borrowMore(id, collateral, amount);\n    }\n\n    function payBackDebt(\n        uint128 id,\n        address collateral,\n        uint256 amount\n    ) external onlyBondOwner(id) returns (bool success) {\n        address bond = state._predictAddress(collateral, state.currency, id);\n        //return state._payBackDebt(bond, id, amount);\n    }\n\n    function liquidate(\n        address collateral_,\n        address debt_,\n        uint128 id\n    ) external onlyBondOwner(id) returns (bool success) {\n        address bond = state._predictAddress(collateral_, state.currency, id);\n        //return state._liquidate(collateral_, debt_, id);\n    }\n\n    function market() external view returns (address) {\n        return state.market;\n    }\n}\n"
        },
        "contracts/safu/SAFU.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.17;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the ERC may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address  => uint256) private _balances;\n\n    mapping(address  => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n    uint16 feeRate;\n    address public treasury;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the ERC. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        uint256 fee = value / feeRate;\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                // Fee on transfer\n                \n                _balances[to] += value - fee;\n                _balances[treasury] += fee;\n            }\n        }\n\n        emit Transfer(from, to, value - fee);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}"
        },
        "contracts/safu/interfaces/IBond.sol": {
            "content": "pragma solidity ^0.8.17;\n\ninterface IBond {\n    function initialize(\n        uint256 id_,\n        address collateral_,\n        address debt_,\n        address market_\n    ) external;\n    \n    function liquidate() external;\n\n    function withdrawCollateral(uint256 amount) external;\n}"
        },
        "contracts/safu/interfaces/ICoupon.sol": {
            "content": "pragma solidity ^0.8.0;\n\ninterface ICoupon {\n    function mint(address to, uint256 tokenId_) external;\n    function burn(uint256 tokenId_) external;\n    function burnFromVault(uint vaultId_) external;\n    function exists(uint256 tokenId_) external view returns (bool);\n}"
        },
        "contracts/safu/interfaces/IERC20Minimal.sol": {
            "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity >=0.5.0;\n\ninterface IERC20Minimal {\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function mint(address to, uint256 amount) external;\n}\n"
        },
        "contracts/safu/interfaces/IERC721Minimal.sol": {
            "content": "// SPDX-License-Identifier: Apache-2.0\n\n\npragma solidity ^0.8.0;\n\ninterface IERC721Minimal {\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n}"
        },
        "contracts/safu/interfaces/IEngine.sol": {
            "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\ninterface IEngine {\n    function mktPrice(\n        address base,\n        address quote\n    ) external view returns (uint256 mktPrice);\n\n    function getOrderbook(uint256 bookId) external view returns (address);\n\n    function marketBuy(\n        address base,\n        address quote,\n        uint256 quoteAmount,\n        bool isMaker,\n        uint32 n,\n        uint32 uid\n    ) external;\n\n    function marketSell(\n        address base,\n        address quote,\n        uint256 baseAmount,\n        bool isMaker,\n        uint32 n,\n        uint32 uid\n    ) external;\n\n    function marketBuyETH(\n        address base,\n        bool isMaker,\n        uint32 n,\n        uint32 uid\n    ) external payable returns (bool);\n\n    function marketSellETH(\n        address quote,\n        bool isMaker,\n        uint32 n,\n        uint32 uid\n    ) external payable returns (bool);\n\n    function limitBuy(\n        address base,\n        address quote,\n        uint256 price,\n        uint256 quoteAmount,\n        bool isMaker,\n        uint32 n,\n        uint32 uid\n    ) external;\n\n    function limitSell(\n        address base,\n        address quote,\n        uint256 price,\n        uint256 baseAmount,\n        bool isMaker,\n        uint32 n,\n        uint32 uid\n    ) external;\n\n    function addPair(\n        address base,\n        address quote\n    ) external returns (address book);\n\n    function getPair(\n        address base,\n        address quote\n    ) external view returns (address book);\n}\n"
        },
        "contracts/safu/interfaces/INetworkState.sol": {
            "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.8.0;\n\ninterface INetworkState {\n\n    /// View funcs\n    /// NFT token address\n    function  v1() external view returns (address);\n    /// Stablecoin address\n    function meter() external view returns (address);\n    /// UniswapV2Factory address\n    function market() external view returns (address);\n    /// Address of feeTo\n    function feeTo() external view returns (address);\n    /// Address of the dividend pool\n    function dividend() external view returns (address);\n    /// Address of Standard treasury\n    function treasury() external view returns (address);\n    /// Address of wrapped eth\n    function WETH() external view returns (address);\n    /// Desired of supply of meter to be minted\n    function desiredSupply() external view returns (uint256);\n    /// Switch to on/off rebase\n    function rebaseActive() external view returns (bool);\n\n    /// Getters\n    /// Get Config of CDP\n    function getCDPConfig(address collateral) external view returns (uint, uint, uint, uint);\n    function getCDecimal(address collateral) external view returns(uint);\n    function getMCR(address collateral) external view returns(uint);\n    function getLFR(address collateral) external view returns(uint);\n    function getSFR(address collateral) external view returns(uint);\n    function getVault(uint vaultId_) external view returns (address);\n    function getAssetPrice(address asset) external returns (uint);\n    function getAssetValue(address asset, uint256 amount) external returns (uint256);\n    function isValidCDP(address collateral, address debt, uint256 cAmount, uint256 dAmount) external returns (bool);\n    function vaultCodeHash() external pure returns (bytes32);\n    function createCDP(address collateral_, uint cAmount_, uint dAmount_) external returns (bool success);\n\n    /// Event\n    event VaultCreated(uint256 vaultId, address collateral, address debt, address creator, address vault);\n}"
        },
        "contracts/safu/interfaces/ISAFU.sol": {
            "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.8.0;\n\ninterface ISAFU {\n    function mint(address to, uint256 amount) external;\n\n    function burn(uint256 amount) external;\n\n    function burnFrom(address account, uint256 amount) external;\n}\n"
        },
        "contracts/safu/interfaces/IWETH.sol": {
            "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function withdraw(uint256) external;\n}\n"
        },
        "contracts/safu/libraries/CloneFactory.sol": {
            "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nlibrary CloneFactory {\n    function _createClone(address target) internal returns (address result) {\n        // convert address to 20 bytes\n        bytes20 targetBytes = bytes20(target);\n\n        // actual code //\n        // 3d602d80600a3d3981f3363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3\n\n        // creation code //\n        // copy runtime code into memory and return it\n        // 3d602d80600a3d3981f3\n\n        // runtime code //\n        // code to delegatecall to address\n        // 363d3d373d3d3d363d73 address 5af43d82803e903d91602b57fd5bf3\n\n        assembly {\n            /*\n            reads the 32 bytes of memory starting at pointer stored in 0x40\n\n            In solidity, the 0x40 slot in memory is special: it contains the \"free memory pointer\"\n            which points to the end of the currently allocated memory.\n            */\n            let clone := mload(0x40)\n            // store 32 bytes to memory starting at \"clone\"\n            mstore(\n                clone,\n                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\n            )\n\n            /*\n              |              20 bytes                |\n            0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\n                                                      ^\n                                                      pointer\n            */\n            // store 32 bytes to memory starting at \"clone\" + 20 bytes\n            // 0x14 = 20\n            mstore(add(clone, 0x14), targetBytes)\n\n            /*\n              |               20 bytes               |                 20 bytes              |\n            0x3d602d80600a3d3981f3363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe\n                                                                                              ^\n                                                                                              pointer\n            */\n            // store 32 bytes to memory starting at \"clone\" + 40 bytes\n            // 0x28 = 40\n            mstore(\n                add(clone, 0x28),\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\n            )\n\n            /*\n              |               20 bytes               |                 20 bytes              |           15 bytes          |\n            0x3d602d80600a3d3981f3363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3\n            */\n            // create new contract\n            // send 0 Ether\n            // code starts at pointer stored in \"clone\"\n            // code size 0x37 (55 bytes)\n            result := create(0, clone, 0x37)\n        }\n    }\n\n    function _isClone(\n        address target,\n        address query\n    ) internal view returns (bool result) {\n        bytes20 targetBytes = bytes20(target);\n        assembly {\n            let clone := mload(0x40)\n            mstore(\n                clone,\n                0x363d3d373d3d3d363d7300000000000000000000000000000000000000000000\n            )\n            mstore(add(clone, 0xa), targetBytes)\n            mstore(\n                add(clone, 0x1e),\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\n            )\n\n            let other := add(clone, 0x40)\n            extcodecopy(query, other, 0, 0x2d)\n            result := and(\n                eq(mload(clone), mload(other)),\n                eq(mload(add(clone, 0xd)), mload(add(other, 0xd)))\n            )\n        }\n    }\n\n    function _createCloneWithSalt(\n        address target,\n        bytes32 salt\n    ) internal returns (address result) {\n        bytes20 targetBytes = bytes20(target);\n        assembly {\n            let clone := mload(0x40)\n            mstore(\n                clone,\n                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\n            )\n            mstore(add(clone, 0x14), targetBytes)\n            mstore(\n                add(clone, 0x28),\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\n            )\n\n            // Use create2 with the provided salt\n            result := create2(0, clone, 0x37, salt)\n            if iszero(extcodesize(result)) {\n                revert(0, 0)\n            }\n        }\n    }\n\n    function predictAddressWithSalt(address deployer, address target, bytes32 salt) internal pure returns (address) {\n    // Create the expected bytecode of the minimal proxy\n    bytes memory bytecode = abi.encodePacked(\n        hex\"3d602d80600a3d3981f3363d3d373d3d3d363d73\",\n        target,\n        hex\"5af43d82803e903d91602b57fd5bf3\"\n    );\n    \n    bytes32 bytecodeHash = keccak256(bytecode);\n\n    bytes32 _data = keccak256(\n        abi.encodePacked(\n            bytes1(0xff),\n            deployer,\n            salt,\n            bytecodeHash\n        )\n    );\n    return address(uint160(uint256(_data)));\n}\n\n}\n"
        },
        "contracts/safu/libraries/NetworkStateLibrary.sol": {
            "content": "pragma solidity ^0.8.17;\n\nimport \"./CloneFactory.sol\";\nimport \"../interfaces/IBond.sol\";\nimport \"../interfaces/IEngine.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nlibrary NetworkStateLibrary {\n    struct CDP {\n        uint32 mcr;\n        uint32 rfr;\n        uint32 lfr;\n        uint8 decimals;\n    }\n\n    struct State {\n        /// Desirable supply of stablecoin\n        uint256 supply;\n        // Vaults\n        uint128 count;\n        /// key: Collateral address, value: CDP in a struct\n        mapping(address => CDP) cdps;\n        /// Address of coupon NFT\n        address coupon;\n        /// Address of admin\n        address gov;\n        /// Address of currency\n        address currency;\n        /// Address of market;\n        address market;\n        /// Address of Standard Treasury\n        address treasury;\n        /// Address of liquidator\n        address liquidator;\n        /// Address of Wrapped eth;\n        address weth;\n        /// Address of Bond impl contract\n        address impl;\n    }\n\n    error InvalidAccess(address caller, address gov);\n    error BondAlreadyExists(address collateral, address currency, uint128 id);\n    error MktPriceIsZero(address base, address quote);\n    error ValueOverflow(uint256 price, uint256 amount);\n    error InvalidCDP(\n        address collateral,\n        address debt,\n        uint256 cAmount,\n        uint256 dAmount\n    );\n    error SupplyLimitExceeded(uint256 supply, uint256 issued, uint256 issueAmount);\n\n    function _initialize(\n        State storage self,\n        address coupon_,\n        address currency_,\n        address market_,\n        address weth_\n    ) public {\n        if (msg.sender != self.gov) revert InvalidAccess(msg.sender, self.gov);\n        self.weth = weth_;\n        self.market = market_;\n        self.currency = currency_;\n        self.coupon = coupon_;\n    }\n\n    function _setCDP(\n        State storage self,\n        address collateral,\n        uint32 mcr,\n        uint32 rfr,\n        uint32 lfr\n    ) public returns (bool success) {\n        if (msg.sender != self.gov) revert InvalidAccess(msg.sender, self.gov);\n        if (mcr > 0) {\n            self.cdps[collateral].mcr = mcr;\n        }\n        if (rfr > 0) {\n            self.cdps[collateral].rfr = rfr;\n        }\n        if (lfr > 0) {\n            self.cdps[collateral].lfr = lfr;\n        }\n        return true;\n    }\n\n    function _setSupply(\n        State storage self,\n        uint256 supply\n    ) public returns (bool success) {\n        if (msg.sender != self.gov) revert InvalidAccess(msg.sender, self.gov);\n        self.supply = supply;\n        return true;\n    }\n\n    function _getCDP(\n        State storage self,\n        address collateral\n    ) public view returns (CDP memory) {\n        return self.cdps[collateral];\n    }\n\n    function allBondsLength(State storage self) public view returns (uint) {\n        return self.count;\n    }\n\n    function _createBond(\n        State storage self,\n        address collateral,\n        uint256 cAmount,\n        uint256 dAmount\n    ) public returns (address bond) {\n        // get id\n        uint128 id = self.count;\n        uint256 issued = IERC20(self.currency).totalSupply();\n\n        // confirm the CDP is valid\n        if (!_isValidCDP(self, collateral, self.currency, cAmount, dAmount)) {\n            revert InvalidCDP(collateral, self.currency, cAmount, dAmount);\n        }\n\n        if (!isValidSupply(self, issued, dAmount)) {\n            revert SupplyLimitExceeded(self.supply, issued, dAmount);\n        }\n\n        bond = _predictAddress(self, collateral, self.currency, id);\n\n        // Check if the address has code\n        uint32 size;\n        assembly {\n            size := extcodesize(bond)\n        }\n\n        // If the address has code and it's a clone of impl, revert.\n        if (size > 0 || CloneFactory._isClone(self.impl, bond)) {\n            revert BondAlreadyExists(collateral, self.currency, id);\n        }\n\n        address proxy = CloneFactory._createCloneWithSalt(\n            self.impl,\n            _getSalt(collateral, self.currency, id)\n        );\n\n        IBond(proxy).initialize(id, collateral, self.currency, self.market);\n\n        self.count += 1;\n\n        return (proxy);\n    }\n\n    function _liquidate(\n        State storage self,\n        address collateral_,\n        address debt_,\n        uint128 id_\n    ) public returns (bool) {\n        // TODO: modify liquidator validation\n        if (msg.sender != self.liquidator) revert InvalidAccess(msg.sender, self.liquidator);\n        address bond = _predictAddress(self, collateral_, debt_, id_);\n        IBond(bond).liquidate();\n        return true;\n    }\n\n    function _borrowMore(\n        State storage self,\n        uint128 id_,\n        address collateral_, \n        uint256 amount_\n    ) public returns (bool) {\n        address bond = _predictAddress(self, collateral_, self.currency, id_);\n        //IBond(bond).borrowMore();\n    }\n\n    function _predictAddress(\n        State storage self,\n        address collateral_,\n        address debt_,\n        uint128 id_\n    ) public view returns (address) {\n        bytes32 salt = _getSalt(collateral_, debt_, id_);\n        return\n            CloneFactory.predictAddressWithSalt(address(this), self.impl, salt);\n    }\n\n    function isValidSupply(\n        State storage self,\n        uint256 issued_,\n        uint256 issueAmount_\n    ) public view returns (bool) {\n        return\n            issued_ + issueAmount_ - IERC20(self.currency).balanceOf(self.liquidator) <=\n            self.supply;\n    }\n\n    function _isValidCDP(\n        State storage self,\n        address collateral_,\n        address debt_,\n        uint256 cAmount_,\n        uint256 dAmount_\n    ) public view returns (bool) {\n        (uint256 collateralValueTimes100, uint256 debtValue) = _calculateValues(\n            self,\n            collateral_,\n            debt_,\n            cAmount_,\n            dAmount_\n        );\n\n        uint mcr = self.cdps[collateral_].mcr;\n        uint cDecimals = self.cdps[collateral_].decimals;\n\n        uint256 debtValueAdjusted = debtValue / (10 ** cDecimals);\n\n        // if the debt become obsolete\n        return\n            debtValueAdjusted == 0\n                ? true\n                : collateralValueTimes100 / debtValueAdjusted >= mcr;\n    }\n\n    function _calculateValues(\n        State storage self,\n        address collateral_,\n        address debt_,\n        uint256 cAmount_,\n        uint256 dAmount_\n    ) public view returns (uint256, uint256) {\n        uint256 collateralValue = getAssetValue(self, collateral_, cAmount_);\n        uint256 debtValue = getAssetValue(self, debt_, dAmount_);\n        uint256 collateralValueTimes100 = collateralValue * 100;\n        require(collateralValueTimes100 >= collateralValue); // overflow check\n        return (collateralValueTimes100, debtValue);\n    }\n\n    function _getAssetPrice(\n        State storage self,\n        address asset_\n    ) public view returns (uint) {\n        uint price = IEngine(self.market).mktPrice(asset_, self.currency);\n        if (price == 0) {\n            revert MktPriceIsZero(asset_, self.currency);\n        }\n        return price;\n    }\n\n    function getAssetValue(\n        State storage self,\n        address asset_,\n        uint256 amount_\n    ) public view returns (uint256) {\n        uint price = _getAssetPrice(self, asset_);\n        uint256 value = price * amount_;\n        if (value < amount_) {\n            revert ValueOverflow(price, amount_);\n        }\n        return value;\n    }\n\n    function _getSalt(\n        address collateral_,\n        address debt_,\n        uint128 id_\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(collateral_, debt_, id_));\n    }\n}\n"
        },
        "contracts/safu/libraries/TransferHelper.sol": {
            "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint256 value) internal {\n        // bytes4(keccak256(bytes(\"approve(address,uint256)\")));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"AF\");\n    }\n\n    function safeTransfer(address token, address to, uint256 value) internal {\n        // bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TF\");\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint256 value) internal {\n        // bytes4(keccak256(bytes(\"transferFrom(address,address,uint256)\")));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TFF\");\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success,) = to.call{value: value}(new bytes(0));\n        require(success, \"ETF\");\n    }\n\n    function decimals(address token) internal view returns (uint8) {\n        // bytes4(keccak256(bytes(\"decimals()\")));\n        (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(0x313ce567));\n        require(success, \"DF\");\n        return abi.decode(data, (uint8));\n    }\n}\n"
        },
        "contracts/security/Initializable.sol": {
            "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\ncontract Initializable {\n    bool private _initialized = false;\n\n    modifier initializer() {\n        // solhint-disable-next-line reason-string\n        require(!_initialized);\n        _;\n        _initialized = true;\n    }\n\n    function initialized() external view returns (bool) {\n        return _initialized;\n    }\n}\n"
        },
        "contracts/svg/interfaces/INFTConstructor.sol": {
            "content": "pragma solidity ^0.8.17;\n\nimport \"../libraries/NFTSVG.sol\";\n\ninterface INFTConstructor {\n    function generateParams(uint256 tokenId_)\n        external\n        view\n        returns (\n            NFTSVG.ChainParams memory cParam,\n            NFTSVG.BlParams memory blParam,\n            NFTSVG.HealthParams memory hParam,\n            NFTSVG.CltParams memory cltParam\n        );\n}\n"
        },
        "contracts/svg/interfaces/INFTSVG.sol": {
            "content": "pragma solidity ^0.8.17;\n\ninterface INFTSVG {\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
        },
        "contracts/svg/libraries/NFTSVG.sol": {
            "content": "pragma solidity ^0.8.17;\n\nlibrary NFTSVG {\n    struct ChainParams {\n        string chainId;\n        string chainName;\n        string collateral;\n        string debt;\n    }\n\n    struct BlParams {\n        string vault;\n        string cBlStr;\n        string dBlStr;\n        string symbol;\n        string lastUpdated;\n        string name;\n    }\n\n    struct CltParams {\n        string MCR;\n        string LFR;\n        string SFR;\n    }\n\n    struct HealthParams {\n        uint256 rawHP;\n        string HP;\n        string HPBarColor1;\n        string HPBarColor2;\n        string HPStatus;\n        string HPGauge;\n    }\n\n    function generateSVGDefs(ChainParams memory params) internal pure returns (string memory svg) {\n        svg = string(\n            abi.encodePacked(\n                '<svg width=\"400\" height=\"250\" viewBox=\"0 0 400 250\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"',\n                ' xmlns:xlink=\"http://www.w3.org/1999/xlink\">',\n                '<rect width=\"400\" height=\"250\" fill=\"url(#pattern0)\" />',\n                '<rect x=\"10\" y=\"12\" width=\"380\" height=\"226\" rx=\"20\" ry=\"20\" fill=\"rgba(0,0,0,0)\" stroke=\"rgba(255,255,255,0.8)\" />'\n            )\n        );\n    }\n\n    function generateBalances(BlParams memory params, string memory id) internal pure returns (string memory svg) {\n        svg = string(\n            abi.encodePacked(\n                '<text y=\"60\" x=\"32\" fill=\"white\"',\n                ' font-family=\"Poppins\" font-weight=\"400\" font-size=\"24px\">WETH Vault #',\n                id,\n                \"</text>\",\n                '<text y=\"85px\" x=\"32px\" fill=\"white\" font-family=\"Poppins\" font-weight=\"350\" font-size=\"14px\">Collateral: ',\n                params.cBlStr,\n                \" \",\n                params.symbol,\n                \"</text>\"\n                '<text y=\"110px\" x=\"32px\" fill=\"white\" font-family=\"Poppins\" font-weight=\"350\" font-size=\"14px\">IOU: ',\n                params.dBlStr,\n                \" \",\n                \"USM\" \"</text>\"\n            )\n        );\n    }\n\n    function generateHealth(HealthParams memory params) internal pure returns (string memory svg) {\n        svg = string(\n            abi.encodePacked(\n                '<text y=\"135px\" x=\"32px\" fill=\"white\" font-family=\"Poppins\" font-weight=\"350\" font-size=\"14px\">Health: ',\n                params.HP,\n                \"% \",\n                params.HPStatus,\n                \"</text>\"\n            )\n        );\n    }\n\n    function generateBitmap() internal pure returns (string memory svg) {\n        svg = string(\n            abi.encodePacked(\n                \"<g>\",\n                '<svg class=\"healthbar\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 -0.5 38 9\" shape-rendering=\"crispEdges\"',\n                ' x=\"-113px\" y=\"138px\" width=\"400px\" height=\"30px\">',\n                '<path stroke=\"#222034\"',\n                ' d=\"M2 2h1M3 2h32M3  3h1M2 3h1M35 3h1M3 4h1M2 4h1M35 4h1M3  5h1M2 5h1M35 5h1M3 6h32M3\" />',\n                '<path stroke=\"#323c39\" d=\"M3 3h32\" />',\n                '<path stroke=\"#494d4c\" d=\"M3 4h32M3 5h32\" />',\n                \"<g>\"\n            )\n        );\n    }\n\n    function generateStop(string memory color1, string memory color2) internal pure returns (string memory svg) {\n        svg = string(\n            abi.encodePacked(\n                '<stop offset=\"5.99%\">',\n                '<animate attributeName=\"stop-color\" values=\"',\n                color1,\n                \"; \",\n                color2,\n                \"; \",\n                color1,\n                '\" dur=\"3s\" repeatCount=\"indefinite\"></animate>',\n                \"</stop>\"\n            )\n        );\n    }\n\n    function generateLinearGradient(HealthParams memory params) internal pure returns (string memory svg) {\n        svg = string(\n            abi.encodePacked(\n                '<linearGradient id=\"myGradient\" gradientTransform=\"rotate(270.47)\" >',\n                generateStop(params.HPBarColor1, params.HPBarColor2),\n                generateStop(params.HPBarColor2, params.HPBarColor1),\n                \"</linearGradient>\"\n            )\n        );\n    }\n\n    function generateHealthBar(HealthParams memory params) internal pure returns (string memory svg) {\n        svg = string(\n            abi.encodePacked(\n                generateLinearGradient(params),\n                '<svg x=\"3\" y=\"2.5\" width=\"32\" height=\"10\">',\n                '<rect fill=\"',\n                \"url(\",\n                \"'#myGradient'\",\n                ')\"',\n                ' height=\"3\">',\n                ' <animate attributeName=\"width\" from=\"0\" to=\"',\n                params.HPGauge,\n                '\" dur=\"0.5s\" fill=\"freeze\" />',\n                \"</rect>\",\n                \"</svg>\",\n                \"</g>\",\n                \"</svg>\",\n                \"</g>\"\n            )\n        );\n    }\n\n    function generateCltParam(string memory y, string memory width, string memory desc, string memory percent)\n        internal\n        pure\n        returns (string memory svg)\n    {\n        svg = string(\n            abi.encodePacked(\n                '<g style=\"transform:translate(30px, ',\n                y,\n                ')\">',\n                '<rect width=\"',\n                width,\n                '\" height=\"12px\" rx=\"3px\" ry=\"3px\" fill=\"rgba(0,0,0,0.6)\" /><text x=\"6px\" y=\"9px\"',\n                ' font-family=\"Poppins\" font-size=\"8px\" fill=\"white\">',\n                '<tspan fill=\"rgba(255,255,255,0.6)\">',\n                desc,\n                \": </tspan>\",\n                percent,\n                \"% </text>\" \"</g>\"\n            )\n        );\n    }\n\n    function generateTextPath() internal pure returns (string memory svg) {\n        svg = string(\n            // text path has to be one liner, concatenating separate texts causes encoding error\n            abi.encodePacked(\n                '<path id=\"text-path-a\" transform=\"translate(1,1)\" d=\"M369.133 1.20364L28.9171 1.44856C13.4688 1.45969 0.948236 13.9804 0.937268 29.4287L0.80321 218.243C0.792219 233.723 13.3437 246.274 28.8233 246.263L369.04 246.018C384.488 246.007 397.008 233.486 397.019 218.038L397.153 29.2235C397.164 13.7439 384.613 1.1925 369.133 1.20364Z\" fill=\"none\" stroke=\"none\" />'\n            )\n        );\n    }\n\n    function generateText1(string memory a, string memory path) internal pure returns (string memory svg) {\n        svg = string(\n            abi.encodePacked(\n                '<text text-rendering=\"optimizeSpeed\">',\n                '<textPath startOffset=\"-100%\" fill=\"white\" font-family=\"Poppins\" font-size=\"10px\" xlink:href=\"#text-path-',\n                path,\n                '\">',\n                a,\n                '<animate additive=\"sum\" attributeName=\"startOffset\" from=\"0%\" to=\"100%\" begin=\"0s\" dur=\"30s\" repeatCount=\"indefinite\" />',\n                '</textPath> <textPath startOffset=\"0%\" fill=\"white\" font-family=\"Poppins\" font-size=\"10px\" xlink:href=\"#text-path-',\n                path,\n                '\">',\n                a,\n                '<animate additive=\"sum\" attributeName=\"startOffset\" from=\"0%\" to=\"100%\" begin=\"0s\" dur=\"30s\" repeatCount=\"indefinite\" /> </textPath>'\n            )\n        );\n    }\n\n    function generateText2(string memory b, string memory path) internal pure returns (string memory svg) {\n        svg = string(\n            abi.encodePacked(\n                '<textPath startOffset=\"50%\" fill=\"white\" font-family=\"Poppins\" font-size=\"10px\" xlink:href=\"#text-path-',\n                path,\n                '\">',\n                b,\n                '<animate additive=\"sum\" attributeName=\"startOffset\" from=\"0%\" to=\"100%\" begin=\"0s\" dur=\"30s\"',\n                ' repeatCount=\"indefinite\" /></textPath><textPath startOffset=\"-50%\" fill=\"white\" font-family=\"Poppins\" font-size=\"10px\" xlink:href=\"#text-path-',\n                path,\n                '\">',\n                b,\n                '<animate additive=\"sum\" attributeName=\"startOffset\" from=\"0%\" to=\"100%\" begin=\"0s\" dur=\"30s\" repeatCount=\"indefinite\" /></textPath></text>'\n            )\n        );\n    }\n\n    function generateNetwork(ChainParams memory cParams) internal pure returns (string memory svg) {\n        svg = string(abi.encodePacked(generateTokenLogos(cParams)));\n    }\n\n    function generateNetTextPath() internal pure returns (string memory svg) {\n        svg = string(\n            // text path has to be one liner, concatenating separate texts causes encoding error\n            abi.encodePacked(\n                '<path id=\"text-path-b\" transform=\"translate(269,35)\" d=\"M1 46C1 70.8528 21.1472 91 46 91C70.8528 91 91 70.8528 91 46C91 21.1472 70.8528 1 46 1C21.1472 1 1 21.1472 1 46Z\" stroke=\"none\"/>'\n            )\n        );\n    }\n\n    function generateTokenLogos(ChainParams memory cParam) internal pure returns (string memory svg) {\n        svg = string(\n            abi.encodePacked(\n                '<g style=\"transform:translate(265px, 180px)\">'\n                '<rect width=\"48px\" height=\"48px\" rx=\"10px\" ry=\"10px\" fill=\"none\" stroke=\"rgba(255,255,255,0.6)\" />'\n                \"</g>\" '<g style=\"transform:translate(325px, 180px)\">'\n                '<rect width=\"48px\" height=\"48px\" rx=\"10px\" ry=\"10px\" fill=\"none\" stroke=\"rgba(255,255,255,0.6)\" />'\n                \"</g>\"\n            )\n        );\n    }\n\n    function generateSVGWithoutImages(\n        string memory tokenId,\n        ChainParams memory cParams,\n        BlParams memory blParams,\n        HealthParams memory hParams,\n        CltParams memory cltParams\n    ) internal pure returns (string memory svg) {\n        string memory a = string(abi.encodePacked(blParams.vault, unicode\"  \", \"Vault\"));\n        string memory b = string(abi.encodePacked(unicode\"  \", cParams.chainName, unicode\"  \"));\n        string memory first = string(\n            abi.encodePacked(\n                generateSVGDefs(cParams),\n                generateBalances(blParams, tokenId),\n                generateHealth(hParams),\n                generateBitmap(),\n                generateHealthBar(hParams)\n            )\n        );\n        string memory second = string(\n            abi.encodePacked(\n                first,\n                generateCltParam(\"180px\", \"130px\", \"Min. Collateral Ratio\", cltParams.MCR),\n                generateCltParam(\"195px\", \"110px\", \"Liquidation Fee\", cltParams.LFR),\n                generateCltParam(\"210px\", \"90px\", \"Stability Fee\", cltParams.SFR),\n                generateTextPath()\n            )\n        );\n        svg = string(\n            abi.encodePacked(\n                second,\n                generateText1(a, \"a\"),\n                generateText2(a, \"a\"),\n                generateNetwork(cParams),\n                generateNetTextPath(),\n                generateText1(b, \"b\"),\n                generateText2(b, \"b\")\n            )\n        );\n    }\n}\n"
        },
        "contracts/svg/pureSVG.sol": {
            "content": "pragma solidity ^0.8.17;\n\nimport \"base64-sol/base64.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\ncontract PureSVG {\n    using Strings for uint256;\n\n    function generateSVGDefs() private pure returns (string memory svg) {\n        string memory url = \"https://i.imgur.com/YESHC62.png\";\n        svg = string(\n            abi.encodePacked(\n                '<svg width=\"400\" height=\"250\" viewBox=\"0 0 400 250\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"',\n                ' xmlns:xlink=\"http://www.w3.org/1999/xlink\">',\n                '<rect width=\"400\" height=\"250\" fill=\"url(#pattern0)\" />',\n                \"<defs>\",\n                '<pattern id=\"pattern0\" patternContentUnits=\"objectBoundingBox\" width=\"1\" height=\"1\">',\n                '<use xlink:href=\"#image0_18_24\" transform=\"scale(0.0025 0.004)\" />',\n                \"</pattern>\",\n                '<image id=\"image0_18_24\" width=\"400\" height=\"250\" xlink:href=\"',\n                \"https://raw.githubusercontent.com/digitalnativeinc/nft-arts/main/V1/backgrounds/\",\n                \"1088\",\n                \".png\",\n                '\"',\n                \" />\",\n                \"</defs>\",\n                '<rect x=\"10\" y=\"12\" width=\"380\" height=\"226\" rx=\"20\" ry=\"20\" fill=\"rgba(0,0,0,0)\" stroke=\"rgba(255,255,255,0.8)\" />'\n            )\n        );\n    }\n\n    function generateBalances() private pure returns (string memory svg) {\n        svg = string(\n            abi.encodePacked(\n                '<text y=\"60\" x=\"32\" fill=\"white\"',\n                ' font-family=\"Poppins\" font-weight=\"400\" font-size=\"24px\">WETH Vault #2</text>',\n                '<text y=\"85px\" x=\"32px\" fill=\"white\" font-family=\"Poppins\" font-weight=\"350\" font-size=\"14px\">Collateral: ',\n                \"1000\",\n                \" \",\n                \"WETH\",\n                \"</text>\"\n                '<text y=\"110px\" x=\"32px\" fill=\"white\" font-family=\"Poppins\" font-weight=\"350\" font-size=\"14px\">IOU: ',\n                \"1500\",\n                \" \",\n                \"USM\" \"</text>\"\n            )\n        );\n    }\n\n    function generateHealth() internal pure returns (string memory svg) {\n        string memory heart = unicode\"\";\n        svg = string(\n            abi.encodePacked(\n                '<text y=\"135px\" x=\"32px\" fill=\"white\" font-family=\"Poppins\" font-weight=\"350\" font-size=\"14px\">Health: ',\n                \"80\",\n                \"% \",\n                heart,\n                \"</text>\"\n            )\n        );\n    }\n\n    function generateBitmap() internal pure returns (string memory svg) {\n        svg = string(\n            abi.encodePacked(\n                \"<g>\",\n                '<svg class=\"healthbar\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 -0.5 38 9\" shape-rendering=\"crispEdges\"',\n                ' x=\"-113px\" y=\"138px\" width=\"400px\" height=\"30px\">',\n                '<path stroke=\"#222034\"',\n                ' d=\"M2 2h1M3 2h32M3  3h1M2 3h1M35 3h1M3 4h1M2 4h1M35 4h1M3  5h1M2 5h1M35 5h1M3 6h32M3\" />',\n                '<path stroke=\"#323c39\" d=\"M3 3h32\" />',\n                '<path stroke=\"#494d4c\" d=\"M3 4h32M3 5h32\" />',\n                \"<g>\"\n            )\n        );\n    }\n\n    function generateHealthBar() internal pure returns (string memory svg) {\n        svg = string(\n            abi.encodePacked(\n                '<svg x=\"3\" y=\"2.5\" width=\"32\" height=\"10\">',\n                '<rect fill=\"',\n                \"#57e705\",\n                '\" height=\"3\">',\n                ' <animate attributeName=\"width\" from=\"0\" to=\"20\" dur=\"0.5s\" fill=\"freeze\" />',\n                \"</rect>\",\n                \"</svg>\",\n                \"</g>\",\n                \"</svg>\",\n                \"</g>\"\n            )\n        );\n    }\n\n    function generateCltParams() internal pure returns (string memory svg) {\n        svg = string(\n            abi.encodePacked(\n                '<g style=\"transform:translate(30px, 180px)\">',\n                '<rect width=\"120px\" height=\"12px\" rx=\"3px\" ry=\"3px\" fill=\"rgba(0,0,0,0.6)\" /><text x=\"6px\" y=\"9px\"'\n                ' font-family=\"Poppins\" font-size=\"8px\" fill=\"white\">',\n                '<tspan fill=\"rgba(255,255,255,0.6)\">Min. Collateral Ratio: </tspan>',\n                \"150\",\n                \"% </text>\" \"</g>\",\n                '<g style=\"transform:translate(30px, 195px)\">',\n                '<rect width=\"110px\" height=\"12px\" rx=\"3px\" ry=\"3px\" fill=\"rgba(0,0,0,0.6)\" /><text x=\"6px\" y=\"9px\"'\n                ' font-family=\"Poppins\" font-size=\"8px\" fill=\"white\">',\n                '<tspan fill=\"rgba(255,255,255,0.6)\">Liq. Penalty Ratio: </tspan>',\n                \"150\",\n                \"% </text>\" \"</g>\",\n                '<g style=\"transform:translate(30px, 210px)\">',\n                '<rect width=\"80px\" height=\"12px\" rx=\"3px\" ry=\"3px\" fill=\"rgba(0,0,0,0.6)\" /><text x=\"6px\" y=\"9px\"'\n                ' font-family=\"Poppins\" font-size=\"8px\" fill=\"white\">',\n                '<tspan fill=\"rgba(255,255,255,0.6)\">Stability Fee: </tspan>',\n                \"150\",\n                \"% </text>\" \"</g>\"\n            )\n        );\n    }\n\n    function generateTextPath() internal pure returns (string memory svg) {\n        svg = string(\n            // text path has to be one liner, concatenating separate texts causes encoding error\n            abi.encodePacked(\n                '<path id=\"text-path-a\" transform=\"translate(1,1)\" d=\"M369.133 1.20364L28.9171 1.44856C13.4688 1.45969 0.948236 13.9804 0.937268 29.4287L0.80321 218.243C0.792219 233.723 13.3437 246.274 28.8233 246.263L369.04 246.018C384.488 246.007 397.008 233.486 397.019 218.038L397.153 29.2235C397.164 13.7439 384.613 1.1925 369.133 1.20364Z\" fill=\"none\" stroke=\"none\" />'\n            )\n        );\n    }\n\n    function generateText1(string memory a, string memory path) internal pure returns (string memory svg) {\n        svg = string(\n            abi.encodePacked(\n                '<text text-rendering=\"optimizeSpeed\">',\n                '<textPath startOffset=\"-100%\" fill=\"white\" font-family=\"Poppins\" font-size=\"10px\" xlink:href=\"#text-path-',\n                path,\n                '\">',\n                a,\n                '<animate additive=\"sum\" attributeName=\"startOffset\" from=\"0%\" to=\"100%\" begin=\"0s\" dur=\"30s\" repeatCount=\"indefinite\" />',\n                '</textPath> <textPath startOffset=\"0%\" fill=\"white\" font-family=\"Poppins\" font-size=\"10px\" xlink:href=\"#text-path-',\n                path,\n                '\">',\n                a,\n                '<animate additive=\"sum\" attributeName=\"startOffset\" from=\"0%\" to=\"100%\" begin=\"0s\" dur=\"30s\" repeatCount=\"indefinite\" /> </textPath>'\n            )\n        );\n    }\n\n    function generateText2(string memory b, string memory path) internal pure returns (string memory svg) {\n        svg = string(\n            abi.encodePacked(\n                '<textPath startOffset=\"50%\" fill=\"white\" font-family=\"Poppins\" font-size=\"10px\" xlink:href=\"#text-path-',\n                path,\n                '\">',\n                b,\n                '<animate additive=\"sum\" attributeName=\"startOffset\" from=\"0%\" to=\"100%\" begin=\"0s\" dur=\"30s\"',\n                ' repeatCount=\"indefinite\" /></textPath><textPath startOffset=\"-50%\" fill=\"white\" font-family=\"Poppins\" font-size=\"10px\" xlink:href=\"#text-path-',\n                path,\n                '\">',\n                b,\n                '<animate additive=\"sum\" attributeName=\"startOffset\" from=\"0%\" to=\"100%\" begin=\"0s\" dur=\"30s\" repeatCount=\"indefinite\" /></textPath></text>'\n            )\n        );\n    }\n\n    function generateNetwork() internal pure returns (string memory svg) {\n        svg = string(\n            abi.encodePacked(\n                '<image  x=\"285\" y=\"50\" width=\"60\" height=\"60\" xlink:href=\"'\n                \"https://raw.githubusercontent.com/digitalnativeinc/nft-arts/main/V1/networks/\",\n                \"1088\",\n                \".png\",\n                '\" />'\n            )\n        );\n    }\n\n    function generateNetTextPath() internal pure returns (string memory svg) {\n        svg = string(\n            // text path has to be one liner, concatenating separate texts causes encoding error\n            abi.encodePacked(\n                '<path id=\"text-path-b\" transform=\"translate(269,35)\" d=\"M1 46C1 70.8528 21.1472 91 46 91C70.8528 91 91 70.8528 91 46C91 21.1472 70.8528 1 46 1C21.1472 1 1 21.1472 1 46Z\" stroke=\"none\"/>'\n            )\n        );\n    }\n\n    function generateTokenLogos() internal pure returns (string memory svg) {\n        svg = string(\n            abi.encodePacked(\n                '<g style=\"transform:translate(265px, 180px)\">'\n                '<rect width=\"48px\" height=\"48px\" rx=\"10px\" ry=\"10px\" fill=\"none\" stroke=\"rgba(255,255,255,0.6)\" />'\n                '<image x=\"4\" y=\"4\" width=\"40\" height=\"40\" xlink:href=\"',\n                \"https://raw.githubusercontent.com/digitalnativeinc/nft-arts/main/V1/tokens/\",\n                \"4\",\n                \"/\" \"0xc778417E063141139Fce010982780140Aa0cD5Ab\",\n                \".png\",\n                '\" />' \"</g>\" '<g style=\"transform:translate(325px, 180px)\">'\n                '<rect width=\"48px\" height=\"48px\" rx=\"10px\" ry=\"10px\" fill=\"none\" stroke=\"rgba(255,255,255,0.6)\" />'\n                '<image x=\"4\" y=\"4\" width=\"40\" height=\"40\" xlink:href=\"',\n                \"https://raw.githubusercontent.com/digitalnativeinc/nft-arts/main/V1/tokens/\",\n                \"4\",\n                \"/\" \"0x6388e0cC745b3c5ED23c6D569A01A4D27eDa3E14\",\n                \".png\",\n                '\" />' \"</g>\"\n            )\n        );\n    }\n\n    function generateSVG() internal pure returns (string memory svg) {\n        string memory a =\n            string(abi.encodePacked(\"0x2260fac5e5542a773aa44fbcfedf7c193bc2c599\", unicode\"  \", \"Vault\"));\n        string memory b = string(abi.encodePacked(unicode\"  \", \"Ethereum\", unicode\"  \"));\n        string memory first = string(\n            abi.encodePacked(\n                generateSVGDefs(),\n                generateBalances(),\n                generateHealth(),\n                generateBitmap(),\n                generateHealthBar(),\n                generateCltParams(),\n                generateTextPath(),\n                generateText1(a, \"a\"),\n                generateText2(a, \"a\")\n            )\n        );\n        svg = string(\n            abi.encodePacked(\n                first,\n                generateNetwork(),\n                generateNetTextPath(),\n                generateText1(b, \"b\"),\n                generateText2(b, \"b\"),\n                generateTokenLogos(),\n                \"</svg>\"\n            )\n        );\n    }\n\n    // You could also just upload the raw SVG and have solildity convert it!\n    function svgToImageURI() public pure returns (string memory) {\n        // example:\n        // <svg width='500' height='500' viewBox='0 0 285 350' fill='none' xmlns='http://www.w3.org/2000/svg'><path fill='black' d='M150,0,L75,200,L225,200,Z'></path></svg>\n        // data:image/svg+xml;base64,PHN2ZyB3aWR0aD0nNTAwJyBoZWlnaHQ9JzUwMCcgdmlld0JveD0nMCAwIDI4NSAzNTAnIGZpbGw9J25vbmUnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc+PHBhdGggZmlsbD0nYmxhY2snIGQ9J00xNTAsMCxMNzUsMjAwLEwyMjUsMjAwLFonPjwvcGF0aD48L3N2Zz4=\n        string memory baseURL = \"data:image/svg+xml;base64,\";\n        string memory svgBase64Encoded = Base64.encode(bytes(string(abi.encodePacked(generateSVG()))));\n        return string(abi.encodePacked(baseURL, svgBase64Encoded));\n    }\n\n    function formatTokenURI(string memory imageURI) public pure returns (string memory) {\n        return string(\n            abi.encodePacked(\n                \"data:application/json;base64,\",\n                Base64.encode(\n                    bytes(\n                        abi.encodePacked(\n                            '{\"name\":\"',\n                            \"VaultOne\", // You can add whatever name here\n                            '\", \"description\":\"An NFT based on SVG!\", \"attributes\":\"\", \"image\":\"',\n                            imageURI,\n                            '\"}'\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    // remove later:\n    function bytes32ToString(bytes32 _bytes32) public pure returns (string memory) {\n        uint8 i = 0;\n        while (i < 32 && _bytes32[i] != 0) {\n            i++;\n        }\n        bytes memory bytesArray = new bytes(i);\n        for (i = 0; i < 32 && _bytes32[i] != 0; i++) {\n            bytesArray[i] = _bytes32[i];\n        }\n        return string(bytesArray);\n    }\n}\n"
        },
        "lib/forge-std/lib/ds-test/src/test.sol": {
            "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.5.0;\n\ncontract DSTest {\n    event log                    (string);\n    event logs                   (bytes);\n\n    event log_address            (address);\n    event log_bytes32            (bytes32);\n    event log_int                (int);\n    event log_uint               (uint);\n    event log_bytes              (bytes);\n    event log_string             (string);\n\n    event log_named_address      (string key, address val);\n    event log_named_bytes32      (string key, bytes32 val);\n    event log_named_decimal_int  (string key, int val, uint decimals);\n    event log_named_decimal_uint (string key, uint val, uint decimals);\n    event log_named_int          (string key, int val);\n    event log_named_uint         (string key, uint val);\n    event log_named_bytes        (string key, bytes val);\n    event log_named_string       (string key, string val);\n\n    bool public IS_TEST = true;\n    bool private _failed;\n\n    address constant HEVM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    modifier mayRevert() { _; }\n    modifier testopts(string memory) { _; }\n\n    function failed() public returns (bool) {\n        if (_failed) {\n            return _failed;\n        } else {\n            bool globalFailed = false;\n            if (hasHEVMContext()) {\n                (, bytes memory retdata) = HEVM_ADDRESS.call(\n                    abi.encodePacked(\n                        bytes4(keccak256(\"load(address,bytes32)\")),\n                        abi.encode(HEVM_ADDRESS, bytes32(\"failed\"))\n                    )\n                );\n                globalFailed = abi.decode(retdata, (bool));\n            }\n            return globalFailed;\n        }\n    }\n\n    function fail() internal virtual {\n        if (hasHEVMContext()) {\n            (bool status, ) = HEVM_ADDRESS.call(\n                abi.encodePacked(\n                    bytes4(keccak256(\"store(address,bytes32,bytes32)\")),\n                    abi.encode(HEVM_ADDRESS, bytes32(\"failed\"), bytes32(uint256(0x01)))\n                )\n            );\n            status; // Silence compiler warnings\n        }\n        _failed = true;\n    }\n\n    function hasHEVMContext() internal view returns (bool) {\n        uint256 hevmCodeSize = 0;\n        assembly {\n            hevmCodeSize := extcodesize(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D)\n        }\n        return hevmCodeSize > 0;\n    }\n\n    modifier logs_gas() {\n        uint startGas = gasleft();\n        _;\n        uint endGas = gasleft();\n        emit log_named_uint(\"gas\", startGas - endGas);\n    }\n\n    function assertTrue(bool condition) internal {\n        if (!condition) {\n            emit log(\"Error: Assertion Failed\");\n            fail();\n        }\n    }\n\n    function assertTrue(bool condition, string memory err) internal {\n        if (!condition) {\n            emit log_named_string(\"Error\", err);\n            assertTrue(condition);\n        }\n    }\n\n    function assertEq(address a, address b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [address]\");\n            emit log_named_address(\"      Left\", a);\n            emit log_named_address(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertEq(address a, address b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes32 a, bytes32 b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bytes32]\");\n            emit log_named_bytes32(\"      Left\", a);\n            emit log_named_bytes32(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertEq(bytes32 a, bytes32 b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq32(bytes32 a, bytes32 b) internal {\n        assertEq(a, b);\n    }\n    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {\n        assertEq(a, b, err);\n    }\n\n    function assertEq(int a, int b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [int]\");\n            emit log_named_int(\"      Left\", a);\n            emit log_named_int(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertEq(int a, int b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq(uint a, uint b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [uint]\");\n            emit log_named_uint(\"      Left\", a);\n            emit log_named_uint(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertEq(uint a, uint b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"      Left\", a, decimals);\n            emit log_named_decimal_int(\"     Right\", b, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"      Left\", a, decimals);\n            emit log_named_decimal_uint(\"     Right\", b, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n\n    function assertNotEq(address a, address b) internal {\n        if (a == b) {\n            emit log(\"Error: a != b not satisfied [address]\");\n            emit log_named_address(\"      Left\", a);\n            emit log_named_address(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertNotEq(address a, address b, string memory err) internal {\n        if (a == b) {\n            emit log_named_string (\"Error\", err);\n            assertNotEq(a, b);\n        }\n    }\n\n    function assertNotEq(bytes32 a, bytes32 b) internal {\n        if (a == b) {\n            emit log(\"Error: a != b not satisfied [bytes32]\");\n            emit log_named_bytes32(\"      Left\", a);\n            emit log_named_bytes32(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertNotEq(bytes32 a, bytes32 b, string memory err) internal {\n        if (a == b) {\n            emit log_named_string (\"Error\", err);\n            assertNotEq(a, b);\n        }\n    }\n    function assertNotEq32(bytes32 a, bytes32 b) internal {\n        assertNotEq(a, b);\n    }\n    function assertNotEq32(bytes32 a, bytes32 b, string memory err) internal {\n        assertNotEq(a, b, err);\n    }\n\n    function assertNotEq(int a, int b) internal {\n        if (a == b) {\n            emit log(\"Error: a != b not satisfied [int]\");\n            emit log_named_int(\"      Left\", a);\n            emit log_named_int(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertNotEq(int a, int b, string memory err) internal {\n        if (a == b) {\n            emit log_named_string(\"Error\", err);\n            assertNotEq(a, b);\n        }\n    }\n    function assertNotEq(uint a, uint b) internal {\n        if (a == b) {\n            emit log(\"Error: a != b not satisfied [uint]\");\n            emit log_named_uint(\"      Left\", a);\n            emit log_named_uint(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertNotEq(uint a, uint b, string memory err) internal {\n        if (a == b) {\n            emit log_named_string(\"Error\", err);\n            assertNotEq(a, b);\n        }\n    }\n    function assertNotEqDecimal(int a, int b, uint decimals) internal {\n        if (a == b) {\n            emit log(\"Error: a != b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"      Left\", a, decimals);\n            emit log_named_decimal_int(\"     Right\", b, decimals);\n            fail();\n        }\n    }\n    function assertNotEqDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a == b) {\n            emit log_named_string(\"Error\", err);\n            assertNotEqDecimal(a, b, decimals);\n        }\n    }\n    function assertNotEqDecimal(uint a, uint b, uint decimals) internal {\n        if (a == b) {\n            emit log(\"Error: a != b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"      Left\", a, decimals);\n            emit log_named_decimal_uint(\"     Right\", b, decimals);\n            fail();\n        }\n    }\n    function assertNotEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a == b) {\n            emit log_named_string(\"Error\", err);\n            assertNotEqDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGt(uint a, uint b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(uint a, uint b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGt(int a, int b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(int a, int b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGe(uint a, uint b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(uint a, uint b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGe(int a, int b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(int a, int b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLt(uint a, uint b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(uint a, uint b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLt(int a, int b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(int a, int b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLe(uint a, uint b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(uint a, uint b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLe(int a, int b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(int a, int b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLeDecimal(a, b, decimals);\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertEq(string memory a, string memory b) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log(\"Error: a == b not satisfied [string]\");\n            emit log_named_string(\"      Left\", a);\n            emit log_named_string(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertEq(string memory a, string memory b, string memory err) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertNotEq(string memory a, string memory b) internal {\n        if (keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b))) {\n            emit log(\"Error: a != b not satisfied [string]\");\n            emit log_named_string(\"      Left\", a);\n            emit log_named_string(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertNotEq(string memory a, string memory b, string memory err) internal {\n        if (keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b))) {\n            emit log_named_string(\"Error\", err);\n            assertNotEq(a, b);\n        }\n    }\n\n    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {\n        ok = true;\n        if (a.length == b.length) {\n            for (uint i = 0; i < a.length; i++) {\n                if (a[i] != b[i]) {\n                    ok = false;\n                }\n            }\n        } else {\n            ok = false;\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b) internal {\n        if (!checkEq0(a, b)) {\n            emit log(\"Error: a == b not satisfied [bytes]\");\n            emit log_named_bytes(\"      Left\", a);\n            emit log_named_bytes(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {\n        if (!checkEq0(a, b)) {\n            emit log_named_string(\"Error\", err);\n            assertEq0(a, b);\n        }\n    }\n\n    function assertNotEq0(bytes memory a, bytes memory b) internal {\n        if (checkEq0(a, b)) {\n            emit log(\"Error: a != b not satisfied [bytes]\");\n            emit log_named_bytes(\"      Left\", a);\n            emit log_named_bytes(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertNotEq0(bytes memory a, bytes memory b, string memory err) internal {\n        if (checkEq0(a, b)) {\n            emit log_named_string(\"Error\", err);\n            assertNotEq0(a, b);\n        }\n    }\n}\n"
        },
        "lib/forge-std/src/Base.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {StdStorage} from \"./StdStorage.sol\";\nimport {Vm, VmSafe} from \"./Vm.sol\";\n\nabstract contract CommonBase {\n    // Cheat code address, 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D.\n    address internal constant VM_ADDRESS = address(uint160(uint256(keccak256(\"hevm cheat code\"))));\n    // console.sol and console2.sol work by executing a staticcall to this address.\n    address internal constant CONSOLE = 0x000000000000000000636F6e736F6c652e6c6f67;\n    // Used when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.\n    address internal constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;\n    // Default address for tx.origin and msg.sender, 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38.\n    address internal constant DEFAULT_SENDER = address(uint160(uint256(keccak256(\"foundry default caller\"))));\n    // Address of the test contract, deployed by the DEFAULT_SENDER.\n    address internal constant DEFAULT_TEST_CONTRACT = 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;\n    // Deterministic deployment address of the Multicall3 contract.\n    address internal constant MULTICALL3_ADDRESS = 0xcA11bde05977b3631167028862bE2a173976CA11;\n    // The order of the secp256k1 curve.\n    uint256 internal constant SECP256K1_ORDER =\n        115792089237316195423570985008687907852837564279074904382605163141518161494337;\n\n    uint256 internal constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    Vm internal constant vm = Vm(VM_ADDRESS);\n    StdStorage internal stdstore;\n}\n\nabstract contract TestBase is CommonBase {}\n\nabstract contract ScriptBase is CommonBase {\n    VmSafe internal constant vmSafe = VmSafe(VM_ADDRESS);\n}\n"
        },
        "lib/forge-std/src/Script.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\n//  ABOUT\n// Forge Std's default Script.\n\n//  MODULES\nimport {console} from \"./console.sol\";\nimport {console2} from \"./console2.sol\";\nimport {safeconsole} from \"./safeconsole.sol\";\nimport {StdChains} from \"./StdChains.sol\";\nimport {StdCheatsSafe} from \"./StdCheats.sol\";\nimport {stdJson} from \"./StdJson.sol\";\nimport {stdMath} from \"./StdMath.sol\";\nimport {StdStorage, stdStorageSafe} from \"./StdStorage.sol\";\nimport {StdStyle} from \"./StdStyle.sol\";\nimport {StdUtils} from \"./StdUtils.sol\";\nimport {VmSafe} from \"./Vm.sol\";\n\n//  BOILERPLATE\nimport {ScriptBase} from \"./Base.sol\";\n\n//  SCRIPT\nabstract contract Script is StdChains, StdCheatsSafe, StdUtils, ScriptBase {\n    // Note: IS_SCRIPT() must return true.\n    bool public IS_SCRIPT = true;\n}\n"
        },
        "lib/forge-std/src/StdAssertions.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {DSTest} from \"ds-test/test.sol\";\nimport {stdMath} from \"./StdMath.sol\";\n\nabstract contract StdAssertions is DSTest {\n    event log_array(uint256[] val);\n    event log_array(int256[] val);\n    event log_array(address[] val);\n    event log_named_array(string key, uint256[] val);\n    event log_named_array(string key, int256[] val);\n    event log_named_array(string key, address[] val);\n\n    function fail(string memory err) internal virtual {\n        emit log_named_string(\"Error\", err);\n        fail();\n    }\n\n    function assertFalse(bool data) internal virtual {\n        assertTrue(!data);\n    }\n\n    function assertFalse(bool data, string memory err) internal virtual {\n        assertTrue(!data, err);\n    }\n\n    function assertEq(bool a, bool b) internal virtual {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bool]\");\n            emit log_named_string(\"      Left\", a ? \"true\" : \"false\");\n            emit log_named_string(\"     Right\", b ? \"true\" : \"false\");\n            fail();\n        }\n    }\n\n    function assertEq(bool a, bool b, string memory err) internal virtual {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes memory a, bytes memory b) internal virtual {\n        assertEq0(a, b);\n    }\n\n    function assertEq(bytes memory a, bytes memory b, string memory err) internal virtual {\n        assertEq0(a, b, err);\n    }\n\n    function assertEq(uint256[] memory a, uint256[] memory b) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [uint[]]\");\n            emit log_named_array(\"      Left\", a);\n            emit log_named_array(\"     Right\", b);\n            fail();\n        }\n    }\n\n    function assertEq(int256[] memory a, int256[] memory b) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [int[]]\");\n            emit log_named_array(\"      Left\", a);\n            emit log_named_array(\"     Right\", b);\n            fail();\n        }\n    }\n\n    function assertEq(address[] memory a, address[] memory b) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [address[]]\");\n            emit log_named_array(\"      Left\", a);\n            emit log_named_array(\"     Right\", b);\n            fail();\n        }\n    }\n\n    function assertEq(uint256[] memory a, uint256[] memory b, string memory err) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(int256[] memory a, int256[] memory b, string memory err) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(address[] memory a, address[] memory b, string memory err) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    // Legacy helper\n    function assertEqUint(uint256 a, uint256 b) internal virtual {\n        assertEq(uint256(a), uint256(b));\n    }\n\n    function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint(\"      Left\", a);\n            emit log_named_uint(\"     Right\", b);\n            emit log_named_uint(\" Max Delta\", maxDelta);\n            emit log_named_uint(\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta, string memory err) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqAbsDecimal(uint256 a, uint256 b, uint256 maxDelta, uint256 decimals) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_decimal_uint(\"      Left\", a, decimals);\n            emit log_named_decimal_uint(\"     Right\", b, decimals);\n            emit log_named_decimal_uint(\" Max Delta\", maxDelta, decimals);\n            emit log_named_decimal_uint(\"     Delta\", delta, decimals);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbsDecimal(uint256 a, uint256 b, uint256 maxDelta, uint256 decimals, string memory err)\n        internal\n        virtual\n    {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqAbsDecimal(a, b, maxDelta, decimals);\n        }\n    }\n\n    function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int(\"       Left\", a);\n            emit log_named_int(\"      Right\", b);\n            emit log_named_uint(\" Max Delta\", maxDelta);\n            emit log_named_uint(\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta, string memory err) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqAbsDecimal(int256 a, int256 b, uint256 maxDelta, uint256 decimals) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [int]\");\n            emit log_named_decimal_int(\"      Left\", a, decimals);\n            emit log_named_decimal_int(\"     Right\", b, decimals);\n            emit log_named_decimal_uint(\" Max Delta\", maxDelta, decimals);\n            emit log_named_decimal_uint(\"     Delta\", delta, decimals);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbsDecimal(int256 a, int256 b, uint256 maxDelta, uint256 decimals, string memory err)\n        internal\n        virtual\n    {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqAbsDecimal(a, b, maxDelta, decimals);\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint(\"        Left\", a);\n            emit log_named_uint(\"       Right\", b);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta * 100, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta * 100, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n\n    function assertApproxEqRelDecimal(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        uint256 decimals\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_decimal_uint(\"        Left\", a, decimals);\n            emit log_named_decimal_uint(\"       Right\", b, decimals);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta * 100, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta * 100, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRelDecimal(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        uint256 decimals,\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals);\n        }\n    }\n\n    function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int(\"        Left\", a);\n            emit log_named_int(\"       Right\", b);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta * 100, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta * 100, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta, string memory err) internal virtual {\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n\n    function assertApproxEqRelDecimal(int256 a, int256 b, uint256 maxPercentDelta, uint256 decimals) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [int]\");\n            emit log_named_decimal_int(\"        Left\", a, decimals);\n            emit log_named_decimal_int(\"       Right\", b, decimals);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta * 100, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta * 100, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRelDecimal(int256 a, int256 b, uint256 maxPercentDelta, uint256 decimals, string memory err)\n        internal\n        virtual\n    {\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals);\n        }\n    }\n\n    function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB) internal virtual {\n        assertEqCall(target, callDataA, target, callDataB, true);\n    }\n\n    function assertEqCall(address targetA, bytes memory callDataA, address targetB, bytes memory callDataB)\n        internal\n        virtual\n    {\n        assertEqCall(targetA, callDataA, targetB, callDataB, true);\n    }\n\n    function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB, bool strictRevertData)\n        internal\n        virtual\n    {\n        assertEqCall(target, callDataA, target, callDataB, strictRevertData);\n    }\n\n    function assertEqCall(\n        address targetA,\n        bytes memory callDataA,\n        address targetB,\n        bytes memory callDataB,\n        bool strictRevertData\n    ) internal virtual {\n        (bool successA, bytes memory returnDataA) = address(targetA).call(callDataA);\n        (bool successB, bytes memory returnDataB) = address(targetB).call(callDataB);\n\n        if (successA && successB) {\n            assertEq(returnDataA, returnDataB, \"Call return data does not match\");\n        }\n\n        if (!successA && !successB && strictRevertData) {\n            assertEq(returnDataA, returnDataB, \"Call revert data does not match\");\n        }\n\n        if (!successA && successB) {\n            emit log(\"Error: Calls were not equal\");\n            emit log_named_bytes(\"  Left call revert data\", returnDataA);\n            emit log_named_bytes(\" Right call return data\", returnDataB);\n            fail();\n        }\n\n        if (successA && !successB) {\n            emit log(\"Error: Calls were not equal\");\n            emit log_named_bytes(\"  Left call return data\", returnDataA);\n            emit log_named_bytes(\" Right call revert data\", returnDataB);\n            fail();\n        }\n    }\n}\n"
        },
        "lib/forge-std/src/StdChains.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {VmSafe} from \"./Vm.sol\";\n\n/**\n * StdChains provides information about EVM compatible chains that can be used in scripts/tests.\n * For each chain, the chain's name, chain ID, and a default RPC URL are provided. Chains are\n * identified by their alias, which is the same as the alias in the `[rpc_endpoints]` section of\n * the `foundry.toml` file. For best UX, ensure the alias in the `foundry.toml` file match the\n * alias used in this contract, which can be found as the first argument to the\n * `setChainWithDefaultRpcUrl` call in the `initializeStdChains` function.\n *\n * There are two main ways to use this contract:\n *   1. Set a chain with `setChain(string memory chainAlias, ChainData memory chain)` or\n *      `setChain(string memory chainAlias, Chain memory chain)`\n *   2. Get a chain with `getChain(string memory chainAlias)` or `getChain(uint256 chainId)`.\n *\n * The first time either of those are used, chains are initialized with the default set of RPC URLs.\n * This is done in `initializeStdChains`, which uses `setChainWithDefaultRpcUrl`. Defaults are recorded in\n * `defaultRpcUrls`.\n *\n * The `setChain` function is straightforward, and it simply saves off the given chain data.\n *\n * The `getChain` methods use `getChainWithUpdatedRpcUrl` to return a chain. For example, let's say\n * we want to retrieve the RPC URL for `mainnet`:\n *   - If you have specified data with `setChain`, it will return that.\n *   - If you have configured a mainnet RPC URL in `foundry.toml`, it will return the URL, provided it\n *     is valid (e.g. a URL is specified, or an environment variable is given and exists).\n *   - If neither of the above conditions is met, the default data is returned.\n *\n * Summarizing the above, the prioritization hierarchy is `setChain` -> `foundry.toml` -> environment variable -> defaults.\n */\nabstract contract StdChains {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    bool private stdChainsInitialized;\n\n    struct ChainData {\n        string name;\n        uint256 chainId;\n        string rpcUrl;\n    }\n\n    struct Chain {\n        // The chain name.\n        string name;\n        // The chain's Chain ID.\n        uint256 chainId;\n        // The chain's alias. (i.e. what gets specified in `foundry.toml`).\n        string chainAlias;\n        // A default RPC endpoint for this chain.\n        // NOTE: This default RPC URL is included for convenience to facilitate quick tests and\n        // experimentation. Do not use this RPC URL for production test suites, CI, or other heavy\n        // usage as you will be throttled and this is a disservice to others who need this endpoint.\n        string rpcUrl;\n    }\n\n    // Maps from the chain's alias (matching the alias in the `foundry.toml` file) to chain data.\n    mapping(string => Chain) private chains;\n    // Maps from the chain's alias to it's default RPC URL.\n    mapping(string => string) private defaultRpcUrls;\n    // Maps from a chain ID to it's alias.\n    mapping(uint256 => string) private idToAlias;\n\n    bool private fallbackToDefaultRpcUrls = true;\n\n    // The RPC URL will be fetched from config or defaultRpcUrls if possible.\n    function getChain(string memory chainAlias) internal virtual returns (Chain memory chain) {\n        require(bytes(chainAlias).length != 0, \"StdChains getChain(string): Chain alias cannot be the empty string.\");\n\n        initializeStdChains();\n        chain = chains[chainAlias];\n        require(\n            chain.chainId != 0,\n            string(abi.encodePacked(\"StdChains getChain(string): Chain with alias \\\"\", chainAlias, \"\\\" not found.\"))\n        );\n\n        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);\n    }\n\n    function getChain(uint256 chainId) internal virtual returns (Chain memory chain) {\n        require(chainId != 0, \"StdChains getChain(uint256): Chain ID cannot be 0.\");\n        initializeStdChains();\n        string memory chainAlias = idToAlias[chainId];\n\n        chain = chains[chainAlias];\n\n        require(\n            chain.chainId != 0,\n            string(abi.encodePacked(\"StdChains getChain(uint256): Chain with ID \", vm.toString(chainId), \" not found.\"))\n        );\n\n        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);\n    }\n\n    // set chain info, with priority to argument's rpcUrl field.\n    function setChain(string memory chainAlias, ChainData memory chain) internal virtual {\n        require(\n            bytes(chainAlias).length != 0,\n            \"StdChains setChain(string,ChainData): Chain alias cannot be the empty string.\"\n        );\n\n        require(chain.chainId != 0, \"StdChains setChain(string,ChainData): Chain ID cannot be 0.\");\n\n        initializeStdChains();\n        string memory foundAlias = idToAlias[chain.chainId];\n\n        require(\n            bytes(foundAlias).length == 0 || keccak256(bytes(foundAlias)) == keccak256(bytes(chainAlias)),\n            string(\n                abi.encodePacked(\n                    \"StdChains setChain(string,ChainData): Chain ID \",\n                    vm.toString(chain.chainId),\n                    \" already used by \\\"\",\n                    foundAlias,\n                    \"\\\".\"\n                )\n            )\n        );\n\n        uint256 oldChainId = chains[chainAlias].chainId;\n        delete idToAlias[oldChainId];\n\n        chains[chainAlias] =\n            Chain({name: chain.name, chainId: chain.chainId, chainAlias: chainAlias, rpcUrl: chain.rpcUrl});\n        idToAlias[chain.chainId] = chainAlias;\n    }\n\n    // set chain info, with priority to argument's rpcUrl field.\n    function setChain(string memory chainAlias, Chain memory chain) internal virtual {\n        setChain(chainAlias, ChainData({name: chain.name, chainId: chain.chainId, rpcUrl: chain.rpcUrl}));\n    }\n\n    function _toUpper(string memory str) private pure returns (string memory) {\n        bytes memory strb = bytes(str);\n        bytes memory copy = new bytes(strb.length);\n        for (uint256 i = 0; i < strb.length; i++) {\n            bytes1 b = strb[i];\n            if (b >= 0x61 && b <= 0x7A) {\n                copy[i] = bytes1(uint8(b) - 32);\n            } else {\n                copy[i] = b;\n            }\n        }\n        return string(copy);\n    }\n\n    // lookup rpcUrl, in descending order of priority:\n    // current -> config (foundry.toml) -> environment variable -> default\n    function getChainWithUpdatedRpcUrl(string memory chainAlias, Chain memory chain) private returns (Chain memory) {\n        if (bytes(chain.rpcUrl).length == 0) {\n            try vm.rpcUrl(chainAlias) returns (string memory configRpcUrl) {\n                chain.rpcUrl = configRpcUrl;\n            } catch (bytes memory err) {\n                string memory envName = string(abi.encodePacked(_toUpper(chainAlias), \"_RPC_URL\"));\n                if (fallbackToDefaultRpcUrls) {\n                    chain.rpcUrl = vm.envOr(envName, defaultRpcUrls[chainAlias]);\n                } else {\n                    chain.rpcUrl = vm.envString(envName);\n                }\n                // distinguish 'not found' from 'cannot read'\n                bytes memory notFoundError =\n                    abi.encodeWithSignature(\"CheatCodeError\", string(abi.encodePacked(\"invalid rpc url \", chainAlias)));\n                if (keccak256(notFoundError) != keccak256(err) || bytes(chain.rpcUrl).length == 0) {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, err), mload(err))\n                    }\n                }\n            }\n        }\n        return chain;\n    }\n\n    function setFallbackToDefaultRpcUrls(bool useDefault) internal {\n        fallbackToDefaultRpcUrls = useDefault;\n    }\n\n    function initializeStdChains() private {\n        if (stdChainsInitialized) return;\n\n        stdChainsInitialized = true;\n\n        // If adding an RPC here, make sure to test the default RPC URL in `testRpcs`\n        setChainWithDefaultRpcUrl(\"anvil\", ChainData(\"Anvil\", 31337, \"http://127.0.0.1:8545\"));\n        setChainWithDefaultRpcUrl(\n            \"mainnet\", ChainData(\"Mainnet\", 1, \"https://mainnet.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"goerli\", ChainData(\"Goerli\", 5, \"https://goerli.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"sepolia\", ChainData(\"Sepolia\", 11155111, \"https://sepolia.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001\")\n        );\n        setChainWithDefaultRpcUrl(\"optimism\", ChainData(\"Optimism\", 10, \"https://mainnet.optimism.io\"));\n        setChainWithDefaultRpcUrl(\"optimism_goerli\", ChainData(\"Optimism Goerli\", 420, \"https://goerli.optimism.io\"));\n        setChainWithDefaultRpcUrl(\"arbitrum_one\", ChainData(\"Arbitrum One\", 42161, \"https://arb1.arbitrum.io/rpc\"));\n        setChainWithDefaultRpcUrl(\n            \"arbitrum_one_goerli\", ChainData(\"Arbitrum One Goerli\", 421613, \"https://goerli-rollup.arbitrum.io/rpc\")\n        );\n        setChainWithDefaultRpcUrl(\"arbitrum_nova\", ChainData(\"Arbitrum Nova\", 42170, \"https://nova.arbitrum.io/rpc\"));\n        setChainWithDefaultRpcUrl(\"polygon\", ChainData(\"Polygon\", 137, \"https://polygon-rpc.com\"));\n        setChainWithDefaultRpcUrl(\n            \"polygon_mumbai\", ChainData(\"Polygon Mumbai\", 80001, \"https://rpc-mumbai.maticvigil.com\")\n        );\n        setChainWithDefaultRpcUrl(\"avalanche\", ChainData(\"Avalanche\", 43114, \"https://api.avax.network/ext/bc/C/rpc\"));\n        setChainWithDefaultRpcUrl(\n            \"avalanche_fuji\", ChainData(\"Avalanche Fuji\", 43113, \"https://api.avax-test.network/ext/bc/C/rpc\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"bnb_smart_chain\", ChainData(\"BNB Smart Chain\", 56, \"https://bsc-dataseed1.binance.org\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"bnb_smart_chain_testnet\",\n            ChainData(\"BNB Smart Chain Testnet\", 97, \"https://rpc.ankr.com/bsc_testnet_chapel\")\n        );\n        setChainWithDefaultRpcUrl(\"gnosis_chain\", ChainData(\"Gnosis Chain\", 100, \"https://rpc.gnosischain.com\"));\n    }\n\n    // set chain info, with priority to chainAlias' rpc url in foundry.toml\n    function setChainWithDefaultRpcUrl(string memory chainAlias, ChainData memory chain) private {\n        string memory rpcUrl = chain.rpcUrl;\n        defaultRpcUrls[chainAlias] = rpcUrl;\n        chain.rpcUrl = \"\";\n        setChain(chainAlias, chain);\n        chain.rpcUrl = rpcUrl; // restore argument\n    }\n}\n"
        },
        "lib/forge-std/src/StdCheats.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {StdStorage, stdStorage} from \"./StdStorage.sol\";\nimport {Vm} from \"./Vm.sol\";\n\nabstract contract StdCheatsSafe {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    uint256 private constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    bool private gasMeteringOff;\n\n    // Data structures to parse Transaction objects from the broadcast artifact\n    // that conform to EIP1559. The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct RawTx1559 {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        // json value name = function\n        string functionSig;\n        bytes32 hash;\n        // json value name = tx\n        RawTx1559Detail txDetail;\n        // json value name = type\n        string opcode;\n    }\n\n    struct RawTx1559Detail {\n        AccessList[] accessList;\n        bytes data;\n        address from;\n        bytes gas;\n        bytes nonce;\n        address to;\n        bytes txType;\n        bytes value;\n    }\n\n    struct Tx1559 {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        string functionSig;\n        bytes32 hash;\n        Tx1559Detail txDetail;\n        string opcode;\n    }\n\n    struct Tx1559Detail {\n        AccessList[] accessList;\n        bytes data;\n        address from;\n        uint256 gas;\n        uint256 nonce;\n        address to;\n        uint256 txType;\n        uint256 value;\n    }\n\n    // Data structures to parse Transaction objects from the broadcast artifact\n    // that DO NOT conform to EIP1559. The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct TxLegacy {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        string functionSig;\n        string hash;\n        string opcode;\n        TxDetailLegacy transaction;\n    }\n\n    struct TxDetailLegacy {\n        AccessList[] accessList;\n        uint256 chainId;\n        bytes data;\n        address from;\n        uint256 gas;\n        uint256 gasPrice;\n        bytes32 hash;\n        uint256 nonce;\n        bytes1 opcode;\n        bytes32 r;\n        bytes32 s;\n        uint256 txType;\n        address to;\n        uint8 v;\n        uint256 value;\n    }\n\n    struct AccessList {\n        address accessAddress;\n        bytes32[] storageKeys;\n    }\n\n    // Data structures to parse Receipt objects from the broadcast artifact.\n    // The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct RawReceipt {\n        bytes32 blockHash;\n        bytes blockNumber;\n        address contractAddress;\n        bytes cumulativeGasUsed;\n        bytes effectiveGasPrice;\n        address from;\n        bytes gasUsed;\n        RawReceiptLog[] logs;\n        bytes logsBloom;\n        bytes status;\n        address to;\n        bytes32 transactionHash;\n        bytes transactionIndex;\n    }\n\n    struct Receipt {\n        bytes32 blockHash;\n        uint256 blockNumber;\n        address contractAddress;\n        uint256 cumulativeGasUsed;\n        uint256 effectiveGasPrice;\n        address from;\n        uint256 gasUsed;\n        ReceiptLog[] logs;\n        bytes logsBloom;\n        uint256 status;\n        address to;\n        bytes32 transactionHash;\n        uint256 transactionIndex;\n    }\n\n    // Data structures to parse the entire broadcast artifact, assuming the\n    // transactions conform to EIP1559.\n\n    struct EIP1559ScriptArtifact {\n        string[] libraries;\n        string path;\n        string[] pending;\n        Receipt[] receipts;\n        uint256 timestamp;\n        Tx1559[] transactions;\n        TxReturn[] txReturns;\n    }\n\n    struct RawEIP1559ScriptArtifact {\n        string[] libraries;\n        string path;\n        string[] pending;\n        RawReceipt[] receipts;\n        TxReturn[] txReturns;\n        uint256 timestamp;\n        RawTx1559[] transactions;\n    }\n\n    struct RawReceiptLog {\n        // json value = address\n        address logAddress;\n        bytes32 blockHash;\n        bytes blockNumber;\n        bytes data;\n        bytes logIndex;\n        bool removed;\n        bytes32[] topics;\n        bytes32 transactionHash;\n        bytes transactionIndex;\n        bytes transactionLogIndex;\n    }\n\n    struct ReceiptLog {\n        // json value = address\n        address logAddress;\n        bytes32 blockHash;\n        uint256 blockNumber;\n        bytes data;\n        uint256 logIndex;\n        bytes32[] topics;\n        uint256 transactionIndex;\n        uint256 transactionLogIndex;\n        bool removed;\n    }\n\n    struct TxReturn {\n        string internalType;\n        string value;\n    }\n\n    struct Account {\n        address addr;\n        uint256 key;\n    }\n\n    enum AddressType {\n        Payable,\n        NonPayable,\n        ZeroAddress,\n        Precompile,\n        ForgeAddress\n    }\n\n    // Checks that `addr` is not blacklisted by token contracts that have a blacklist.\n    function assumeNotBlacklisted(address token, address addr) internal view virtual {\n        // Nothing to check if `token` is not a contract.\n        uint256 tokenCodeSize;\n        assembly {\n            tokenCodeSize := extcodesize(token)\n        }\n        require(tokenCodeSize > 0, \"StdCheats assumeNotBlacklisted(address,address): Token address is not a contract.\");\n\n        bool success;\n        bytes memory returnData;\n\n        // 4-byte selector for `isBlacklisted(address)`, used by USDC.\n        (success, returnData) = token.staticcall(abi.encodeWithSelector(0xfe575a87, addr));\n        vm.assume(!success || abi.decode(returnData, (bool)) == false);\n\n        // 4-byte selector for `isBlackListed(address)`, used by USDT.\n        (success, returnData) = token.staticcall(abi.encodeWithSelector(0xe47d6060, addr));\n        vm.assume(!success || abi.decode(returnData, (bool)) == false);\n    }\n\n    // Checks that `addr` is not blacklisted by token contracts that have a blacklist.\n    // This is identical to `assumeNotBlacklisted(address,address)` but with a different name, for\n    // backwards compatibility, since this name was used in the original PR which has already has\n    // a release. This function can be removed in a future release once we want a breaking change.\n    function assumeNoBlacklisted(address token, address addr) internal view virtual {\n        assumeNotBlacklisted(token, addr);\n    }\n\n    function assumeAddressIsNot(address addr, AddressType addressType) internal virtual {\n        if (addressType == AddressType.Payable) {\n            assumeNotPayable(addr);\n        } else if (addressType == AddressType.NonPayable) {\n            assumePayable(addr);\n        } else if (addressType == AddressType.ZeroAddress) {\n            assumeNotZeroAddress(addr);\n        } else if (addressType == AddressType.Precompile) {\n            assumeNotPrecompile(addr);\n        } else if (addressType == AddressType.ForgeAddress) {\n            assumeNotForgeAddress(addr);\n        }\n    }\n\n    function assumeAddressIsNot(address addr, AddressType addressType1, AddressType addressType2) internal virtual {\n        assumeAddressIsNot(addr, addressType1);\n        assumeAddressIsNot(addr, addressType2);\n    }\n\n    function assumeAddressIsNot(\n        address addr,\n        AddressType addressType1,\n        AddressType addressType2,\n        AddressType addressType3\n    ) internal virtual {\n        assumeAddressIsNot(addr, addressType1);\n        assumeAddressIsNot(addr, addressType2);\n        assumeAddressIsNot(addr, addressType3);\n    }\n\n    function assumeAddressIsNot(\n        address addr,\n        AddressType addressType1,\n        AddressType addressType2,\n        AddressType addressType3,\n        AddressType addressType4\n    ) internal virtual {\n        assumeAddressIsNot(addr, addressType1);\n        assumeAddressIsNot(addr, addressType2);\n        assumeAddressIsNot(addr, addressType3);\n        assumeAddressIsNot(addr, addressType4);\n    }\n\n    // This function checks whether an address, `addr`, is payable. It works by sending 1 wei to\n    // `addr` and checking the `success` return value.\n    // NOTE: This function may result in state changes depending on the fallback/receive logic\n    // implemented by `addr`, which should be taken into account when this function is used.\n    function _isPayable(address addr) private returns (bool) {\n        require(\n            addr.balance < UINT256_MAX,\n            \"StdCheats _isPayable(address): Balance equals max uint256, so it cannot receive any more funds\"\n        );\n        uint256 origBalanceTest = address(this).balance;\n        uint256 origBalanceAddr = address(addr).balance;\n\n        vm.deal(address(this), 1);\n        (bool success,) = payable(addr).call{value: 1}(\"\");\n\n        // reset balances\n        vm.deal(address(this), origBalanceTest);\n        vm.deal(addr, origBalanceAddr);\n\n        return success;\n    }\n\n    // NOTE: This function may result in state changes depending on the fallback/receive logic\n    // implemented by `addr`, which should be taken into account when this function is used. See the\n    // `_isPayable` method for more information.\n    function assumePayable(address addr) internal virtual {\n        vm.assume(_isPayable(addr));\n    }\n\n    function assumeNotPayable(address addr) internal virtual {\n        vm.assume(!_isPayable(addr));\n    }\n\n    function assumeNotZeroAddress(address addr) internal pure virtual {\n        vm.assume(addr != address(0));\n    }\n\n    function assumeNotPrecompile(address addr) internal pure virtual {\n        assumeNotPrecompile(addr, _pureChainId());\n    }\n\n    function assumeNotPrecompile(address addr, uint256 chainId) internal pure virtual {\n        // Note: For some chains like Optimism these are technically predeploys (i.e. bytecode placed at a specific\n        // address), but the same rationale for excluding them applies so we include those too.\n\n        // These should be present on all EVM-compatible chains.\n        vm.assume(addr < address(0x1) || addr > address(0x9));\n\n        // forgefmt: disable-start\n        if (chainId == 10 || chainId == 420) {\n            // https://github.com/ethereum-optimism/optimism/blob/eaa371a0184b56b7ca6d9eb9cb0a2b78b2ccd864/op-bindings/predeploys/addresses.go#L6-L21\n            vm.assume(addr < address(0x4200000000000000000000000000000000000000) || addr > address(0x4200000000000000000000000000000000000800));\n        } else if (chainId == 42161 || chainId == 421613) {\n            // https://developer.arbitrum.io/useful-addresses#arbitrum-precompiles-l2-same-on-all-arb-chains\n            vm.assume(addr < address(0x0000000000000000000000000000000000000064) || addr > address(0x0000000000000000000000000000000000000068));\n        } else if (chainId == 43114 || chainId == 43113) {\n            // https://github.com/ava-labs/subnet-evm/blob/47c03fd007ecaa6de2c52ea081596e0a88401f58/precompile/params.go#L18-L59\n            vm.assume(addr < address(0x0100000000000000000000000000000000000000) || addr > address(0x01000000000000000000000000000000000000ff));\n            vm.assume(addr < address(0x0200000000000000000000000000000000000000) || addr > address(0x02000000000000000000000000000000000000FF));\n            vm.assume(addr < address(0x0300000000000000000000000000000000000000) || addr > address(0x03000000000000000000000000000000000000Ff));\n        }\n        // forgefmt: disable-end\n    }\n\n    function assumeNotForgeAddress(address addr) internal pure virtual {\n        // vm and console addresses\n        vm.assume(addr != address(vm) || addr != 0x000000000000000000636F6e736F6c652e6c6f67);\n    }\n\n    function readEIP1559ScriptArtifact(string memory path)\n        internal\n        view\n        virtual\n        returns (EIP1559ScriptArtifact memory)\n    {\n        string memory data = vm.readFile(path);\n        bytes memory parsedData = vm.parseJson(data);\n        RawEIP1559ScriptArtifact memory rawArtifact = abi.decode(parsedData, (RawEIP1559ScriptArtifact));\n        EIP1559ScriptArtifact memory artifact;\n        artifact.libraries = rawArtifact.libraries;\n        artifact.path = rawArtifact.path;\n        artifact.timestamp = rawArtifact.timestamp;\n        artifact.pending = rawArtifact.pending;\n        artifact.txReturns = rawArtifact.txReturns;\n        artifact.receipts = rawToConvertedReceipts(rawArtifact.receipts);\n        artifact.transactions = rawToConvertedEIPTx1559s(rawArtifact.transactions);\n        return artifact;\n    }\n\n    function rawToConvertedEIPTx1559s(RawTx1559[] memory rawTxs) internal pure virtual returns (Tx1559[] memory) {\n        Tx1559[] memory txs = new Tx1559[](rawTxs.length);\n        for (uint256 i; i < rawTxs.length; i++) {\n            txs[i] = rawToConvertedEIPTx1559(rawTxs[i]);\n        }\n        return txs;\n    }\n\n    function rawToConvertedEIPTx1559(RawTx1559 memory rawTx) internal pure virtual returns (Tx1559 memory) {\n        Tx1559 memory transaction;\n        transaction.arguments = rawTx.arguments;\n        transaction.contractName = rawTx.contractName;\n        transaction.functionSig = rawTx.functionSig;\n        transaction.hash = rawTx.hash;\n        transaction.txDetail = rawToConvertedEIP1559Detail(rawTx.txDetail);\n        transaction.opcode = rawTx.opcode;\n        return transaction;\n    }\n\n    function rawToConvertedEIP1559Detail(RawTx1559Detail memory rawDetail)\n        internal\n        pure\n        virtual\n        returns (Tx1559Detail memory)\n    {\n        Tx1559Detail memory txDetail;\n        txDetail.data = rawDetail.data;\n        txDetail.from = rawDetail.from;\n        txDetail.to = rawDetail.to;\n        txDetail.nonce = _bytesToUint(rawDetail.nonce);\n        txDetail.txType = _bytesToUint(rawDetail.txType);\n        txDetail.value = _bytesToUint(rawDetail.value);\n        txDetail.gas = _bytesToUint(rawDetail.gas);\n        txDetail.accessList = rawDetail.accessList;\n        return txDetail;\n    }\n\n    function readTx1559s(string memory path) internal view virtual returns (Tx1559[] memory) {\n        string memory deployData = vm.readFile(path);\n        bytes memory parsedDeployData = vm.parseJson(deployData, \".transactions\");\n        RawTx1559[] memory rawTxs = abi.decode(parsedDeployData, (RawTx1559[]));\n        return rawToConvertedEIPTx1559s(rawTxs);\n    }\n\n    function readTx1559(string memory path, uint256 index) internal view virtual returns (Tx1559 memory) {\n        string memory deployData = vm.readFile(path);\n        string memory key = string(abi.encodePacked(\".transactions[\", vm.toString(index), \"]\"));\n        bytes memory parsedDeployData = vm.parseJson(deployData, key);\n        RawTx1559 memory rawTx = abi.decode(parsedDeployData, (RawTx1559));\n        return rawToConvertedEIPTx1559(rawTx);\n    }\n\n    // Analogous to readTransactions, but for receipts.\n    function readReceipts(string memory path) internal view virtual returns (Receipt[] memory) {\n        string memory deployData = vm.readFile(path);\n        bytes memory parsedDeployData = vm.parseJson(deployData, \".receipts\");\n        RawReceipt[] memory rawReceipts = abi.decode(parsedDeployData, (RawReceipt[]));\n        return rawToConvertedReceipts(rawReceipts);\n    }\n\n    function readReceipt(string memory path, uint256 index) internal view virtual returns (Receipt memory) {\n        string memory deployData = vm.readFile(path);\n        string memory key = string(abi.encodePacked(\".receipts[\", vm.toString(index), \"]\"));\n        bytes memory parsedDeployData = vm.parseJson(deployData, key);\n        RawReceipt memory rawReceipt = abi.decode(parsedDeployData, (RawReceipt));\n        return rawToConvertedReceipt(rawReceipt);\n    }\n\n    function rawToConvertedReceipts(RawReceipt[] memory rawReceipts) internal pure virtual returns (Receipt[] memory) {\n        Receipt[] memory receipts = new Receipt[](rawReceipts.length);\n        for (uint256 i; i < rawReceipts.length; i++) {\n            receipts[i] = rawToConvertedReceipt(rawReceipts[i]);\n        }\n        return receipts;\n    }\n\n    function rawToConvertedReceipt(RawReceipt memory rawReceipt) internal pure virtual returns (Receipt memory) {\n        Receipt memory receipt;\n        receipt.blockHash = rawReceipt.blockHash;\n        receipt.to = rawReceipt.to;\n        receipt.from = rawReceipt.from;\n        receipt.contractAddress = rawReceipt.contractAddress;\n        receipt.effectiveGasPrice = _bytesToUint(rawReceipt.effectiveGasPrice);\n        receipt.cumulativeGasUsed = _bytesToUint(rawReceipt.cumulativeGasUsed);\n        receipt.gasUsed = _bytesToUint(rawReceipt.gasUsed);\n        receipt.status = _bytesToUint(rawReceipt.status);\n        receipt.transactionIndex = _bytesToUint(rawReceipt.transactionIndex);\n        receipt.blockNumber = _bytesToUint(rawReceipt.blockNumber);\n        receipt.logs = rawToConvertedReceiptLogs(rawReceipt.logs);\n        receipt.logsBloom = rawReceipt.logsBloom;\n        receipt.transactionHash = rawReceipt.transactionHash;\n        return receipt;\n    }\n\n    function rawToConvertedReceiptLogs(RawReceiptLog[] memory rawLogs)\n        internal\n        pure\n        virtual\n        returns (ReceiptLog[] memory)\n    {\n        ReceiptLog[] memory logs = new ReceiptLog[](rawLogs.length);\n        for (uint256 i; i < rawLogs.length; i++) {\n            logs[i].logAddress = rawLogs[i].logAddress;\n            logs[i].blockHash = rawLogs[i].blockHash;\n            logs[i].blockNumber = _bytesToUint(rawLogs[i].blockNumber);\n            logs[i].data = rawLogs[i].data;\n            logs[i].logIndex = _bytesToUint(rawLogs[i].logIndex);\n            logs[i].topics = rawLogs[i].topics;\n            logs[i].transactionIndex = _bytesToUint(rawLogs[i].transactionIndex);\n            logs[i].transactionLogIndex = _bytesToUint(rawLogs[i].transactionLogIndex);\n            logs[i].removed = rawLogs[i].removed;\n        }\n        return logs;\n    }\n\n    // Deploy a contract by fetching the contract bytecode from\n    // the artifacts directory\n    // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`\n    function deployCode(string memory what, bytes memory args) internal virtual returns (address addr) {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,bytes): Deployment failed.\");\n    }\n\n    function deployCode(string memory what) internal virtual returns (address addr) {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string): Deployment failed.\");\n    }\n\n    /// @dev deploy contract with value on construction\n    function deployCode(string memory what, bytes memory args, uint256 val) internal virtual returns (address addr) {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,bytes,uint256): Deployment failed.\");\n    }\n\n    function deployCode(string memory what, uint256 val) internal virtual returns (address addr) {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,uint256): Deployment failed.\");\n    }\n\n    // creates a labeled address and the corresponding private key\n    function makeAddrAndKey(string memory name) internal virtual returns (address addr, uint256 privateKey) {\n        privateKey = uint256(keccak256(abi.encodePacked(name)));\n        addr = vm.addr(privateKey);\n        vm.label(addr, name);\n    }\n\n    // creates a labeled address\n    function makeAddr(string memory name) internal virtual returns (address addr) {\n        (addr,) = makeAddrAndKey(name);\n    }\n\n    // Destroys an account immediately, sending the balance to beneficiary.\n    // Destroying means: balance will be zero, code will be empty, and nonce will be 0\n    // This is similar to selfdestruct but not identical: selfdestruct destroys code and nonce\n    // only after tx ends, this will run immediately.\n    function destroyAccount(address who, address beneficiary) internal virtual {\n        uint256 currBalance = who.balance;\n        vm.etch(who, abi.encode());\n        vm.deal(who, 0);\n        vm.resetNonce(who);\n\n        uint256 beneficiaryBalance = beneficiary.balance;\n        vm.deal(beneficiary, currBalance + beneficiaryBalance);\n    }\n\n    // creates a struct containing both a labeled address and the corresponding private key\n    function makeAccount(string memory name) internal virtual returns (Account memory account) {\n        (account.addr, account.key) = makeAddrAndKey(name);\n    }\n\n    function deriveRememberKey(string memory mnemonic, uint32 index)\n        internal\n        virtual\n        returns (address who, uint256 privateKey)\n    {\n        privateKey = vm.deriveKey(mnemonic, index);\n        who = vm.rememberKey(privateKey);\n    }\n\n    function _bytesToUint(bytes memory b) private pure returns (uint256) {\n        require(b.length <= 32, \"StdCheats _bytesToUint(bytes): Bytes length exceeds 32.\");\n        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));\n    }\n\n    function isFork() internal view virtual returns (bool status) {\n        try vm.activeFork() {\n            status = true;\n        } catch (bytes memory) {}\n    }\n\n    modifier skipWhenForking() {\n        if (!isFork()) {\n            _;\n        }\n    }\n\n    modifier skipWhenNotForking() {\n        if (isFork()) {\n            _;\n        }\n    }\n\n    modifier noGasMetering() {\n        vm.pauseGasMetering();\n        // To prevent turning gas monitoring back on with nested functions that use this modifier,\n        // we check if gasMetering started in the off position. If it did, we don't want to turn\n        // it back on until we exit the top level function that used the modifier\n        //\n        // i.e. funcA() noGasMetering { funcB() }, where funcB has noGasMetering as well.\n        // funcA will have `gasStartedOff` as false, funcB will have it as true,\n        // so we only turn metering back on at the end of the funcA\n        bool gasStartedOff = gasMeteringOff;\n        gasMeteringOff = true;\n\n        _;\n\n        // if gas metering was on when this modifier was called, turn it back on at the end\n        if (!gasStartedOff) {\n            gasMeteringOff = false;\n            vm.resumeGasMetering();\n        }\n    }\n\n    // We use this complex approach of `_viewChainId` and `_pureChainId` to ensure there are no\n    // compiler warnings when accessing chain ID in any solidity version supported by forge-std. We\n    // can't simply access the chain ID in a normal view or pure function because the solc View Pure\n    // Checker changed `chainid` from pure to view in 0.8.0.\n    function _viewChainId() private view returns (uint256 chainId) {\n        // Assembly required since `block.chainid` was introduced in 0.8.0.\n        assembly {\n            chainId := chainid()\n        }\n\n        address(this); // Silence warnings in older Solc versions.\n    }\n\n    function _pureChainId() private pure returns (uint256 chainId) {\n        function() internal view returns (uint256) fnIn = _viewChainId;\n        function() internal pure returns (uint256) pureChainId;\n        assembly {\n            pureChainId := fnIn\n        }\n        chainId = pureChainId();\n    }\n}\n\n// Wrappers around cheatcodes to avoid footguns\nabstract contract StdCheats is StdCheatsSafe {\n    using stdStorage for StdStorage;\n\n    StdStorage private stdstore;\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    // Skip forward or rewind time by the specified number of seconds\n    function skip(uint256 time) internal virtual {\n        vm.warp(block.timestamp + time);\n    }\n\n    function rewind(uint256 time) internal virtual {\n        vm.warp(block.timestamp - time);\n    }\n\n    // Setup a prank from an address that has some ether\n    function hoax(address msgSender) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.prank(msgSender);\n    }\n\n    function hoax(address msgSender, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.prank(msgSender);\n    }\n\n    function hoax(address msgSender, address origin) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.prank(msgSender, origin);\n    }\n\n    function hoax(address msgSender, address origin, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.prank(msgSender, origin);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    function startHoax(address msgSender) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.startPrank(msgSender);\n    }\n\n    function startHoax(address msgSender, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.startPrank(msgSender);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    // tx.origin is set to the origin parameter\n    function startHoax(address msgSender, address origin) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.startPrank(msgSender, origin);\n    }\n\n    function startHoax(address msgSender, address origin, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.startPrank(msgSender, origin);\n    }\n\n    function changePrank(address msgSender) internal virtual {\n        vm.stopPrank();\n        vm.startPrank(msgSender);\n    }\n\n    function changePrank(address msgSender, address txOrigin) internal virtual {\n        vm.stopPrank();\n        vm.startPrank(msgSender, txOrigin);\n    }\n\n    // The same as Vm's `deal`\n    // Use the alternative signature for ERC20 tokens\n    function deal(address to, uint256 give) internal virtual {\n        vm.deal(to, give);\n    }\n\n    // Set the balance of an account for any ERC20 token\n    // Use the alternative signature to update `totalSupply`\n    function deal(address token, address to, uint256 give) internal virtual {\n        deal(token, to, give, false);\n    }\n\n    // Set the balance of an account for any ERC1155 token\n    // Use the alternative signature to update `totalSupply`\n    function dealERC1155(address token, address to, uint256 id, uint256 give) internal virtual {\n        dealERC1155(token, to, id, give, false);\n    }\n\n    function deal(address token, address to, uint256 give, bool adjust) internal virtual {\n        // get current balance\n        (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));\n        uint256 prevBal = abi.decode(balData, (uint256));\n\n        // update balance\n        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(give);\n\n        // update total supply\n        if (adjust) {\n            (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0x18160ddd));\n            uint256 totSup = abi.decode(totSupData, (uint256));\n            if (give < prevBal) {\n                totSup -= (prevBal - give);\n            } else {\n                totSup += (give - prevBal);\n            }\n            stdstore.target(token).sig(0x18160ddd).checked_write(totSup);\n        }\n    }\n\n    function dealERC1155(address token, address to, uint256 id, uint256 give, bool adjust) internal virtual {\n        // get current balance\n        (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x00fdd58e, to, id));\n        uint256 prevBal = abi.decode(balData, (uint256));\n\n        // update balance\n        stdstore.target(token).sig(0x00fdd58e).with_key(to).with_key(id).checked_write(give);\n\n        // update total supply\n        if (adjust) {\n            (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0xbd85b039, id));\n            require(\n                totSupData.length != 0,\n                \"StdCheats deal(address,address,uint,uint,bool): target contract is not ERC1155Supply.\"\n            );\n            uint256 totSup = abi.decode(totSupData, (uint256));\n            if (give < prevBal) {\n                totSup -= (prevBal - give);\n            } else {\n                totSup += (give - prevBal);\n            }\n            stdstore.target(token).sig(0xbd85b039).with_key(id).checked_write(totSup);\n        }\n    }\n\n    function dealERC721(address token, address to, uint256 id) internal virtual {\n        // check if token id is already minted and the actual owner.\n        (bool successMinted, bytes memory ownerData) = token.staticcall(abi.encodeWithSelector(0x6352211e, id));\n        require(successMinted, \"StdCheats deal(address,address,uint,bool): id not minted.\");\n\n        // get owner current balance\n        (, bytes memory fromBalData) =\n            token.staticcall(abi.encodeWithSelector(0x70a08231, abi.decode(ownerData, (address))));\n        uint256 fromPrevBal = abi.decode(fromBalData, (uint256));\n\n        // get new user current balance\n        (, bytes memory toBalData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));\n        uint256 toPrevBal = abi.decode(toBalData, (uint256));\n\n        // update balances\n        stdstore.target(token).sig(0x70a08231).with_key(abi.decode(ownerData, (address))).checked_write(--fromPrevBal);\n        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(++toPrevBal);\n\n        // update owner\n        stdstore.target(token).sig(0x6352211e).with_key(id).checked_write(to);\n    }\n\n    function deployCodeTo(string memory what, address where) internal virtual {\n        deployCodeTo(what, \"\", 0, where);\n    }\n\n    function deployCodeTo(string memory what, bytes memory args, address where) internal virtual {\n        deployCodeTo(what, args, 0, where);\n    }\n\n    function deployCodeTo(string memory what, bytes memory args, uint256 value, address where) internal virtual {\n        bytes memory creationCode = vm.getCode(what);\n        vm.etch(where, abi.encodePacked(creationCode, args));\n        (bool success, bytes memory runtimeBytecode) = where.call{value: value}(\"\");\n        require(success, \"StdCheats deployCodeTo(string,bytes,uint256,address): Failed to create runtime bytecode.\");\n        vm.etch(where, runtimeBytecode);\n    }\n}\n"
        },
        "lib/forge-std/src/StdError.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// Panics work for versions >=0.8.0, but we lowered the pragma to make this compatible with Test\npragma solidity >=0.6.2 <0.9.0;\n\nlibrary stdError {\n    bytes public constant assertionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x01);\n    bytes public constant arithmeticError = abi.encodeWithSignature(\"Panic(uint256)\", 0x11);\n    bytes public constant divisionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x12);\n    bytes public constant enumConversionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x21);\n    bytes public constant encodeStorageError = abi.encodeWithSignature(\"Panic(uint256)\", 0x22);\n    bytes public constant popError = abi.encodeWithSignature(\"Panic(uint256)\", 0x31);\n    bytes public constant indexOOBError = abi.encodeWithSignature(\"Panic(uint256)\", 0x32);\n    bytes public constant memOverflowError = abi.encodeWithSignature(\"Panic(uint256)\", 0x41);\n    bytes public constant zeroVarError = abi.encodeWithSignature(\"Panic(uint256)\", 0x51);\n}\n"
        },
        "lib/forge-std/src/StdInvariant.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nabstract contract StdInvariant {\n    struct FuzzSelector {\n        address addr;\n        bytes4[] selectors;\n    }\n\n    address[] private _excludedContracts;\n    address[] private _excludedSenders;\n    address[] private _targetedContracts;\n    address[] private _targetedSenders;\n\n    string[] private _excludedArtifacts;\n    string[] private _targetedArtifacts;\n\n    FuzzSelector[] private _targetedArtifactSelectors;\n    FuzzSelector[] private _targetedSelectors;\n\n    // Functions for users:\n    // These are intended to be called in tests.\n\n    function excludeContract(address newExcludedContract_) internal {\n        _excludedContracts.push(newExcludedContract_);\n    }\n\n    function excludeSender(address newExcludedSender_) internal {\n        _excludedSenders.push(newExcludedSender_);\n    }\n\n    function excludeArtifact(string memory newExcludedArtifact_) internal {\n        _excludedArtifacts.push(newExcludedArtifact_);\n    }\n\n    function targetArtifact(string memory newTargetedArtifact_) internal {\n        _targetedArtifacts.push(newTargetedArtifact_);\n    }\n\n    function targetArtifactSelector(FuzzSelector memory newTargetedArtifactSelector_) internal {\n        _targetedArtifactSelectors.push(newTargetedArtifactSelector_);\n    }\n\n    function targetContract(address newTargetedContract_) internal {\n        _targetedContracts.push(newTargetedContract_);\n    }\n\n    function targetSelector(FuzzSelector memory newTargetedSelector_) internal {\n        _targetedSelectors.push(newTargetedSelector_);\n    }\n\n    function targetSender(address newTargetedSender_) internal {\n        _targetedSenders.push(newTargetedSender_);\n    }\n\n    // Functions for forge:\n    // These are called by forge to run invariant tests and don't need to be called in tests.\n\n    function excludeArtifacts() public view returns (string[] memory excludedArtifacts_) {\n        excludedArtifacts_ = _excludedArtifacts;\n    }\n\n    function excludeContracts() public view returns (address[] memory excludedContracts_) {\n        excludedContracts_ = _excludedContracts;\n    }\n\n    function excludeSenders() public view returns (address[] memory excludedSenders_) {\n        excludedSenders_ = _excludedSenders;\n    }\n\n    function targetArtifacts() public view returns (string[] memory targetedArtifacts_) {\n        targetedArtifacts_ = _targetedArtifacts;\n    }\n\n    function targetArtifactSelectors() public view returns (FuzzSelector[] memory targetedArtifactSelectors_) {\n        targetedArtifactSelectors_ = _targetedArtifactSelectors;\n    }\n\n    function targetContracts() public view returns (address[] memory targetedContracts_) {\n        targetedContracts_ = _targetedContracts;\n    }\n\n    function targetSelectors() public view returns (FuzzSelector[] memory targetedSelectors_) {\n        targetedSelectors_ = _targetedSelectors;\n    }\n\n    function targetSenders() public view returns (address[] memory targetedSenders_) {\n        targetedSenders_ = _targetedSenders;\n    }\n}\n"
        },
        "lib/forge-std/src/StdJson.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {VmSafe} from \"./Vm.sol\";\n\n// Helpers for parsing and writing JSON files\n// To parse:\n// ```\n// using stdJson for string;\n// string memory json = vm.readFile(\"some_peth\");\n// json.parseUint(\"<json_path>\");\n// ```\n// To write:\n// ```\n// using stdJson for string;\n// string memory json = \"deploymentArtifact\";\n// Contract contract = new Contract();\n// json.serialize(\"contractAddress\", address(contract));\n// json = json.serialize(\"deploymentTimes\", uint(1));\n// // store the stringified JSON to the 'json' variable we have been using as a key\n// // as we won't need it any longer\n// string memory json2 = \"finalArtifact\";\n// string memory final = json2.serialize(\"depArtifact\", json);\n// final.write(\"<some_path>\");\n// ```\n\nlibrary stdJson {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function parseRaw(string memory json, string memory key) internal pure returns (bytes memory) {\n        return vm.parseJson(json, key);\n    }\n\n    function readUint(string memory json, string memory key) internal returns (uint256) {\n        return vm.parseJsonUint(json, key);\n    }\n\n    function readUintArray(string memory json, string memory key) internal returns (uint256[] memory) {\n        return vm.parseJsonUintArray(json, key);\n    }\n\n    function readInt(string memory json, string memory key) internal returns (int256) {\n        return vm.parseJsonInt(json, key);\n    }\n\n    function readIntArray(string memory json, string memory key) internal returns (int256[] memory) {\n        return vm.parseJsonIntArray(json, key);\n    }\n\n    function readBytes32(string memory json, string memory key) internal returns (bytes32) {\n        return vm.parseJsonBytes32(json, key);\n    }\n\n    function readBytes32Array(string memory json, string memory key) internal returns (bytes32[] memory) {\n        return vm.parseJsonBytes32Array(json, key);\n    }\n\n    function readString(string memory json, string memory key) internal returns (string memory) {\n        return vm.parseJsonString(json, key);\n    }\n\n    function readStringArray(string memory json, string memory key) internal returns (string[] memory) {\n        return vm.parseJsonStringArray(json, key);\n    }\n\n    function readAddress(string memory json, string memory key) internal returns (address) {\n        return vm.parseJsonAddress(json, key);\n    }\n\n    function readAddressArray(string memory json, string memory key) internal returns (address[] memory) {\n        return vm.parseJsonAddressArray(json, key);\n    }\n\n    function readBool(string memory json, string memory key) internal returns (bool) {\n        return vm.parseJsonBool(json, key);\n    }\n\n    function readBoolArray(string memory json, string memory key) internal returns (bool[] memory) {\n        return vm.parseJsonBoolArray(json, key);\n    }\n\n    function readBytes(string memory json, string memory key) internal returns (bytes memory) {\n        return vm.parseJsonBytes(json, key);\n    }\n\n    function readBytesArray(string memory json, string memory key) internal returns (bytes[] memory) {\n        return vm.parseJsonBytesArray(json, key);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {\n        return vm.serializeBool(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bool[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBool(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {\n        return vm.serializeUint(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, uint256[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeUint(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {\n        return vm.serializeInt(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, int256[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeInt(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {\n        return vm.serializeAddress(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, address[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeAddress(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {\n        return vm.serializeBytes32(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes32[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBytes32(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {\n        return vm.serializeBytes(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBytes(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, string memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeString(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, string[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeString(jsonKey, key, value);\n    }\n\n    function write(string memory jsonKey, string memory path) internal {\n        vm.writeJson(jsonKey, path);\n    }\n\n    function write(string memory jsonKey, string memory path, string memory valueKey) internal {\n        vm.writeJson(jsonKey, path, valueKey);\n    }\n}\n"
        },
        "lib/forge-std/src/StdMath.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nlibrary stdMath {\n    int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n    function abs(int256 a) internal pure returns (uint256) {\n        // Required or it will fail when `a = type(int256).min`\n        if (a == INT256_MIN) {\n            return 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n        }\n\n        return uint256(a > 0 ? a : -a);\n    }\n\n    function delta(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a - b : b - a;\n    }\n\n    function delta(int256 a, int256 b) internal pure returns (uint256) {\n        // a and b are of the same sign\n        // this works thanks to two's complement, the left-most bit is the sign bit\n        if ((a ^ b) > -1) {\n            return delta(abs(a), abs(b));\n        }\n\n        // a and b are of opposite signs\n        return abs(a) + abs(b);\n    }\n\n    function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n\n        return absDelta * 1e18 / b;\n    }\n\n    function percentDelta(int256 a, int256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n        uint256 absB = abs(b);\n\n        return absDelta * 1e18 / absB;\n    }\n}\n"
        },
        "lib/forge-std/src/StdStorage.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {Vm} from \"./Vm.sol\";\n\nstruct StdStorage {\n    mapping(address => mapping(bytes4 => mapping(bytes32 => uint256))) slots;\n    mapping(address => mapping(bytes4 => mapping(bytes32 => bool))) finds;\n    bytes32[] _keys;\n    bytes4 _sig;\n    uint256 _depth;\n    address _target;\n    bytes32 _set;\n}\n\nlibrary stdStorageSafe {\n    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint256 slot);\n    event WARNING_UninitedSlot(address who, uint256 slot);\n\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function sigs(string memory sigStr) internal pure returns (bytes4) {\n        return bytes4(keccak256(bytes(sigStr)));\n    }\n\n    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against\n    // slot complexity:\n    //  if flat, will be bytes32(uint256(uint));\n    //  if map, will be keccak256(abi.encode(key, uint(slot)));\n    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));\n    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);\n    function find(StdStorage storage self) internal returns (uint256) {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        // calldata to test against\n        if (self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n        }\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        vm.record();\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32 * field_depth);\n        }\n\n        (bytes32[] memory reads,) = vm.accesses(address(who));\n        if (reads.length == 1) {\n            bytes32 curr = vm.load(who, reads[0]);\n            if (curr == bytes32(0)) {\n                emit WARNING_UninitedSlot(who, uint256(reads[0]));\n            }\n            if (fdat != curr) {\n                require(\n                    false,\n                    \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\"\n                );\n            }\n            emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[0]));\n            self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[0]);\n            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n        } else if (reads.length > 1) {\n            for (uint256 i = 0; i < reads.length; i++) {\n                bytes32 prev = vm.load(who, reads[i]);\n                if (prev == bytes32(0)) {\n                    emit WARNING_UninitedSlot(who, uint256(reads[i]));\n                }\n                // store\n                vm.store(who, reads[i], bytes32(hex\"1337\"));\n                bool success;\n                bytes memory rdat;\n                {\n                    (success, rdat) = who.staticcall(cald);\n                    fdat = bytesToBytes32(rdat, 32 * field_depth);\n                }\n\n                if (success && fdat == bytes32(hex\"1337\")) {\n                    // we found which of the slots is the actual one\n                    emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[i]));\n                    self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[i]);\n                    self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n                    vm.store(who, reads[i], prev);\n                    break;\n                }\n                vm.store(who, reads[i], prev);\n            }\n        } else {\n            revert(\"stdStorage find(StdStorage): No storage use detected for target.\");\n        }\n\n        require(\n            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))],\n            \"stdStorage find(StdStorage): Slot(s) not found.\"\n        );\n\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n\n        return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n    }\n\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\n        self._target = _target;\n        return self;\n    }\n\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\n        self._sig = _sig;\n        return self;\n    }\n\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\n        self._sig = sigs(_sig);\n        return self;\n    }\n\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(uint256(uint160(who))));\n        return self;\n    }\n\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(amt));\n        return self;\n    }\n\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\n        self._keys.push(key);\n        return self;\n    }\n\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\n        self._depth = _depth;\n        return self;\n    }\n\n    function read(StdStorage storage self) private returns (bytes memory) {\n        address t = self._target;\n        uint256 s = find(self);\n        return abi.encode(vm.load(t, bytes32(s)));\n    }\n\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\n        return abi.decode(read(self), (bytes32));\n    }\n\n    function read_bool(StdStorage storage self) internal returns (bool) {\n        int256 v = read_int(self);\n        if (v == 0) return false;\n        if (v == 1) return true;\n        revert(\"stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.\");\n    }\n\n    function read_address(StdStorage storage self) internal returns (address) {\n        return abi.decode(read(self), (address));\n    }\n\n    function read_uint(StdStorage storage self) internal returns (uint256) {\n        return abi.decode(read(self), (uint256));\n    }\n\n    function read_int(StdStorage storage self) internal returns (int256) {\n        return abi.decode(read(self), (int256));\n    }\n\n    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {\n        bytes32 out;\n\n        uint256 max = b.length > 32 ? 32 : b.length;\n        for (uint256 i = 0; i < max; i++) {\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\n        }\n        return out;\n    }\n\n    function flatten(bytes32[] memory b) private pure returns (bytes memory) {\n        bytes memory result = new bytes(b.length * 32);\n        for (uint256 i = 0; i < b.length; i++) {\n            bytes32 k = b[i];\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(add(result, add(32, mul(32, i))), k)\n            }\n        }\n\n        return result;\n    }\n}\n\nlibrary stdStorage {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function sigs(string memory sigStr) internal pure returns (bytes4) {\n        return stdStorageSafe.sigs(sigStr);\n    }\n\n    function find(StdStorage storage self) internal returns (uint256) {\n        return stdStorageSafe.find(self);\n    }\n\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\n        return stdStorageSafe.target(self, _target);\n    }\n\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\n        return stdStorageSafe.sig(self, _sig);\n    }\n\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\n        return stdStorageSafe.sig(self, _sig);\n    }\n\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, who);\n    }\n\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, amt);\n    }\n\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, key);\n    }\n\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\n        return stdStorageSafe.depth(self, _depth);\n    }\n\n    function checked_write(StdStorage storage self, address who) internal {\n        checked_write(self, bytes32(uint256(uint160(who))));\n    }\n\n    function checked_write(StdStorage storage self, uint256 amt) internal {\n        checked_write(self, bytes32(amt));\n    }\n\n    function checked_write_int(StdStorage storage self, int256 val) internal {\n        checked_write(self, bytes32(uint256(val)));\n    }\n\n    function checked_write(StdStorage storage self, bool write) internal {\n        bytes32 t;\n        /// @solidity memory-safe-assembly\n        assembly {\n            t := write\n        }\n        checked_write(self, t);\n    }\n\n    function checked_write(StdStorage storage self, bytes32 set) internal {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        if (!self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            find(self);\n        }\n        bytes32 slot = bytes32(self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]);\n\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32 * field_depth);\n        }\n        bytes32 curr = vm.load(who, slot);\n\n        if (fdat != curr) {\n            require(\n                false,\n                \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\"\n            );\n        }\n        vm.store(who, slot, set);\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n    }\n\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\n        return stdStorageSafe.read_bytes32(self);\n    }\n\n    function read_bool(StdStorage storage self) internal returns (bool) {\n        return stdStorageSafe.read_bool(self);\n    }\n\n    function read_address(StdStorage storage self) internal returns (address) {\n        return stdStorageSafe.read_address(self);\n    }\n\n    function read_uint(StdStorage storage self) internal returns (uint256) {\n        return stdStorageSafe.read_uint(self);\n    }\n\n    function read_int(StdStorage storage self) internal returns (int256) {\n        return stdStorageSafe.read_int(self);\n    }\n\n    // Private function so needs to be copied over\n    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {\n        bytes32 out;\n\n        uint256 max = b.length > 32 ? 32 : b.length;\n        for (uint256 i = 0; i < max; i++) {\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\n        }\n        return out;\n    }\n\n    // Private function so needs to be copied over\n    function flatten(bytes32[] memory b) private pure returns (bytes memory) {\n        bytes memory result = new bytes(b.length * 32);\n        for (uint256 i = 0; i < b.length; i++) {\n            bytes32 k = b[i];\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(add(result, add(32, mul(32, i))), k)\n            }\n        }\n\n        return result;\n    }\n}\n"
        },
        "lib/forge-std/src/StdStyle.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nimport {VmSafe} from \"./Vm.sol\";\n\nlibrary StdStyle {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    string constant RED = \"\\u001b[91m\";\n    string constant GREEN = \"\\u001b[92m\";\n    string constant YELLOW = \"\\u001b[93m\";\n    string constant BLUE = \"\\u001b[94m\";\n    string constant MAGENTA = \"\\u001b[95m\";\n    string constant CYAN = \"\\u001b[96m\";\n    string constant BOLD = \"\\u001b[1m\";\n    string constant DIM = \"\\u001b[2m\";\n    string constant ITALIC = \"\\u001b[3m\";\n    string constant UNDERLINE = \"\\u001b[4m\";\n    string constant INVERSE = \"\\u001b[7m\";\n    string constant RESET = \"\\u001b[0m\";\n\n    function styleConcat(string memory style, string memory self) private pure returns (string memory) {\n        return string(abi.encodePacked(style, self, RESET));\n    }\n\n    function red(string memory self) internal pure returns (string memory) {\n        return styleConcat(RED, self);\n    }\n\n    function red(uint256 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(int256 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(address self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(bool self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function redBytes(bytes memory self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function redBytes32(bytes32 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function green(string memory self) internal pure returns (string memory) {\n        return styleConcat(GREEN, self);\n    }\n\n    function green(uint256 self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function green(int256 self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function green(address self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function green(bool self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function greenBytes(bytes memory self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function greenBytes32(bytes32 self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function yellow(string memory self) internal pure returns (string memory) {\n        return styleConcat(YELLOW, self);\n    }\n\n    function yellow(uint256 self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellow(int256 self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellow(address self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellow(bool self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellowBytes(bytes memory self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellowBytes32(bytes32 self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function blue(string memory self) internal pure returns (string memory) {\n        return styleConcat(BLUE, self);\n    }\n\n    function blue(uint256 self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blue(int256 self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blue(address self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blue(bool self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blueBytes(bytes memory self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blueBytes32(bytes32 self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function magenta(string memory self) internal pure returns (string memory) {\n        return styleConcat(MAGENTA, self);\n    }\n\n    function magenta(uint256 self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magenta(int256 self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magenta(address self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magenta(bool self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magentaBytes(bytes memory self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magentaBytes32(bytes32 self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function cyan(string memory self) internal pure returns (string memory) {\n        return styleConcat(CYAN, self);\n    }\n\n    function cyan(uint256 self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyan(int256 self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyan(address self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyan(bool self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyanBytes(bytes memory self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyanBytes32(bytes32 self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function bold(string memory self) internal pure returns (string memory) {\n        return styleConcat(BOLD, self);\n    }\n\n    function bold(uint256 self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function bold(int256 self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function bold(address self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function bold(bool self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function boldBytes(bytes memory self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function boldBytes32(bytes32 self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function dim(string memory self) internal pure returns (string memory) {\n        return styleConcat(DIM, self);\n    }\n\n    function dim(uint256 self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dim(int256 self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dim(address self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dim(bool self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dimBytes(bytes memory self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dimBytes32(bytes32 self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function italic(string memory self) internal pure returns (string memory) {\n        return styleConcat(ITALIC, self);\n    }\n\n    function italic(uint256 self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italic(int256 self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italic(address self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italic(bool self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italicBytes(bytes memory self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italicBytes32(bytes32 self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function underline(string memory self) internal pure returns (string memory) {\n        return styleConcat(UNDERLINE, self);\n    }\n\n    function underline(uint256 self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underline(int256 self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underline(address self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underline(bool self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underlineBytes(bytes memory self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underlineBytes32(bytes32 self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function inverse(string memory self) internal pure returns (string memory) {\n        return styleConcat(INVERSE, self);\n    }\n\n    function inverse(uint256 self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverse(int256 self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverse(address self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverse(bool self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverseBytes(bytes memory self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverseBytes32(bytes32 self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n}\n"
        },
        "lib/forge-std/src/StdUtils.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {IMulticall3} from \"./interfaces/IMulticall3.sol\";\nimport {VmSafe} from \"./Vm.sol\";\n\nabstract contract StdUtils {\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTANTS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    IMulticall3 private constant multicall = IMulticall3(0xcA11bde05977b3631167028862bE2a173976CA11);\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n    address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;\n    uint256 private constant INT256_MIN_ABS =\n        57896044618658097711785492504343953926634992332820282019728792003956564819968;\n    uint256 private constant SECP256K1_ORDER =\n        115792089237316195423570985008687907852837564279074904382605163141518161494337;\n    uint256 private constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    // Used by default when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.\n    address private constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                 INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function _bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {\n        require(min <= max, \"StdUtils bound(uint256,uint256,uint256): Max is less than min.\");\n        // If x is between min and max, return x directly. This is to ensure that dictionary values\n        // do not get shifted if the min is nonzero. More info: https://github.com/foundry-rs/forge-std/issues/188\n        if (x >= min && x <= max) return x;\n\n        uint256 size = max - min + 1;\n\n        // If the value is 0, 1, 2, 3, wrap that to min, min+1, min+2, min+3. Similarly for the UINT256_MAX side.\n        // This helps ensure coverage of the min/max values.\n        if (x <= 3 && size > x) return min + x;\n        if (x >= UINT256_MAX - 3 && size > UINT256_MAX - x) return max - (UINT256_MAX - x);\n\n        // Otherwise, wrap x into the range [min, max], i.e. the range is inclusive.\n        if (x > max) {\n            uint256 diff = x - max;\n            uint256 rem = diff % size;\n            if (rem == 0) return max;\n            result = min + rem - 1;\n        } else if (x < min) {\n            uint256 diff = min - x;\n            uint256 rem = diff % size;\n            if (rem == 0) return min;\n            result = max - rem + 1;\n        }\n    }\n\n    function bound(uint256 x, uint256 min, uint256 max) internal view virtual returns (uint256 result) {\n        result = _bound(x, min, max);\n        console2_log(\"Bound Result\", result);\n    }\n\n    function _bound(int256 x, int256 min, int256 max) internal pure virtual returns (int256 result) {\n        require(min <= max, \"StdUtils bound(int256,int256,int256): Max is less than min.\");\n\n        // Shifting all int256 values to uint256 to use _bound function. The range of two types are:\n        // int256 : -(2**255) ~ (2**255 - 1)\n        // uint256:     0     ~ (2**256 - 1)\n        // So, add 2**255, INT256_MIN_ABS to the integer values.\n        //\n        // If the given integer value is -2**255, we cannot use `-uint256(-x)` because of the overflow.\n        // So, use `~uint256(x) + 1` instead.\n        uint256 _x = x < 0 ? (INT256_MIN_ABS - ~uint256(x) - 1) : (uint256(x) + INT256_MIN_ABS);\n        uint256 _min = min < 0 ? (INT256_MIN_ABS - ~uint256(min) - 1) : (uint256(min) + INT256_MIN_ABS);\n        uint256 _max = max < 0 ? (INT256_MIN_ABS - ~uint256(max) - 1) : (uint256(max) + INT256_MIN_ABS);\n\n        uint256 y = _bound(_x, _min, _max);\n\n        // To move it back to int256 value, subtract INT256_MIN_ABS at here.\n        result = y < INT256_MIN_ABS ? int256(~(INT256_MIN_ABS - y) + 1) : int256(y - INT256_MIN_ABS);\n    }\n\n    function bound(int256 x, int256 min, int256 max) internal view virtual returns (int256 result) {\n        result = _bound(x, min, max);\n        console2_log(\"Bound result\", vm.toString(result));\n    }\n\n    function boundPrivateKey(uint256 privateKey) internal pure virtual returns (uint256 result) {\n        result = _bound(privateKey, 1, SECP256K1_ORDER - 1);\n    }\n\n    function bytesToUint(bytes memory b) internal pure virtual returns (uint256) {\n        require(b.length <= 32, \"StdUtils bytesToUint(bytes): Bytes length exceeds 32.\");\n        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));\n    }\n\n    /// @dev Compute the address a contract will be deployed at for a given deployer address and nonce\n    /// @notice adapted from Solmate implementation (https://github.com/Rari-Capital/solmate/blob/main/src/utils/LibRLP.sol)\n    function computeCreateAddress(address deployer, uint256 nonce) internal pure virtual returns (address) {\n        // forgefmt: disable-start\n        // The integer zero is treated as an empty byte string, and as a result it only has a length prefix, 0x80, computed via 0x80 + 0.\n        // A one byte integer uses its own value as its length prefix, there is no additional \"0x80 + length\" prefix that comes before it.\n        if (nonce == 0x00)      return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, bytes1(0x80))));\n        if (nonce <= 0x7f)      return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, uint8(nonce))));\n\n        // Nonces greater than 1 byte all follow a consistent encoding scheme, where each value is preceded by a prefix of 0x80 + length.\n        if (nonce <= 2**8 - 1)  return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployer, bytes1(0x81), uint8(nonce))));\n        if (nonce <= 2**16 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployer, bytes1(0x82), uint16(nonce))));\n        if (nonce <= 2**24 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployer, bytes1(0x83), uint24(nonce))));\n        // forgefmt: disable-end\n\n        // More details about RLP encoding can be found here: https://eth.wiki/fundamentals/rlp\n        // 0xda = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x84 ++ nonce)\n        // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)\n        // 0x84 = 0x80 + 0x04 (0x04 = the bytes length of the nonce, 4 bytes, in hex)\n        // We assume nobody can have a nonce large enough to require more than 32 bytes.\n        return addressFromLast20Bytes(\n            keccak256(abi.encodePacked(bytes1(0xda), bytes1(0x94), deployer, bytes1(0x84), uint32(nonce)))\n        );\n    }\n\n    function computeCreate2Address(bytes32 salt, bytes32 initcodeHash, address deployer)\n        internal\n        pure\n        virtual\n        returns (address)\n    {\n        return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, initcodeHash)));\n    }\n\n    /// @dev returns the address of a contract created with CREATE2 using the default CREATE2 deployer\n    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) internal pure returns (address) {\n        return computeCreate2Address(salt, initCodeHash, CREATE2_FACTORY);\n    }\n\n    /// @dev returns the hash of the init code (creation code + no args) used in CREATE2 with no constructor arguments\n    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode\n    function hashInitCode(bytes memory creationCode) internal pure returns (bytes32) {\n        return hashInitCode(creationCode, \"\");\n    }\n\n    /// @dev returns the hash of the init code (creation code + ABI-encoded args) used in CREATE2\n    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode\n    /// @param args the ABI-encoded arguments to the constructor of C\n    function hashInitCode(bytes memory creationCode, bytes memory args) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(creationCode, args));\n    }\n\n    // Performs a single call with Multicall3 to query the ERC-20 token balances of the given addresses.\n    function getTokenBalances(address token, address[] memory addresses)\n        internal\n        virtual\n        returns (uint256[] memory balances)\n    {\n        uint256 tokenCodeSize;\n        assembly {\n            tokenCodeSize := extcodesize(token)\n        }\n        require(tokenCodeSize > 0, \"StdUtils getTokenBalances(address,address[]): Token address is not a contract.\");\n\n        // ABI encode the aggregate call to Multicall3.\n        uint256 length = addresses.length;\n        IMulticall3.Call[] memory calls = new IMulticall3.Call[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            // 0x70a08231 = bytes4(\"balanceOf(address)\"))\n            calls[i] = IMulticall3.Call({target: token, callData: abi.encodeWithSelector(0x70a08231, (addresses[i]))});\n        }\n\n        // Make the aggregate call.\n        (, bytes[] memory returnData) = multicall.aggregate(calls);\n\n        // ABI decode the return data and return the balances.\n        balances = new uint256[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            balances[i] = abi.decode(returnData[i], (uint256));\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                 PRIVATE FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function addressFromLast20Bytes(bytes32 bytesValue) private pure returns (address) {\n        return address(uint160(uint256(bytesValue)));\n    }\n\n    // Used to prevent the compilation of console, which shortens the compilation time when console is not used elsewhere.\n\n    function console2_log(string memory p0, uint256 p1) private view {\n        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n        status;\n    }\n\n    function console2_log(string memory p0, string memory p1) private view {\n        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n        status;\n    }\n}\n"
        },
        "lib/forge-std/src/Test.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\n//  ABOUT\n// Forge Std's default Test.\n\n//  MODULES\nimport {console} from \"./console.sol\";\nimport {console2} from \"./console2.sol\";\nimport {safeconsole} from \"./safeconsole.sol\";\nimport {StdAssertions} from \"./StdAssertions.sol\";\nimport {StdChains} from \"./StdChains.sol\";\nimport {StdCheats} from \"./StdCheats.sol\";\nimport {stdError} from \"./StdError.sol\";\nimport {StdInvariant} from \"./StdInvariant.sol\";\nimport {stdJson} from \"./StdJson.sol\";\nimport {stdMath} from \"./StdMath.sol\";\nimport {StdStorage, stdStorage} from \"./StdStorage.sol\";\nimport {StdStyle} from \"./StdStyle.sol\";\nimport {StdUtils} from \"./StdUtils.sol\";\nimport {Vm} from \"./Vm.sol\";\n\n//  BOILERPLATE\nimport {TestBase} from \"./Base.sol\";\nimport {DSTest} from \"ds-test/test.sol\";\n\n//  TEST\n// Note: DSTest and any contracts that inherit it must be inherited first, https://github.com/foundry-rs/forge-std/pull/241\nabstract contract Test is DSTest, StdAssertions, StdChains, StdCheats, StdInvariant, StdUtils, TestBase {\n// Note: IS_TEST() must return true.\n// Note: Must have failure system, https://github.com/dapphub/ds-test/blob/cd98eff28324bfac652e63a239a60632a761790b/src/test.sol#L39-L76.\n}\n"
        },
        "lib/forge-std/src/Vm.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\n// Cheatcodes are marked as view/pure/none using the following rules:\n// 0. A call's observable behaviour includes its return value, logs, reverts and state writes,\n// 1. If you can influence a later call's observable behaviour, you're neither `view` nor `pure (you are modifying some state be it the EVM, interpreter, filesystem, etc),\n// 2. Otherwise if you can be influenced by an earlier call, or if reading some state, you're `view`,\n// 3. Otherwise you're `pure`.\n\ninterface VmSafe {\n    enum CallerMode {\n        None,\n        Broadcast,\n        RecurrentBroadcast,\n        Prank,\n        RecurrentPrank\n    }\n\n    struct Log {\n        bytes32[] topics;\n        bytes data;\n        address emitter;\n    }\n\n    struct Rpc {\n        string key;\n        string url;\n    }\n\n    struct DirEntry {\n        string errorMessage;\n        string path;\n        uint64 depth;\n        bool isDir;\n        bool isSymlink;\n    }\n\n    struct FsMetadata {\n        bool isDir;\n        bool isSymlink;\n        uint256 length;\n        bool readOnly;\n        uint256 modified;\n        uint256 accessed;\n        uint256 created;\n    }\n\n    // Loads a storage slot from an address\n    function load(address target, bytes32 slot) external view returns (bytes32 data);\n    // Signs data\n    function sign(uint256 privateKey, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);\n    // Gets the address for a given private key\n    function addr(uint256 privateKey) external pure returns (address keyAddr);\n    // Gets the nonce of an account\n    function getNonce(address account) external view returns (uint64 nonce);\n    // Performs a foreign function call via the terminal\n    function ffi(string[] calldata commandInput) external returns (bytes memory result);\n    // Sets environment variables\n    function setEnv(string calldata name, string calldata value) external;\n    // Reads environment variables, (name) => (value)\n    function envBool(string calldata name) external view returns (bool value);\n    function envUint(string calldata name) external view returns (uint256 value);\n    function envInt(string calldata name) external view returns (int256 value);\n    function envAddress(string calldata name) external view returns (address value);\n    function envBytes32(string calldata name) external view returns (bytes32 value);\n    function envString(string calldata name) external view returns (string memory value);\n    function envBytes(string calldata name) external view returns (bytes memory value);\n    // Reads environment variables as arrays\n    function envBool(string calldata name, string calldata delim) external view returns (bool[] memory value);\n    function envUint(string calldata name, string calldata delim) external view returns (uint256[] memory value);\n    function envInt(string calldata name, string calldata delim) external view returns (int256[] memory value);\n    function envAddress(string calldata name, string calldata delim) external view returns (address[] memory value);\n    function envBytes32(string calldata name, string calldata delim) external view returns (bytes32[] memory value);\n    function envString(string calldata name, string calldata delim) external view returns (string[] memory value);\n    function envBytes(string calldata name, string calldata delim) external view returns (bytes[] memory value);\n    // Read environment variables with default value\n    function envOr(string calldata name, bool defaultValue) external returns (bool value);\n    function envOr(string calldata name, uint256 defaultValue) external returns (uint256 value);\n    function envOr(string calldata name, int256 defaultValue) external returns (int256 value);\n    function envOr(string calldata name, address defaultValue) external returns (address value);\n    function envOr(string calldata name, bytes32 defaultValue) external returns (bytes32 value);\n    function envOr(string calldata name, string calldata defaultValue) external returns (string memory value);\n    function envOr(string calldata name, bytes calldata defaultValue) external returns (bytes memory value);\n    // Read environment variables as arrays with default value\n    function envOr(string calldata name, string calldata delim, bool[] calldata defaultValue)\n        external\n        returns (bool[] memory value);\n    function envOr(string calldata name, string calldata delim, uint256[] calldata defaultValue)\n        external\n        returns (uint256[] memory value);\n    function envOr(string calldata name, string calldata delim, int256[] calldata defaultValue)\n        external\n        returns (int256[] memory value);\n    function envOr(string calldata name, string calldata delim, address[] calldata defaultValue)\n        external\n        returns (address[] memory value);\n    function envOr(string calldata name, string calldata delim, bytes32[] calldata defaultValue)\n        external\n        returns (bytes32[] memory value);\n    function envOr(string calldata name, string calldata delim, string[] calldata defaultValue)\n        external\n        returns (string[] memory value);\n    function envOr(string calldata name, string calldata delim, bytes[] calldata defaultValue)\n        external\n        returns (bytes[] memory value);\n    // Records all storage reads and writes\n    function record() external;\n    // Gets all accessed reads and write slot from a recording session, for a given address\n    function accesses(address target) external returns (bytes32[] memory readSlots, bytes32[] memory writeSlots);\n    // Gets the _creation_ bytecode from an artifact file. Takes in the relative path to the json file\n    function getCode(string calldata artifactPath) external view returns (bytes memory creationBytecode);\n    // Gets the _deployed_ bytecode from an artifact file. Takes in the relative path to the json file\n    function getDeployedCode(string calldata artifactPath) external view returns (bytes memory runtimeBytecode);\n    // Labels an address in call traces\n    function label(address account, string calldata newLabel) external;\n    // Gets the label for the specified address\n    function getLabel(address account) external returns (string memory currentLabel);\n    // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n    function broadcast() external;\n    // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n    function broadcast(address signer) external;\n    // Has the next call (at this call depth only) create a transaction with the private key provided as the sender that can later be signed and sent onchain\n    function broadcast(uint256 privateKey) external;\n    // Using the address that calls the test contract, has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n    function startBroadcast() external;\n    // Has all subsequent calls (at this call depth only) create transactions with the address provided that can later be signed and sent onchain\n    function startBroadcast(address signer) external;\n    // Has all subsequent calls (at this call depth only) create transactions with the private key provided that can later be signed and sent onchain\n    function startBroadcast(uint256 privateKey) external;\n    // Stops collecting onchain transactions\n    function stopBroadcast() external;\n\n    // Get the path of the current project root.\n    function projectRoot() external view returns (string memory path);\n    // Reads the entire content of file to string. `path` is relative to the project root.\n    function readFile(string calldata path) external view returns (string memory data);\n    // Reads the entire content of file as binary. `path` is relative to the project root.\n    function readFileBinary(string calldata path) external view returns (bytes memory data);\n    // Reads next line of file to string.\n    function readLine(string calldata path) external view returns (string memory line);\n    // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    // `path` is relative to the project root.\n    function writeFile(string calldata path, string calldata data) external;\n    // Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    // `path` is relative to the project root.\n    function writeFileBinary(string calldata path, bytes calldata data) external;\n    // Writes line to file, creating a file if it does not exist.\n    // `path` is relative to the project root.\n    function writeLine(string calldata path, string calldata data) external;\n    // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n    // `path` is relative to the project root.\n    function closeFile(string calldata path) external;\n    // Removes a file from the filesystem.\n    // This cheatcode will revert in the following situations, but is not limited to just these cases:\n    // - `path` points to a directory.\n    // - The file doesn't exist.\n    // - The user lacks permissions to remove the file.\n    // `path` is relative to the project root.\n    function removeFile(string calldata path) external;\n    // Creates a new, empty directory at the provided path.\n    // This cheatcode will revert in the following situations, but is not limited to just these cases:\n    // - User lacks permissions to modify `path`.\n    // - A parent of the given path doesn't exist and `recursive` is false.\n    // - `path` already exists and `recursive` is false.\n    // `path` is relative to the project root.\n    function createDir(string calldata path, bool recursive) external;\n    // Removes a directory at the provided path.\n    // This cheatcode will revert in the following situations, but is not limited to just these cases:\n    // - `path` doesn't exist.\n    // - `path` isn't a directory.\n    // - User lacks permissions to modify `path`.\n    // - The directory is not empty and `recursive` is false.\n    // `path` is relative to the project root.\n    function removeDir(string calldata path, bool recursive) external;\n    // Reads the directory at the given path recursively, up to `max_depth`.\n    // `max_depth` defaults to 1, meaning only the direct children of the given directory will be returned.\n    // Follows symbolic links if `follow_links` is true.\n    function readDir(string calldata path) external view returns (DirEntry[] memory entries);\n    function readDir(string calldata path, uint64 maxDepth) external view returns (DirEntry[] memory entries);\n    function readDir(string calldata path, uint64 maxDepth, bool followLinks)\n        external\n        view\n        returns (DirEntry[] memory entries);\n    // Reads a symbolic link, returning the path that the link points to.\n    // This cheatcode will revert in the following situations, but is not limited to just these cases:\n    // - `path` is not a symbolic link.\n    // - `path` does not exist.\n    function readLink(string calldata linkPath) external view returns (string memory targetPath);\n    // Given a path, query the file system to get information about a file, directory, etc.\n    function fsMetadata(string calldata path) external view returns (FsMetadata memory metadata);\n\n    // Convert values to a string\n    function toString(address value) external pure returns (string memory stringifiedValue);\n    function toString(bytes calldata value) external pure returns (string memory stringifiedValue);\n    function toString(bytes32 value) external pure returns (string memory stringifiedValue);\n    function toString(bool value) external pure returns (string memory stringifiedValue);\n    function toString(uint256 value) external pure returns (string memory stringifiedValue);\n    function toString(int256 value) external pure returns (string memory stringifiedValue);\n    // Convert values from a string\n    function parseBytes(string calldata stringifiedValue) external pure returns (bytes memory parsedValue);\n    function parseAddress(string calldata stringifiedValue) external pure returns (address parsedValue);\n    function parseUint(string calldata stringifiedValue) external pure returns (uint256 parsedValue);\n    function parseInt(string calldata stringifiedValue) external pure returns (int256 parsedValue);\n    function parseBytes32(string calldata stringifiedValue) external pure returns (bytes32 parsedValue);\n    function parseBool(string calldata stringifiedValue) external pure returns (bool parsedValue);\n    // Record all the transaction logs\n    function recordLogs() external;\n    // Gets all the recorded logs\n    function getRecordedLogs() external returns (Log[] memory logs);\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\n    function deriveKey(string calldata mnemonic, uint32 index) external pure returns (uint256 privateKey);\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at {derivationPath}{index}\n    function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index)\n        external\n        pure\n        returns (uint256 privateKey);\n    // Adds a private key to the local forge wallet and returns the address\n    function rememberKey(uint256 privateKey) external returns (address keyAddr);\n    //\n    // parseJson\n    //\n    // ----\n    // In case the returned value is a JSON object, it's encoded as a ABI-encoded tuple. As JSON objects\n    // don't have the notion of ordered, but tuples do, they JSON object is encoded with it's fields ordered in\n    // ALPHABETICAL order. That means that in order to successfully decode the tuple, we need to define a tuple that\n    // encodes the fields in the same order, which is alphabetical. In the case of Solidity structs, they are encoded\n    // as tuples, with the attributes in the order in which they are defined.\n    // For example: json = { 'a': 1, 'b': 0xa4tb......3xs}\n    // a: uint256\n    // b: address\n    // To decode that json, we need to define a struct or a tuple as follows:\n    // struct json = { uint256 a; address b; }\n    // If we defined a json struct with the opposite order, meaning placing the address b first, it would try to\n    // decode the tuple in that order, and thus fail.\n    // ----\n    // Given a string of JSON, return it as ABI-encoded\n    function parseJson(string calldata json, string calldata key) external pure returns (bytes memory abiEncodedData);\n    function parseJson(string calldata json) external pure returns (bytes memory abiEncodedData);\n\n    // The following parseJson cheatcodes will do type coercion, for the type that they indicate.\n    // For example, parseJsonUint will coerce all values to a uint256. That includes stringified numbers '12'\n    // and hex numbers '0xEF'.\n    // Type coercion works ONLY for discrete values or arrays. That means that the key must return a value or array, not\n    // a JSON object.\n    function parseJsonUint(string calldata, string calldata) external returns (uint256);\n    function parseJsonUintArray(string calldata, string calldata) external returns (uint256[] memory);\n    function parseJsonInt(string calldata, string calldata) external returns (int256);\n    function parseJsonIntArray(string calldata, string calldata) external returns (int256[] memory);\n    function parseJsonBool(string calldata, string calldata) external returns (bool);\n    function parseJsonBoolArray(string calldata, string calldata) external returns (bool[] memory);\n    function parseJsonAddress(string calldata, string calldata) external returns (address);\n    function parseJsonAddressArray(string calldata, string calldata) external returns (address[] memory);\n    function parseJsonString(string calldata, string calldata) external returns (string memory);\n    function parseJsonStringArray(string calldata, string calldata) external returns (string[] memory);\n    function parseJsonBytes(string calldata, string calldata) external returns (bytes memory);\n    function parseJsonBytesArray(string calldata, string calldata) external returns (bytes[] memory);\n    function parseJsonBytes32(string calldata, string calldata) external returns (bytes32);\n    function parseJsonBytes32Array(string calldata, string calldata) external returns (bytes32[] memory);\n\n    // Serialize a key and value to a JSON object stored in-memory that can be later written to a file\n    // It returns the stringified version of the specific JSON file up to that moment.\n    function serializeBool(string calldata objectKey, string calldata valueKey, bool value)\n        external\n        returns (string memory json);\n    function serializeUint(string calldata objectKey, string calldata valueKey, uint256 value)\n        external\n        returns (string memory json);\n    function serializeInt(string calldata objectKey, string calldata valueKey, int256 value)\n        external\n        returns (string memory json);\n    function serializeAddress(string calldata objectKey, string calldata valueKey, address value)\n        external\n        returns (string memory json);\n    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32 value)\n        external\n        returns (string memory json);\n    function serializeString(string calldata objectKey, string calldata valueKey, string calldata value)\n        external\n        returns (string memory json);\n    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes calldata value)\n        external\n        returns (string memory json);\n\n    function serializeBool(string calldata objectKey, string calldata valueKey, bool[] calldata values)\n        external\n        returns (string memory json);\n    function serializeUint(string calldata objectKey, string calldata valueKey, uint256[] calldata values)\n        external\n        returns (string memory json);\n    function serializeInt(string calldata objectKey, string calldata valueKey, int256[] calldata values)\n        external\n        returns (string memory json);\n    function serializeAddress(string calldata objectKey, string calldata valueKey, address[] calldata values)\n        external\n        returns (string memory json);\n    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32[] calldata values)\n        external\n        returns (string memory json);\n    function serializeString(string calldata objectKey, string calldata valueKey, string[] calldata values)\n        external\n        returns (string memory json);\n    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes[] calldata values)\n        external\n        returns (string memory json);\n\n    //\n    // writeJson\n    //\n    // ----\n    // Write a serialized JSON object to a file. If the file exists, it will be overwritten.\n    // Let's assume we want to write the following JSON to a file:\n    //\n    // { \"boolean\": true, \"number\": 342, \"object\": { \"title\": \"finally json serialization\" } }\n    //\n    // ```\n    //  string memory json1 = \"some key\";\n    //  vm.serializeBool(json1, \"boolean\", true);\n    //  vm.serializeBool(json1, \"number\", uint256(342));\n    //  json2 = \"some other key\";\n    //  string memory output = vm.serializeString(json2, \"title\", \"finally json serialization\");\n    //  string memory finalJson = vm.serialize(json1, \"object\", output);\n    //  vm.writeJson(finalJson, \"./output/example.json\");\n    // ```\n    // The critical insight is that every invocation of serialization will return the stringified version of the JSON\n    // up to that point. That means we can construct arbitrary JSON objects and then use the return stringified version\n    // to serialize them as values to another JSON object.\n    //\n    // json1 and json2 are simply keys used by the backend to keep track of the objects. So vm.serializeJson(json1,..)\n    // will find the object in-memory that is keyed by \"some key\".\n    function writeJson(string calldata json, string calldata path) external;\n    // Write a serialized JSON object to an **existing** JSON file, replacing a value with key = <value_key>\n    // This is useful to replace a specific value of a JSON file, without having to parse the entire thing\n    function writeJson(string calldata json, string calldata path, string calldata valueKey) external;\n    // Returns the RPC url for the given alias\n    function rpcUrl(string calldata rpcAlias) external view returns (string memory json);\n    // Returns all rpc urls and their aliases `[alias, url][]`\n    function rpcUrls() external view returns (string[2][] memory urls);\n    // Returns all rpc urls and their aliases as structs.\n    function rpcUrlStructs() external view returns (Rpc[] memory urls);\n    // If the condition is false, discard this run's fuzz inputs and generate new ones.\n    function assume(bool condition) external pure;\n    // Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.\n    function pauseGasMetering() external;\n    // Resumes gas metering (i.e. gas usage is counted again). Noop if already on.\n    function resumeGasMetering() external;\n    // Writes a breakpoint to jump to in the debugger\n    function breakpoint(string calldata char) external;\n    // Writes a conditional breakpoint to jump to in the debugger\n    function breakpoint(string calldata char, bool value) external;\n}\n\ninterface Vm is VmSafe {\n    // Sets block.timestamp\n    function warp(uint256 newTimestamp) external;\n    // Sets block.height\n    function roll(uint256 newHeight) external;\n    // Sets block.basefee\n    function fee(uint256 newBasefee) external;\n    // Sets block.difficulty\n    // Not available on EVM versions from Paris onwards. Use `prevrandao` instead.\n    // If used on unsupported EVM versions it will revert.\n    function difficulty(uint256 newDifficulty) external;\n    // Sets block.prevrandao\n    // Not available on EVM versions before Paris. Use `difficulty` instead.\n    // If used on unsupported EVM versions it will revert.\n    function prevrandao(bytes32 newPrevrandao) external;\n    // Sets block.chainid\n    function chainId(uint256 newChainId) external;\n    // Sets tx.gasprice\n    function txGasPrice(uint256 newGasPrice) external;\n    // Stores a value to an address' storage slot.\n    function store(address target, bytes32 slot, bytes32 value) external;\n    // Sets the nonce of an account; must be higher than the current nonce of the account\n    function setNonce(address account, uint64 newNonce) external;\n    // Sets the nonce of an account to an arbitrary value\n    function setNonceUnsafe(address account, uint64 newNonce) external;\n    // Resets the nonce of an account to 0 for EOAs and 1 for contract accounts\n    function resetNonce(address account) external;\n    // Sets the *next* call's msg.sender to be the input address\n    function prank(address msgSender) external;\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n    function startPrank(address msgSender) external;\n    // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n    function prank(address msgSender, address txOrigin) external;\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n    function startPrank(address msgSender, address txOrigin) external;\n    // Resets subsequent calls' msg.sender to be `address(this)`\n    function stopPrank() external;\n    // Reads the current `msg.sender` and `tx.origin` from state and reports if there is any active caller modification\n    function readCallers() external returns (CallerMode callerMode, address msgSender, address txOrigin);\n    // Sets an address' balance\n    function deal(address account, uint256 newBalance) external;\n    // Sets an address' code\n    function etch(address target, bytes calldata newRuntimeBytecode) external;\n    // Marks a test as skipped. Must be called at the top of the test.\n    function skip(bool skipTest) external;\n    // Expects an error on next call\n    function expectRevert(bytes calldata revertData) external;\n    function expectRevert(bytes4 revertData) external;\n    function expectRevert() external;\n\n    // Prepare an expected log with all four checks enabled.\n    // Call this function, then emit an event, then call a function. Internally after the call, we check if\n    // logs were emitted in the expected order with the expected topics and data.\n    // Second form also checks supplied address against emitting contract.\n    function expectEmit() external;\n    function expectEmit(address emitter) external;\n\n    // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n    // Call this function, then emit an event, then call a function. Internally after the call, we check if\n    // logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\n    // Second form also checks supplied address against emitting contract.\n    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData) external;\n    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, address emitter)\n        external;\n\n    // Mocks a call to an address, returning specified data.\n    // Calldata can either be strict or a partial match, e.g. if you only\n    // pass a Solidity selector to the expected calldata, then the entire Solidity\n    // function will be mocked.\n    function mockCall(address callee, bytes calldata data, bytes calldata returnData) external;\n    // Mocks a call to an address with a specific msg.value, returning specified data.\n    // Calldata match takes precedence over msg.value in case of ambiguity.\n    function mockCall(address callee, uint256 msgValue, bytes calldata data, bytes calldata returnData) external;\n    // Reverts a call to an address with specified revert data.\n    function mockCallRevert(address callee, bytes calldata data, bytes calldata revertData) external;\n    // Reverts a call to an address with a specific msg.value, with specified revert data.\n    function mockCallRevert(address callee, uint256 msgValue, bytes calldata data, bytes calldata revertData)\n        external;\n    // Clears all mocked calls\n    function clearMockedCalls() external;\n    // Expects a call to an address with the specified calldata.\n    // Calldata can either be a strict or a partial match\n    function expectCall(address callee, bytes calldata data) external;\n    // Expects given number of calls to an address with the specified calldata.\n    function expectCall(address callee, bytes calldata data, uint64 count) external;\n    // Expects a call to an address with the specified msg.value and calldata\n    function expectCall(address callee, uint256 msgValue, bytes calldata data) external;\n    // Expects given number of calls to an address with the specified msg.value and calldata\n    function expectCall(address callee, uint256 msgValue, bytes calldata data, uint64 count) external;\n    // Expect a call to an address with the specified msg.value, gas, and calldata.\n    function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data) external;\n    // Expects given number of calls to an address with the specified msg.value, gas, and calldata.\n    function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data, uint64 count) external;\n    // Expect a call to an address with the specified msg.value and calldata, and a *minimum* amount of gas.\n    function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data) external;\n    // Expect given number of calls to an address with the specified msg.value and calldata, and a *minimum* amount of gas.\n    function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data, uint64 count)\n        external;\n    // Only allows memory writes to offsets [0x00, 0x60)  [min, max) in the current subcontext. If any other\n    // memory is written to, the test will fail. Can be called multiple times to add more ranges to the set.\n    function expectSafeMemory(uint64 min, uint64 max) external;\n    // Only allows memory writes to offsets [0x00, 0x60)  [min, max) in the next created subcontext.\n    // If any other memory is written to, the test will fail. Can be called multiple times to add more ranges\n    // to the set.\n    function expectSafeMemoryCall(uint64 min, uint64 max) external;\n    // Sets block.coinbase\n    function coinbase(address newCoinbase) external;\n    // Snapshot the current state of the evm.\n    // Returns the id of the snapshot that was created.\n    // To revert a snapshot use `revertTo`\n    function snapshot() external returns (uint256 snapshotId);\n    // Revert the state of the EVM to a previous snapshot\n    // Takes the snapshot id to revert to.\n    // This deletes the snapshot and all snapshots taken after the given snapshot id.\n    function revertTo(uint256 snapshotId) external returns (bool success);\n    // Creates a new fork with the given endpoint and block and returns the identifier of the fork\n    function createFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);\n    // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\n    function createFork(string calldata urlOrAlias) external returns (uint256 forkId);\n    // Creates a new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before the transaction,\n    // and returns the identifier of the fork\n    function createFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);\n    // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\n    function createSelectFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);\n    // Creates _and_ also selects new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before\n    // the transaction, returns the identifier of the fork\n    function createSelectFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);\n    // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\n    function createSelectFork(string calldata urlOrAlias) external returns (uint256 forkId);\n    // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n    function selectFork(uint256 forkId) external;\n    /// Returns the identifier of the currently active fork. Reverts if no fork is currently active.\n    function activeFork() external view returns (uint256 forkId);\n    // Updates the currently active fork to given block number\n    // This is similar to `roll` but for the currently active fork\n    function rollFork(uint256 blockNumber) external;\n    // Updates the currently active fork to given transaction\n    // this will `rollFork` with the number of the block the transaction was mined in and replays all transaction mined before it in the block\n    function rollFork(bytes32 txHash) external;\n    // Updates the given fork to given block number\n    function rollFork(uint256 forkId, uint256 blockNumber) external;\n    // Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block\n    function rollFork(uint256 forkId, bytes32 txHash) external;\n    // Marks that the account(s) should use persistent storage across fork swaps in a multifork setup\n    // Meaning, changes made to the state of this account will be kept when switching forks\n    function makePersistent(address account) external;\n    function makePersistent(address account0, address account1) external;\n    function makePersistent(address account0, address account1, address account2) external;\n    function makePersistent(address[] calldata accounts) external;\n    // Revokes persistent status from the address, previously added via `makePersistent`\n    function revokePersistent(address account) external;\n    function revokePersistent(address[] calldata accounts) external;\n    // Returns true if the account is marked as persistent\n    function isPersistent(address account) external view returns (bool persistent);\n    // In forking mode, explicitly grant the given address cheatcode access\n    function allowCheatcodes(address account) external;\n    // Fetches the given transaction from the active fork and executes it on the current state\n    function transact(bytes32 txHash) external;\n    // Fetches the given transaction from the given fork and executes it on the current state\n    function transact(uint256 forkId, bytes32 txHash) external;\n}\n"
        },
        "lib/forge-std/src/console.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n    }\n\n    function logUint(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n    }\n\n    function log(uint p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n    }\n\n    function log(uint p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n    }\n\n    function log(uint p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"
        },
        "lib/forge-std/src/console2.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\n/// @dev The original console.sol uses `int` and `uint` for computing function selectors, but it should\n/// use `int256` and `uint256`. This modified version fixes that. This version is recommended\n/// over `console.sol` if you don't need compatibility with Hardhat as the logs will show up in\n/// forge stack traces. If you do need compatibility with Hardhat, you must use `console.sol`.\n/// Reference: https://github.com/NomicFoundation/hardhat/issues/2178\nlibrary console2 {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _castLogPayloadViewToPure(\n        function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) internal pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castLogPayloadViewToPure(_sendLogPayloadView)(payload);\n    }\n\n    function _sendLogPayloadView(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, int256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,int256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"
        },
        "lib/forge-std/src/interfaces/IMulticall3.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\ninterface IMulticall3 {\n    struct Call {\n        address target;\n        bytes callData;\n    }\n\n    struct Call3 {\n        address target;\n        bool allowFailure;\n        bytes callData;\n    }\n\n    struct Call3Value {\n        address target;\n        bool allowFailure;\n        uint256 value;\n        bytes callData;\n    }\n\n    struct Result {\n        bool success;\n        bytes returnData;\n    }\n\n    function aggregate(Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes[] memory returnData);\n\n    function aggregate3(Call3[] calldata calls) external payable returns (Result[] memory returnData);\n\n    function aggregate3Value(Call3Value[] calldata calls) external payable returns (Result[] memory returnData);\n\n    function blockAndAggregate(Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);\n\n    function getBasefee() external view returns (uint256 basefee);\n\n    function getBlockHash(uint256 blockNumber) external view returns (bytes32 blockHash);\n\n    function getBlockNumber() external view returns (uint256 blockNumber);\n\n    function getChainId() external view returns (uint256 chainid);\n\n    function getCurrentBlockCoinbase() external view returns (address coinbase);\n\n    function getCurrentBlockDifficulty() external view returns (uint256 difficulty);\n\n    function getCurrentBlockGasLimit() external view returns (uint256 gaslimit);\n\n    function getCurrentBlockTimestamp() external view returns (uint256 timestamp);\n\n    function getEthBalance(address addr) external view returns (uint256 balance);\n\n    function getLastBlockHash() external view returns (bytes32 blockHash);\n\n    function tryAggregate(bool requireSuccess, Call[] calldata calls)\n        external\n        payable\n        returns (Result[] memory returnData);\n\n    function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);\n}\n"
        },
        "lib/forge-std/src/safeconsole.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\n/// @author philogy <https://github.com/philogy>\n/// @dev Code generated automatically by script.\nlibrary safeconsole {\n    uint256 constant CONSOLE_ADDR = 0x000000000000000000000000000000000000000000636F6e736F6c652e6c6f67;\n\n    // Credit to [0age](https://twitter.com/z0age/status/1654922202930888704) and [0xdapper](https://github.com/foundry-rs/forge-std/pull/374)\n    // for the view-to-pure log trick.\n    function _sendLogPayload(uint256 offset, uint256 size) private pure {\n        function(uint256, uint256) internal view fnIn = _sendLogPayloadView;\n        function(uint256, uint256) internal pure pureSendLogPayload;\n        assembly {\n            pureSendLogPayload := fnIn\n        }\n        pureSendLogPayload(offset, size);\n    }\n\n    function _sendLogPayloadView(uint256 offset, uint256 size) private view {\n        assembly {\n            pop(staticcall(gas(), CONSOLE_ADDR, offset, size, 0x0, 0x0))\n        }\n    }\n\n    function _memcopy(uint256 fromOffset, uint256 toOffset, uint256 length) private pure {\n        function(uint256, uint256, uint256) internal view fnIn = _memcopyView;\n        function(uint256, uint256, uint256) internal pure pureMemcopy;\n        assembly {\n            pureMemcopy := fnIn\n        }\n        pureMemcopy(fromOffset, toOffset, length);\n    }\n\n    function _memcopyView(uint256 fromOffset, uint256 toOffset, uint256 length) private view {\n        assembly {\n            pop(staticcall(gas(), 0x4, fromOffset, length, toOffset, length))\n        }\n    }\n\n    function logMemory(uint256 offset, uint256 length) internal pure {\n        if (offset >= 0x60) {\n            // Sufficient memory before slice to prepare call header.\n            bytes32 m0;\n            bytes32 m1;\n            bytes32 m2;\n            assembly {\n                m0 := mload(sub(offset, 0x60))\n                m1 := mload(sub(offset, 0x40))\n                m2 := mload(sub(offset, 0x20))\n                // Selector of `logBytes(bytes)`.\n                mstore(sub(offset, 0x60), 0xe17bf956)\n                mstore(sub(offset, 0x40), 0x20)\n                mstore(sub(offset, 0x20), length)\n            }\n            _sendLogPayload(offset - 0x44, length + 0x44);\n            assembly {\n                mstore(sub(offset, 0x60), m0)\n                mstore(sub(offset, 0x40), m1)\n                mstore(sub(offset, 0x20), m2)\n            }\n        } else {\n            // Insufficient space, so copy slice forward, add header and reverse.\n            bytes32 m0;\n            bytes32 m1;\n            bytes32 m2;\n            uint256 endOffset = offset + length;\n            assembly {\n                m0 := mload(add(endOffset, 0x00))\n                m1 := mload(add(endOffset, 0x20))\n                m2 := mload(add(endOffset, 0x40))\n            }\n            _memcopy(offset, offset + 0x60, length);\n            assembly {\n                // Selector of `logBytes(bytes)`.\n                mstore(add(offset, 0x00), 0xe17bf956)\n                mstore(add(offset, 0x20), 0x20)\n                mstore(add(offset, 0x40), length)\n            }\n            _sendLogPayload(offset + 0x1c, length + 0x44);\n            _memcopy(offset + 0x60, offset, length);\n            assembly {\n                mstore(add(endOffset, 0x00), m0)\n                mstore(add(endOffset, 0x20), m1)\n                mstore(add(endOffset, 0x40), m2)\n            }\n        }\n    }\n\n    function log(address p0) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            // Selector of `log(address)`.\n            mstore(0x00, 0x2c2ecbc2)\n            mstore(0x20, p0)\n        }\n        _sendLogPayload(0x1c, 0x24);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n        }\n    }\n\n    function log(bool p0) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            // Selector of `log(bool)`.\n            mstore(0x00, 0x32458eed)\n            mstore(0x20, p0)\n        }\n        _sendLogPayload(0x1c, 0x24);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n        }\n    }\n\n    function log(uint256 p0) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            // Selector of `log(uint256)`.\n            mstore(0x00, 0xf82c50f1)\n            mstore(0x20, p0)\n        }\n        _sendLogPayload(0x1c, 0x24);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n        }\n    }\n\n    function log(bytes32 p0) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(string)`.\n            mstore(0x00, 0x41304fac)\n            mstore(0x20, 0x20)\n            writeString(0x40, p0)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, address p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(address,address)`.\n            mstore(0x00, 0xdaf0d4aa)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(address p0, bool p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(address,bool)`.\n            mstore(0x00, 0x75b605d3)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(address,uint256)`.\n            mstore(0x00, 0x8309e8a8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(address p0, bytes32 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,string)`.\n            mstore(0x00, 0x759f86bb)\n            mstore(0x20, p0)\n            mstore(0x40, 0x40)\n            writeString(0x60, p1)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(bool,address)`.\n            mstore(0x00, 0x853c4849)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(bool,bool)`.\n            mstore(0x00, 0x2a110e83)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(bool,uint256)`.\n            mstore(0x00, 0x399174d3)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(bool p0, bytes32 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,string)`.\n            mstore(0x00, 0x8feac525)\n            mstore(0x20, p0)\n            mstore(0x40, 0x40)\n            writeString(0x60, p1)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(uint256,address)`.\n            mstore(0x00, 0x69276c86)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(uint256,bool)`.\n            mstore(0x00, 0x1c9d7eb3)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(uint256,uint256)`.\n            mstore(0x00, 0xf666715a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,string)`.\n            mstore(0x00, 0x643fd0df)\n            mstore(0x20, p0)\n            mstore(0x40, 0x40)\n            writeString(0x60, p1)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bytes32 p0, address p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(string,address)`.\n            mstore(0x00, 0x319af333)\n            mstore(0x20, 0x40)\n            mstore(0x40, p1)\n            writeString(0x60, p0)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bytes32 p0, bool p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(string,bool)`.\n            mstore(0x00, 0xc3b55635)\n            mstore(0x20, 0x40)\n            mstore(0x40, p1)\n            writeString(0x60, p0)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(string,uint256)`.\n            mstore(0x00, 0xb60e72cc)\n            mstore(0x20, 0x40)\n            mstore(0x40, p1)\n            writeString(0x60, p0)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,string)`.\n            mstore(0x00, 0x4b5c4277)\n            mstore(0x20, 0x40)\n            mstore(0x40, 0x80)\n            writeString(0x60, p0)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,address,address)`.\n            mstore(0x00, 0x018c84c2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,address,bool)`.\n            mstore(0x00, 0xf2a66286)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,address,uint256)`.\n            mstore(0x00, 0x17fe6185)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, address p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(address,address,string)`.\n            mstore(0x00, 0x007150be)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,bool,address)`.\n            mstore(0x00, 0xf11699ed)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,bool,bool)`.\n            mstore(0x00, 0xeb830c92)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,bool,uint256)`.\n            mstore(0x00, 0x9c4f99fb)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, bool p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(address,bool,string)`.\n            mstore(0x00, 0x212255cc)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,uint256,address)`.\n            mstore(0x00, 0x7bc0d848)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,uint256,bool)`.\n            mstore(0x00, 0x678209a8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,uint256,uint256)`.\n            mstore(0x00, 0xb69bcaf6)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, uint256 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(address,uint256,string)`.\n            mstore(0x00, 0xa1f2e8aa)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(address p0, bytes32 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(address,string,address)`.\n            mstore(0x00, 0xf08744e8)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(address,string,bool)`.\n            mstore(0x00, 0xcf020fb1)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(address p0, bytes32 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(address,string,uint256)`.\n            mstore(0x00, 0x67dd6ff1)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(address,string,string)`.\n            mstore(0x00, 0xfb772265)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, 0xa0)\n            writeString(0x80, p1)\n            writeString(0xc0, p2)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,address,address)`.\n            mstore(0x00, 0xd2763667)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,address,bool)`.\n            mstore(0x00, 0x18c9c746)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,address,uint256)`.\n            mstore(0x00, 0x5f7b9afb)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, address p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(bool,address,string)`.\n            mstore(0x00, 0xde9a9270)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,bool,address)`.\n            mstore(0x00, 0x1078f68d)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,bool,bool)`.\n            mstore(0x00, 0x50709698)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,bool,uint256)`.\n            mstore(0x00, 0x12f21602)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, bool p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(bool,bool,string)`.\n            mstore(0x00, 0x2555fa46)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,uint256,address)`.\n            mstore(0x00, 0x088ef9d2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,uint256,bool)`.\n            mstore(0x00, 0xe8defba9)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,uint256,uint256)`.\n            mstore(0x00, 0x37103367)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(bool,uint256,string)`.\n            mstore(0x00, 0xc3fc3970)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(bool,string,address)`.\n            mstore(0x00, 0x9591b953)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(bool,string,bool)`.\n            mstore(0x00, 0xdbb4c247)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(bool,string,uint256)`.\n            mstore(0x00, 0x1093ee11)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(bool,string,string)`.\n            mstore(0x00, 0xb076847f)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, 0xa0)\n            writeString(0x80, p1)\n            writeString(0xc0, p2)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,address,address)`.\n            mstore(0x00, 0xbcfd9be0)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,address,bool)`.\n            mstore(0x00, 0x9b6ec042)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,address,uint256)`.\n            mstore(0x00, 0x5a9b5ed5)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, address p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(uint256,address,string)`.\n            mstore(0x00, 0x63cb41f9)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,bool,address)`.\n            mstore(0x00, 0x35085f7b)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,bool,bool)`.\n            mstore(0x00, 0x20718650)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,bool,uint256)`.\n            mstore(0x00, 0x20098014)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(uint256,bool,string)`.\n            mstore(0x00, 0x85775021)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,uint256,address)`.\n            mstore(0x00, 0x5c96b331)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,uint256,bool)`.\n            mstore(0x00, 0x4766da72)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,uint256,uint256)`.\n            mstore(0x00, 0xd1ed7a3c)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(uint256,uint256,string)`.\n            mstore(0x00, 0x71d04af2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(uint256,string,address)`.\n            mstore(0x00, 0x7afac959)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(uint256,string,bool)`.\n            mstore(0x00, 0x4ceda75a)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(uint256,string,uint256)`.\n            mstore(0x00, 0x37aa7d4c)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(uint256,string,string)`.\n            mstore(0x00, 0xb115611f)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, 0xa0)\n            writeString(0x80, p1)\n            writeString(0xc0, p2)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, address p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,address,address)`.\n            mstore(0x00, 0xfcec75e0)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,address,bool)`.\n            mstore(0x00, 0xc91d5ed4)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, address p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,address,uint256)`.\n            mstore(0x00, 0x0d26b925)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(string,address,string)`.\n            mstore(0x00, 0xe0e9ad4f)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, 0xa0)\n            writeString(0x80, p0)\n            writeString(0xc0, p2)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,bool,address)`.\n            mstore(0x00, 0x932bbb38)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,bool,bool)`.\n            mstore(0x00, 0x850b7ad6)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,bool,uint256)`.\n            mstore(0x00, 0xc95958d6)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(string,bool,string)`.\n            mstore(0x00, 0xe298f47d)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, 0xa0)\n            writeString(0x80, p0)\n            writeString(0xc0, p2)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,uint256,address)`.\n            mstore(0x00, 0x1c7ec448)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,uint256,bool)`.\n            mstore(0x00, 0xca7733b1)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,uint256,uint256)`.\n            mstore(0x00, 0xca47c4eb)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(string,uint256,string)`.\n            mstore(0x00, 0x5970e089)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, 0xa0)\n            writeString(0x80, p0)\n            writeString(0xc0, p2)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(string,string,address)`.\n            mstore(0x00, 0x95ed0195)\n            mstore(0x20, 0x60)\n            mstore(0x40, 0xa0)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n            writeString(0xc0, p1)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(string,string,bool)`.\n            mstore(0x00, 0xb0e0f9b5)\n            mstore(0x20, 0x60)\n            mstore(0x40, 0xa0)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n            writeString(0xc0, p1)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(string,string,uint256)`.\n            mstore(0x00, 0x5821efa1)\n            mstore(0x20, 0x60)\n            mstore(0x40, 0xa0)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n            writeString(0xc0, p1)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            // Selector of `log(string,string,string)`.\n            mstore(0x00, 0x2ced7cef)\n            mstore(0x20, 0x60)\n            mstore(0x40, 0xa0)\n            mstore(0x60, 0xe0)\n            writeString(0x80, p0)\n            writeString(0xc0, p1)\n            writeString(0x100, p2)\n        }\n        _sendLogPayload(0x1c, 0x124);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n        }\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,address,address)`.\n            mstore(0x00, 0x665bf134)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,address,bool)`.\n            mstore(0x00, 0x0e378994)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,address,uint256)`.\n            mstore(0x00, 0x94250d77)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,address,address,string)`.\n            mstore(0x00, 0xf808da20)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,bool,address)`.\n            mstore(0x00, 0x9f1bc36e)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,bool,bool)`.\n            mstore(0x00, 0x2cd4134a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,bool,uint256)`.\n            mstore(0x00, 0x3971e78c)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,address,bool,string)`.\n            mstore(0x00, 0xaa6540c8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,uint256,address)`.\n            mstore(0x00, 0x8da6def5)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,uint256,bool)`.\n            mstore(0x00, 0x9b4254e2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,uint256,uint256)`.\n            mstore(0x00, 0xbe553481)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,address,uint256,string)`.\n            mstore(0x00, 0xfdb4f990)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,address,string,address)`.\n            mstore(0x00, 0x8f736d16)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,address,string,bool)`.\n            mstore(0x00, 0x6f1a594e)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,address,string,uint256)`.\n            mstore(0x00, 0xef1cefe7)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,address,string,string)`.\n            mstore(0x00, 0x21bdaf25)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,address,address)`.\n            mstore(0x00, 0x660375dd)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,address,bool)`.\n            mstore(0x00, 0xa6f50b0f)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,address,uint256)`.\n            mstore(0x00, 0xa75c59de)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,bool,address,string)`.\n            mstore(0x00, 0x2dd778e6)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,bool,address)`.\n            mstore(0x00, 0xcf394485)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,bool,bool)`.\n            mstore(0x00, 0xcac43479)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,bool,uint256)`.\n            mstore(0x00, 0x8c4e5de6)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,bool,bool,string)`.\n            mstore(0x00, 0xdfc4a2e8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,uint256,address)`.\n            mstore(0x00, 0xccf790a1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,uint256,bool)`.\n            mstore(0x00, 0xc4643e20)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,uint256,uint256)`.\n            mstore(0x00, 0x386ff5f4)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,bool,uint256,string)`.\n            mstore(0x00, 0x0aa6cfad)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bool p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,bool,string,address)`.\n            mstore(0x00, 0x19fd4956)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bool p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,bool,string,bool)`.\n            mstore(0x00, 0x50ad461d)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bool p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,bool,string,uint256)`.\n            mstore(0x00, 0x80e6a20b)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,bool,string,string)`.\n            mstore(0x00, 0x475c5c33)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,address,address)`.\n            mstore(0x00, 0x478d1c62)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,address,bool)`.\n            mstore(0x00, 0xa1bcc9b3)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,address,uint256)`.\n            mstore(0x00, 0x100f650e)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,uint256,address,string)`.\n            mstore(0x00, 0x1da986ea)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,bool,address)`.\n            mstore(0x00, 0xa31bfdcc)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,bool,bool)`.\n            mstore(0x00, 0x3bf5e537)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,bool,uint256)`.\n            mstore(0x00, 0x22f6b999)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,uint256,bool,string)`.\n            mstore(0x00, 0xc5ad85f9)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,uint256,address)`.\n            mstore(0x00, 0x20e3984d)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,uint256,bool)`.\n            mstore(0x00, 0x66f1bc67)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,uint256,uint256)`.\n            mstore(0x00, 0x34f0e636)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,uint256,uint256,string)`.\n            mstore(0x00, 0x4a28c017)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, uint256 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,uint256,string,address)`.\n            mstore(0x00, 0x5c430d47)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, uint256 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,uint256,string,bool)`.\n            mstore(0x00, 0xcf18105c)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,uint256,string,uint256)`.\n            mstore(0x00, 0xbf01f891)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,uint256,string,string)`.\n            mstore(0x00, 0x88a8c406)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,address,address)`.\n            mstore(0x00, 0x0d36fa20)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,address,bool)`.\n            mstore(0x00, 0x0df12b76)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,address,uint256)`.\n            mstore(0x00, 0x457fe3cf)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,string,address,string)`.\n            mstore(0x00, 0xf7e36245)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,bool,address)`.\n            mstore(0x00, 0x205871c2)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,bool,bool)`.\n            mstore(0x00, 0x5f1d5c9f)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,bool,uint256)`.\n            mstore(0x00, 0x515e38b6)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,string,bool,string)`.\n            mstore(0x00, 0xbc0b61fe)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,uint256,address)`.\n            mstore(0x00, 0x63183678)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,uint256,bool)`.\n            mstore(0x00, 0x0ef7e050)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,uint256,uint256)`.\n            mstore(0x00, 0x1dc8e1b8)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,string,uint256,string)`.\n            mstore(0x00, 0x448830a8)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,string,string,address)`.\n            mstore(0x00, 0xa04e2f87)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,string,string,bool)`.\n            mstore(0x00, 0x35a5071f)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,string,string,uint256)`.\n            mstore(0x00, 0x159f8927)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(address,string,string,string)`.\n            mstore(0x00, 0x5d02c50b)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,address,address)`.\n            mstore(0x00, 0x1d14d001)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,address,bool)`.\n            mstore(0x00, 0x46600be0)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,address,uint256)`.\n            mstore(0x00, 0x0c66d1be)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,address,address,string)`.\n            mstore(0x00, 0xd812a167)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,bool,address)`.\n            mstore(0x00, 0x1c41a336)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,bool,bool)`.\n            mstore(0x00, 0x6a9c478b)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,bool,uint256)`.\n            mstore(0x00, 0x07831502)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,address,bool,string)`.\n            mstore(0x00, 0x4a66cb34)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,uint256,address)`.\n            mstore(0x00, 0x136b05dd)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,uint256,bool)`.\n            mstore(0x00, 0xd6019f1c)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,uint256,uint256)`.\n            mstore(0x00, 0x7bf181a1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,address,uint256,string)`.\n            mstore(0x00, 0x51f09ff8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, address p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,address,string,address)`.\n            mstore(0x00, 0x6f7c603e)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, address p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,address,string,bool)`.\n            mstore(0x00, 0xe2bfd60b)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, address p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,address,string,uint256)`.\n            mstore(0x00, 0xc21f64c7)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, address p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,address,string,string)`.\n            mstore(0x00, 0xa73c1db6)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,address,address)`.\n            mstore(0x00, 0xf4880ea4)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,address,bool)`.\n            mstore(0x00, 0xc0a302d8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,address,uint256)`.\n            mstore(0x00, 0x4c123d57)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,bool,address,string)`.\n            mstore(0x00, 0xa0a47963)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,bool,address)`.\n            mstore(0x00, 0x8c329b1a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,bool,bool)`.\n            mstore(0x00, 0x3b2a5ce0)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,bool,uint256)`.\n            mstore(0x00, 0x6d7045c1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,bool,bool,string)`.\n            mstore(0x00, 0x2ae408d4)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,uint256,address)`.\n            mstore(0x00, 0x54a7a9a0)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,uint256,bool)`.\n            mstore(0x00, 0x619e4d0e)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,uint256,uint256)`.\n            mstore(0x00, 0x0bb00eab)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,bool,uint256,string)`.\n            mstore(0x00, 0x7dd4d0e0)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bool p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,bool,string,address)`.\n            mstore(0x00, 0xf9ad2b89)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bool p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,bool,string,bool)`.\n            mstore(0x00, 0xb857163a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bool p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,bool,string,uint256)`.\n            mstore(0x00, 0xe3a9ca2f)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,bool,string,string)`.\n            mstore(0x00, 0x6d1e8751)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,address,address)`.\n            mstore(0x00, 0x26f560a8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,address,bool)`.\n            mstore(0x00, 0xb4c314ff)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,address,uint256)`.\n            mstore(0x00, 0x1537dc87)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,uint256,address,string)`.\n            mstore(0x00, 0x1bb3b09a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,bool,address)`.\n            mstore(0x00, 0x9acd3616)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,bool,bool)`.\n            mstore(0x00, 0xceb5f4d7)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,bool,uint256)`.\n            mstore(0x00, 0x7f9bbca2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,uint256,bool,string)`.\n            mstore(0x00, 0x9143dbb1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,uint256,address)`.\n            mstore(0x00, 0x00dd87b9)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,uint256,bool)`.\n            mstore(0x00, 0xbe984353)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,uint256,uint256)`.\n            mstore(0x00, 0x374bb4b2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,uint256,uint256,string)`.\n            mstore(0x00, 0x8e69fb5d)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,uint256,string,address)`.\n            mstore(0x00, 0xfedd1fff)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,uint256,string,bool)`.\n            mstore(0x00, 0xe5e70b2b)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,uint256,string,uint256)`.\n            mstore(0x00, 0x6a1199e2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,uint256,string,string)`.\n            mstore(0x00, 0xf5bc2249)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,address,address)`.\n            mstore(0x00, 0x2b2b18dc)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,address,bool)`.\n            mstore(0x00, 0x6dd434ca)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,address,uint256)`.\n            mstore(0x00, 0xa5cada94)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,string,address,string)`.\n            mstore(0x00, 0x12d6c788)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,bool,address)`.\n            mstore(0x00, 0x538e06ab)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,bool,bool)`.\n            mstore(0x00, 0xdc5e935b)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,bool,uint256)`.\n            mstore(0x00, 0x1606a393)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,string,bool,string)`.\n            mstore(0x00, 0x483d0416)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,uint256,address)`.\n            mstore(0x00, 0x1596a1ce)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,uint256,bool)`.\n            mstore(0x00, 0x6b0e5d53)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,uint256,uint256)`.\n            mstore(0x00, 0x28863fcb)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,string,uint256,string)`.\n            mstore(0x00, 0x1ad96de6)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,string,string,address)`.\n            mstore(0x00, 0x97d394d8)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,string,string,bool)`.\n            mstore(0x00, 0x1e4b87e5)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,string,string,uint256)`.\n            mstore(0x00, 0x7be0c3eb)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(bool,string,string,string)`.\n            mstore(0x00, 0x1762e32a)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,address,address)`.\n            mstore(0x00, 0x2488b414)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,address,bool)`.\n            mstore(0x00, 0x091ffaf5)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,address,uint256)`.\n            mstore(0x00, 0x736efbb6)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,address,address,string)`.\n            mstore(0x00, 0x031c6f73)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,bool,address)`.\n            mstore(0x00, 0xef72c513)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,bool,bool)`.\n            mstore(0x00, 0xe351140f)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,bool,uint256)`.\n            mstore(0x00, 0x5abd992a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,address,bool,string)`.\n            mstore(0x00, 0x90fb06aa)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,uint256,address)`.\n            mstore(0x00, 0x15c127b5)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,uint256,bool)`.\n            mstore(0x00, 0x5f743a7c)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,uint256,uint256)`.\n            mstore(0x00, 0x0c9cd9c1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,address,uint256,string)`.\n            mstore(0x00, 0xddb06521)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, address p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,address,string,address)`.\n            mstore(0x00, 0x9cba8fff)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, address p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,address,string,bool)`.\n            mstore(0x00, 0xcc32ab07)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, address p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,address,string,uint256)`.\n            mstore(0x00, 0x46826b5d)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, address p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,address,string,string)`.\n            mstore(0x00, 0x3e128ca3)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,address,address)`.\n            mstore(0x00, 0xa1ef4cbb)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,address,bool)`.\n            mstore(0x00, 0x454d54a5)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,address,uint256)`.\n            mstore(0x00, 0x078287f5)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,bool,address,string)`.\n            mstore(0x00, 0xade052c7)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,bool,address)`.\n            mstore(0x00, 0x69640b59)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,bool,bool)`.\n            mstore(0x00, 0xb6f577a1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,bool,uint256)`.\n            mstore(0x00, 0x7464ce23)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,bool,bool,string)`.\n            mstore(0x00, 0xdddb9561)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,uint256,address)`.\n            mstore(0x00, 0x88cb6041)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,uint256,bool)`.\n            mstore(0x00, 0x91a02e2a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,uint256,uint256)`.\n            mstore(0x00, 0xc6acc7a8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,bool,uint256,string)`.\n            mstore(0x00, 0xde03e774)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,bool,string,address)`.\n            mstore(0x00, 0xef529018)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,bool,string,bool)`.\n            mstore(0x00, 0xeb928d7f)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,bool,string,uint256)`.\n            mstore(0x00, 0x2c1d0746)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,bool,string,string)`.\n            mstore(0x00, 0x68c8b8bd)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,address,address)`.\n            mstore(0x00, 0x56a5d1b1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,address,bool)`.\n            mstore(0x00, 0x15cac476)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,address,uint256)`.\n            mstore(0x00, 0x88f6e4b2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,uint256,address,string)`.\n            mstore(0x00, 0x6cde40b8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,bool,address)`.\n            mstore(0x00, 0x9a816a83)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,bool,bool)`.\n            mstore(0x00, 0xab085ae6)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,bool,uint256)`.\n            mstore(0x00, 0xeb7f6fd2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,uint256,bool,string)`.\n            mstore(0x00, 0xa5b4fc99)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,uint256,address)`.\n            mstore(0x00, 0xfa8185af)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,uint256,bool)`.\n            mstore(0x00, 0xc598d185)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,uint256,uint256)`.\n            mstore(0x00, 0x193fb800)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,uint256,uint256,string)`.\n            mstore(0x00, 0x59cfcbe3)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,uint256,string,address)`.\n            mstore(0x00, 0x42d21db7)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,uint256,string,bool)`.\n            mstore(0x00, 0x7af6ab25)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,uint256,string,uint256)`.\n            mstore(0x00, 0x5da297eb)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,uint256,string,string)`.\n            mstore(0x00, 0x27d8afd2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,address,address)`.\n            mstore(0x00, 0x6168ed61)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,address,bool)`.\n            mstore(0x00, 0x90c30a56)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,address,uint256)`.\n            mstore(0x00, 0xe8d3018d)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,string,address,string)`.\n            mstore(0x00, 0x9c3adfa1)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,bool,address)`.\n            mstore(0x00, 0xae2ec581)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,bool,bool)`.\n            mstore(0x00, 0xba535d9c)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,bool,uint256)`.\n            mstore(0x00, 0xcf009880)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,string,bool,string)`.\n            mstore(0x00, 0xd2d423cd)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,uint256,address)`.\n            mstore(0x00, 0x3b2279b4)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,uint256,bool)`.\n            mstore(0x00, 0x691a8f74)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,uint256,uint256)`.\n            mstore(0x00, 0x82c25b74)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,string,uint256,string)`.\n            mstore(0x00, 0xb7b914ca)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,string,string,address)`.\n            mstore(0x00, 0xd583c602)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,string,string,bool)`.\n            mstore(0x00, 0xb3a6b6bd)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,string,string,uint256)`.\n            mstore(0x00, 0xb028c9bd)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(uint256,string,string,string)`.\n            mstore(0x00, 0x21ad0683)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, address p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,address,address)`.\n            mstore(0x00, 0xed8f28f6)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,address,bool)`.\n            mstore(0x00, 0xb59dbd60)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,address,uint256)`.\n            mstore(0x00, 0x8ef3f399)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,address,address,string)`.\n            mstore(0x00, 0x800a1c67)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,bool,address)`.\n            mstore(0x00, 0x223603bd)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,bool,bool)`.\n            mstore(0x00, 0x79884c2b)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,bool,uint256)`.\n            mstore(0x00, 0x3e9f866a)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,address,bool,string)`.\n            mstore(0x00, 0x0454c079)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, address p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,uint256,address)`.\n            mstore(0x00, 0x63fb8bc5)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,uint256,bool)`.\n            mstore(0x00, 0xfc4845f0)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,uint256,uint256)`.\n            mstore(0x00, 0xf8f51b1e)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,address,uint256,string)`.\n            mstore(0x00, 0x5a477632)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,address,string,address)`.\n            mstore(0x00, 0xaabc9a31)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,address,string,bool)`.\n            mstore(0x00, 0x5f15d28c)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,address,string,uint256)`.\n            mstore(0x00, 0x91d1112e)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,address,string,string)`.\n            mstore(0x00, 0x245986f2)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,address,address)`.\n            mstore(0x00, 0x33e9dd1d)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,address,bool)`.\n            mstore(0x00, 0x958c28c6)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,address,uint256)`.\n            mstore(0x00, 0x5d08bb05)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,bool,address,string)`.\n            mstore(0x00, 0x2d8e33a4)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,bool,address)`.\n            mstore(0x00, 0x7190a529)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,bool,bool)`.\n            mstore(0x00, 0x895af8c5)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,bool,uint256)`.\n            mstore(0x00, 0x8e3f78a9)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,bool,bool,string)`.\n            mstore(0x00, 0x9d22d5dd)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,uint256,address)`.\n            mstore(0x00, 0x935e09bf)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,uint256,bool)`.\n            mstore(0x00, 0x8af7cf8a)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,uint256,uint256)`.\n            mstore(0x00, 0x64b5bb67)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,bool,uint256,string)`.\n            mstore(0x00, 0x742d6ee7)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,bool,string,address)`.\n            mstore(0x00, 0xe0625b29)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,bool,string,bool)`.\n            mstore(0x00, 0x3f8a701d)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,bool,string,uint256)`.\n            mstore(0x00, 0x24f91465)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,bool,string,string)`.\n            mstore(0x00, 0xa826caeb)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,address,address)`.\n            mstore(0x00, 0x5ea2b7ae)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,address,bool)`.\n            mstore(0x00, 0x82112a42)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,address,uint256)`.\n            mstore(0x00, 0x4f04fdc6)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,uint256,address,string)`.\n            mstore(0x00, 0x9ffb2f93)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,bool,address)`.\n            mstore(0x00, 0xe0e95b98)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,bool,bool)`.\n            mstore(0x00, 0x354c36d6)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,bool,uint256)`.\n            mstore(0x00, 0xe41b6f6f)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,uint256,bool,string)`.\n            mstore(0x00, 0xabf73a98)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,uint256,address)`.\n            mstore(0x00, 0xe21de278)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,uint256,bool)`.\n            mstore(0x00, 0x7626db92)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,uint256,uint256)`.\n            mstore(0x00, 0xa7a87853)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,uint256,uint256,string)`.\n            mstore(0x00, 0x854b3496)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,uint256,string,address)`.\n            mstore(0x00, 0x7c4632a4)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,uint256,string,bool)`.\n            mstore(0x00, 0x7d24491d)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,uint256,string,uint256)`.\n            mstore(0x00, 0xc67ea9d1)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,uint256,string,string)`.\n            mstore(0x00, 0x5ab84e1f)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,address,address)`.\n            mstore(0x00, 0x439c7bef)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,address,bool)`.\n            mstore(0x00, 0x5ccd4e37)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,address,uint256)`.\n            mstore(0x00, 0x7cc3c607)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,string,address,string)`.\n            mstore(0x00, 0xeb1bff80)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,bool,address)`.\n            mstore(0x00, 0xc371c7db)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,bool,bool)`.\n            mstore(0x00, 0x40785869)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,bool,uint256)`.\n            mstore(0x00, 0xd6aefad2)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,string,bool,string)`.\n            mstore(0x00, 0x5e84b0ea)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,uint256,address)`.\n            mstore(0x00, 0x1023f7b2)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,uint256,bool)`.\n            mstore(0x00, 0xc3a8a654)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,uint256,uint256)`.\n            mstore(0x00, 0xf45d7d2c)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,string,uint256,string)`.\n            mstore(0x00, 0x5d1a971a)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,string,string,address)`.\n            mstore(0x00, 0x6d572f44)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, 0x100)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p2)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,string,string,bool)`.\n            mstore(0x00, 0x2c1754ed)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, 0x100)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p2)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,string,string,uint256)`.\n            mstore(0x00, 0x8eafb02b)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, 0x100)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p2)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        bytes32 m11;\n        bytes32 m12;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            m11 := mload(0x160)\n            m12 := mload(0x180)\n            // Selector of `log(string,string,string,string)`.\n            mstore(0x00, 0xde68f20a)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, 0x100)\n            mstore(0x80, 0x140)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p2)\n            writeString(0x160, p3)\n        }\n        _sendLogPayload(0x1c, 0x184);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n            mstore(0x160, m11)\n            mstore(0x180, m12)\n        }\n    }\n}\n"
        },
        "node_modules/@openzeppelin/contracts/access/AccessControl.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(account),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
        },
        "node_modules/@openzeppelin/contracts/access/AccessControlEnumerable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerable.sol\";\nimport \"./AccessControl.sol\";\nimport \"../utils/structs/EnumerableSet.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n}\n"
        },
        "node_modules/@openzeppelin/contracts/access/IAccessControl.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
        },
        "node_modules/@openzeppelin/contracts/access/IAccessControlEnumerable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
        },
        "node_modules/@openzeppelin/contracts/security/Pausable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
        },
        "node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"
        },
        "node_modules/@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    ) public view virtual override returns (uint256[] memory) {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner or approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner or approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(address to, uint256 id, uint256 amount, bytes memory data) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(address from, uint256 id, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(address from, uint256[] memory ids, uint256[] memory amounts) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
        },
        "node_modules/@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
        },
        "node_modules/@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
        },
        "node_modules/@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
        },
        "node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
        },
        "node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
        },
        "node_modules/@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n}\n"
        },
        "node_modules/@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/ERC20Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../security/Pausable.sol\";\n\n/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n *\n * IMPORTANT: This contract does not include public pause and unpause functions. In\n * addition to inheriting this contract, you must define both functions, invoking the\n * {Pausable-_pause} and {Pausable-_unpause} internal functions, with appropriate\n * access control, e.g. using {AccessControl} or {Ownable}. Not doing so will\n * make the contract unpausable.\n */\nabstract contract ERC20Pausable is ERC20, Pausable {\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        require(!paused(), \"ERC20Pausable: token transfer while paused\");\n    }\n}\n"
        },
        "node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
        },
        "node_modules/@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/presets/ERC20PresetMinterPauser.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../extensions/ERC20Burnable.sol\";\nimport \"../extensions/ERC20Pausable.sol\";\nimport \"../../../access/AccessControlEnumerable.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev {ERC20} token, including:\n *\n *  - ability for holders to burn (destroy) their tokens\n *  - a minter role that allows for token minting (creation)\n *  - a pauser role that allows to stop all token transfers\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter and pauser\n * roles, as well as the default admin role, which will let it grant both minter\n * and pauser roles to other accounts.\n *\n * _Deprecated in favor of https://wizard.openzeppelin.com/[Contracts Wizard]._\n */\ncontract ERC20PresetMinterPauser is Context, AccessControlEnumerable, ERC20Burnable, ERC20Pausable {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    /**\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\n     * account that deploys the contract.\n     *\n     * See {ERC20-constructor}.\n     */\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(PAUSER_ROLE, _msgSender());\n    }\n\n    /**\n     * @dev Creates `amount` new tokens for `to`.\n     *\n     * See {ERC20-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     */\n    function mint(address to, uint256 amount) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have minter role to mint\");\n        _mint(to, amount);\n    }\n\n    /**\n     * @dev Pauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_pause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function pause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to pause\");\n        _pause();\n    }\n\n    /**\n     * @dev Unpauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_unpause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function unpause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to unpause\");\n        _unpause();\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override(ERC20, ERC20Pausable) {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n}\n"
        },
        "node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant\n     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such\n     * that `ownerOf(tokenId)` is `a`.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n}\n"
        },
        "node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
        },
        "node_modules/@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
        },
        "node_modules/@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
        },
        "node_modules/@openzeppelin/contracts/utils/Address.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
        },
        "node_modules/@openzeppelin/contracts/utils/Context.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
        },
        "node_modules/@openzeppelin/contracts/utils/Strings.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
        },
        "node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
        },
        "node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
        },
        "node_modules/@openzeppelin/contracts/utils/math/Math.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
        },
        "node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
        },
        "node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
        },
        "node_modules/@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
        },
        "node_modules/@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
        },
        "node_modules/base64-sol/base64.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/// @title Base64\n/// @author Brecht Devos - <brecht@loopring.org>\n/// @notice Provides functions for encoding/decoding base64\nlibrary Base64 {\n    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    bytes  internal constant TABLE_DECODE = hex\"0000000000000000000000000000000000000000000000000000000000000000\"\n                                            hex\"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000\"\n                                            hex\"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000\"\n                                            hex\"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000\";\n\n    function encode(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return '';\n\n        // load the table into memory\n        string memory table = TABLE_ENCODE;\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n        // add some extra buffer at the end required for the writing\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            // set the actual output length\n            mstore(result, encodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 3 bytes at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n                // read 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // write 4 characters\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\n                resultPtr := add(resultPtr, 1)\n            }\n\n            // padding with '='\n            switch mod(mload(data), 3)\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\n        }\n\n        return result;\n    }\n\n    function decode(string memory _data) internal pure returns (bytes memory) {\n        bytes memory data = bytes(_data);\n\n        if (data.length == 0) return new bytes(0);\n        require(data.length % 4 == 0, \"invalid base64 decoder input\");\n\n        // load the table into memory\n        bytes memory table = TABLE_DECODE;\n\n        // every 4 characters represent 3 bytes\n        uint256 decodedLen = (data.length / 4) * 3;\n\n        // add some extra buffer at the end required for the writing\n        bytes memory result = new bytes(decodedLen + 32);\n\n        assembly {\n            // padding with '='\n            let lastBytes := mload(add(data, mload(data)))\n            if eq(and(lastBytes, 0xFF), 0x3d) {\n                decodedLen := sub(decodedLen, 1)\n                if eq(and(lastBytes, 0xFFFF), 0x3d3d) {\n                    decodedLen := sub(decodedLen, 1)\n                }\n            }\n\n            // set the actual output length\n            mstore(result, decodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 4 characters at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n               // read 4 characters\n               dataPtr := add(dataPtr, 4)\n               let input := mload(dataPtr)\n\n               // write 3 bytes\n               let output := add(\n                   add(\n                       shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\n                       shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),\n                   add(\n                       shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),\n                               and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)\n                    )\n                )\n                mstore(resultPtr, shl(232, output))\n                resultPtr := add(resultPtr, 3)\n            }\n        }\n\n        return result;\n    }\n}\n"
        },
        "script/Multicall3.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @title Multicall3\n/// @notice Aggregate results from multiple function calls\n/// @dev Multicall & Multicall2 backwards-compatible\n/// @dev Aggregate methods are marked `payable` to save 24 gas per call\n/// @author Michael Elliot <mike@makerdao.com>\n/// @author Joshua Levine <joshua@makerdao.com>\n/// @author Nick Johnson <arachnid@notdot.net>\n/// @author Andreas Bigger <andreas@nascent.xyz>\n/// @author Matt Solomon <matt@mattsolomon.dev>\ncontract Multicall3 {\n    struct Call {\n        address target;\n        bytes callData;\n    }\n\n    struct Call3 {\n        address target;\n        bool allowFailure;\n        bytes callData;\n    }\n\n    struct Call3Value {\n        address target;\n        bool allowFailure;\n        uint256 value;\n        bytes callData;\n    }\n\n    struct Result {\n        bool success;\n        bytes returnData;\n    }\n\n    /// @notice Backwards-compatible call aggregation with Multicall\n    /// @param calls An array of Call structs\n    /// @return blockNumber The block number where the calls were executed\n    /// @return returnData An array of bytes containing the responses\n    function aggregate(Call[] calldata calls) public payable returns (uint256 blockNumber, bytes[] memory returnData) {\n        blockNumber = block.number;\n        uint256 length = calls.length;\n        returnData = new bytes[](length);\n        Call calldata call;\n        for (uint256 i = 0; i < length;) {\n            bool success;\n            call = calls[i];\n            (success, returnData[i]) = call.target.call(call.callData);\n            require(success, \"Multicall3: call failed\");\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Backwards-compatible with Multicall2\n    /// @notice Aggregate calls without requiring success\n    /// @param requireSuccess If true, require all calls to succeed\n    /// @param calls An array of Call structs\n    /// @return returnData An array of Result structs\n    function tryAggregate(bool requireSuccess, Call[] calldata calls)\n        public\n        payable\n        returns (Result[] memory returnData)\n    {\n        uint256 length = calls.length;\n        returnData = new Result[](length);\n        Call calldata call;\n        for (uint256 i = 0; i < length;) {\n            Result memory result = returnData[i];\n            call = calls[i];\n            (result.success, result.returnData) = call.target.call(call.callData);\n            if (requireSuccess) require(result.success, \"Multicall3: call failed\");\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Backwards-compatible with Multicall2\n    /// @notice Aggregate calls and allow failures using tryAggregate\n    /// @param calls An array of Call structs\n    /// @return blockNumber The block number where the calls were executed\n    /// @return blockHash The hash of the block where the calls were executed\n    /// @return returnData An array of Result structs\n    function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls)\n        public\n        payable\n        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData)\n    {\n        blockNumber = block.number;\n        blockHash = blockhash(block.number);\n        returnData = tryAggregate(requireSuccess, calls);\n    }\n\n    /// @notice Backwards-compatible with Multicall2\n    /// @notice Aggregate calls and allow failures using tryAggregate\n    /// @param calls An array of Call structs\n    /// @return blockNumber The block number where the calls were executed\n    /// @return blockHash The hash of the block where the calls were executed\n    /// @return returnData An array of Result structs\n    function blockAndAggregate(Call[] calldata calls)\n        public\n        payable\n        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData)\n    {\n        (blockNumber, blockHash, returnData) = tryBlockAndAggregate(true, calls);\n    }\n\n    /// @notice Aggregate calls, ensuring each returns success if required\n    /// @param calls An array of Call3 structs\n    /// @return returnData An array of Result structs\n    function aggregate3(Call3[] calldata calls) public payable returns (Result[] memory returnData) {\n        uint256 length = calls.length;\n        returnData = new Result[](length);\n        Call3 calldata calli;\n        for (uint256 i = 0; i < length;) {\n            Result memory result = returnData[i];\n            calli = calls[i];\n            (result.success, result.returnData) = calli.target.call(calli.callData);\n            assembly {\n                // Revert if the call fails and failure is not allowed\n                // `allowFailure := calldataload(add(calli, 0x20))` and `success := mload(result)`\n                if iszero(or(calldataload(add(calli, 0x20)), mload(result))) {\n                    // set \"Error(string)\" signature: bytes32(bytes4(keccak256(\"Error(string)\")))\n                    mstore(0x00, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n                    // set data offset\n                    mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\n                    // set length of revert string\n                    mstore(0x24, 0x0000000000000000000000000000000000000000000000000000000000000017)\n                    // set revert string: bytes32(abi.encodePacked(\"Multicall3: call failed\"))\n                    mstore(0x44, 0x4d756c746963616c6c333a2063616c6c206661696c6564000000000000000000)\n                    revert(0x00, 0x64)\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Aggregate calls with a msg value\n    /// @notice Reverts if msg.value is less than the sum of the call values\n    /// @param calls An array of Call3Value structs\n    /// @return returnData An array of Result structs\n    function aggregate3Value(Call3Value[] calldata calls) public payable returns (Result[] memory returnData) {\n        uint256 valAccumulator;\n        uint256 length = calls.length;\n        returnData = new Result[](length);\n        Call3Value calldata calli;\n        for (uint256 i = 0; i < length;) {\n            Result memory result = returnData[i];\n            calli = calls[i];\n            uint256 val = calli.value;\n            // Humanity will be a Type V Kardashev Civilization before this overflows - andreas\n            // ~ 10^25 Wei in existence << ~ 10^76 size uint fits in a uint256\n            unchecked {\n                valAccumulator += val;\n            }\n            (result.success, result.returnData) = calli.target.call{value: val}(calli.callData);\n            assembly {\n                // Revert if the call fails and failure is not allowed\n                // `allowFailure := calldataload(add(calli, 0x20))` and `success := mload(result)`\n                if iszero(or(calldataload(add(calli, 0x20)), mload(result))) {\n                    // set \"Error(string)\" signature: bytes32(bytes4(keccak256(\"Error(string)\")))\n                    mstore(0x00, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n                    // set data offset\n                    mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\n                    // set length of revert string\n                    mstore(0x24, 0x0000000000000000000000000000000000000000000000000000000000000017)\n                    // set revert string: bytes32(abi.encodePacked(\"Multicall3: call failed\"))\n                    mstore(0x44, 0x4d756c746963616c6c333a2063616c6c206661696c6564000000000000000000)\n                    revert(0x00, 0x84)\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        // Finally, make sure the msg.value = SUM(call[0...i].value)\n        require(msg.value == valAccumulator, \"Multicall3: value mismatch\");\n    }\n\n    /// @notice Returns the block hash for the given block number\n    /// @param blockNumber The block number\n    function getBlockHash(uint256 blockNumber) public view returns (bytes32 blockHash) {\n        blockHash = blockhash(blockNumber);\n    }\n\n    /// @notice Returns the block number\n    function getBlockNumber() public view returns (uint256 blockNumber) {\n        blockNumber = block.number;\n    }\n\n    /// @notice Returns the block coinbase\n    function getCurrentBlockCoinbase() public view returns (address coinbase) {\n        coinbase = block.coinbase;\n    }\n\n    /// @notice Returns the block difficulty\n    function getCurrentBlockDifficulty() public view returns (uint256 difficulty) {\n        difficulty = block.difficulty;\n    }\n\n    /// @notice Returns the block gas limit\n    function getCurrentBlockGasLimit() public view returns (uint256 gaslimit) {\n        gaslimit = block.gaslimit;\n    }\n\n    /// @notice Returns the block timestamp\n    function getCurrentBlockTimestamp() public view returns (uint256 timestamp) {\n        timestamp = block.timestamp;\n    }\n\n    /// @notice Returns the (ETH) balance of a given address\n    function getEthBalance(address addr) public view returns (uint256 balance) {\n        balance = addr.balance;\n    }\n\n    /// @notice Returns the block hash of the last block\n    function getLastBlockHash() public view returns (bytes32 blockHash) {\n        unchecked {\n            blockHash = blockhash(block.number - 1);\n        }\n    }\n\n    /// @notice Gets the base fee of the given block\n    /// @notice Can revert if the BASEFEE opcode is not implemented by the given chain\n    function getBasefee() public view returns (uint256 basefee) {\n        basefee = block.basefee;\n    }\n\n    /// @notice Returns the chain id\n    function getChainId() public view returns (uint256 chainid) {\n        chainid = block.chainid;\n    }\n}\n"
        },
        "script/exchange/BlastTestnet.s.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"forge-std/Script.sol\";\nimport {console} from \"forge-std/console.sol\";\nimport {MockBTC} from \"../../contracts/mock/MockBTC.sol\";\nimport {SABT} from \"../../contracts/sabt/SABT.sol\";\nimport {BlockAccountant} from \"../../contracts/sabt/BlockAccountant.sol\";\nimport {Membership} from \"../../contracts/sabt/Membership.sol\";\nimport {Treasury} from \"../../contracts/sabt/Treasury.sol\";\nimport {MockToken} from \"../../contracts/mock/MockToken.sol\";\nimport {MatchingEngine} from \"../../contracts/safex/MatchingEngine.sol\";\nimport {OrderbookFactory} from \"../../contracts/safex/orderbooks/OrderbookFactory.sol\";\nimport {Orderbook} from \"../../contracts/safex/orderbooks/Orderbook.sol\";\nimport {Multicall3} from \"../Multicall3.sol\";\nimport {TokenDispenser} from \"../../contracts/safex/airdrops/TokenDispenser.sol\";\nimport {ExchangeOrderbook} from \"../../contracts/safex/libraries/ExchangeOrderbook.sol\";\nimport {TransferHelper} from \"../../contracts/safex/libraries/TransferHelper.sol\";\n\ncontract Deployer is Script {\n    function _setDeployer() internal {\n        uint256 deployerPrivateKey = vm.envUint(\"LINEA_TESTNET_DEPLOYER_KEY\");\n        vm.startBroadcast(deployerPrivateKey);\n    }\n}\n\ncontract DeployMulticall3 is Deployer {\n    function run() external {\n        _setDeployer();\n        new Multicall3();\n        vm.stopBroadcast();\n    }\n}\n\ncontract DeployWETH is Deployer {\n    function run() external {\n        _setDeployer();\n        vm.stopBroadcast();\n    }\n}\n\ncontract DeploySAFEXMainnetContracts is Deployer {\n    // Change address constants on deploying to other networks from DeployAssets\n    /// Second per block to finalize\n    uint32 constant spb = 2;\n    address constant deployer_address =\n        0x34CCCa03631830cD8296c172bf3c31e126814ce9;\n    address constant foundation_address =\n        0x34CCCa03631830cD8296c172bf3c31e126814ce9;\n    address constant weth = 0x4200000000000000000000000000000000000023;\n\n    Treasury public treasury;\n\n    function run() external {\n        _setDeployer();\n        OrderbookFactory orderbookFactory = new OrderbookFactory();\n        MatchingEngine matchingEngine = new MatchingEngine();\n        treasury = new Treasury();\n        \n        matchingEngine.initialize(\n            address(orderbookFactory),\n            address(treasury),\n            address(weth)\n        );\n        \n        orderbookFactory.initialize(address(matchingEngine));\n        vm.stopBroadcast();\n    }\n}\n\ncontract DeploySABTMainnetContracts is Deployer {\n    Treasury constant treasury =\n        Treasury(0xAF70BD3B32f70206a17DfdBe66529917E2Bf8c7B);\n    uint32 constant spb = 12;\n    address constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // weth on mainnet\n    address constant stablecoin = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48; // usdc on mainnet\n    address constant matchingEngine =\n        0x677B1CA9ACb800f7b40C89ef9BB441f79A7363f0;\n    address constant foundation_address =\n        0x34CCCa03631830cD8296c172bf3c31e126814ce9;\n\n    function run() external {\n        Membership membership = new Membership();\n        SABT sabt = new SABT();\n        membership.initialize(address(sabt), foundation_address, weth);\n        sabt.initialize(address(membership));\n        // Setup accountant and treasury\n        BlockAccountant accountant = new BlockAccountant();\n        accountant.initialize(\n            address(membership),\n            address(matchingEngine),\n            address(stablecoin),\n            spb\n        );\n        treasury.set(address(membership), address(accountant), address(sabt));\n        // Wire up matching engine with them\n        accountant.grantRole(accountant.REPORTER_ROLE(), address(treasury));\n        treasury.grantRole(treasury.REPORTER_ROLE(), address(matchingEngine));\n    }\n}\n\ncontract DeployTokenDispenser is Deployer {\n    function run() external {\n        _setDeployer();\n        TokenDispenser dispenser = new TokenDispenser();\n        vm.stopBroadcast();\n    }\n}\n\ncontract AddAirdrop is Deployer {\n    address constant airdrop_token_address =\n        0xE57Cdf5796C2f5281EDF1B81129E1D4Ff9190815;\n    address constant dispenser_address =\n        0xA8800c10F7276E2cfe025aAc849b812A2eC601fF;\n    address constant deployer_address =\n        0x34CCCa03631830cD8296c172bf3c31e126814ce9;\n    MockToken public airdropToken = MockToken(airdrop_token_address);\n    TokenDispenser public dispenser = TokenDispenser(dispenser_address);\n    uint256 public deposit_amount = 1e40;\n    uint256 public airdrop_amount = 100000e18;\n\n    function run() external {\n        _setDeployer();\n        airdropToken.mint(deployer_address, deposit_amount);\n        airdropToken.transfer(dispenser_address, deposit_amount);\n        dispenser.setTokenAmount(airdrop_token_address, airdrop_amount);\n        vm.stopBroadcast();\n    }\n}\n\ncontract TestOrderbookSell is Deployer {\n    // Change address constants on deploying to other networks from DeployAssets\n    address constant matching_engine_address =\n        0x677B1CA9ACb800f7b40C89ef9BB441f79A7363f0;\n    address constant base_addr = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address constant quote_addr = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n    MatchingEngine public matchingEngine =\n        MatchingEngine(payable(matching_engine_address));\n    MockToken public base = MockToken(base_addr);\n    MockToken public quote = MockToken(quote_addr);\n    Orderbook public book;\n    uint256 price = 100000e6;\n\n    function run() external {\n        _setDeployer();\n\n        book = Orderbook(\n            payable(matchingEngine.getPair(address(base), address(quote)))\n        );\n\n        // make a price in matching engine where 1 feeToken = 1000 stablecoin with buy and sell order\n        base.approve(address(matchingEngine), 100000e18);\n        quote.approve(address(matchingEngine), 100000000e18);\n        // add limit orders\n        matchingEngine.limitSell(\n            address(base),\n            address(quote),\n            price,\n            10000e18,\n            true,\n            1,\n            0,\n            msg.sender\n        );\n        //matchingEngine.getOrders(address(token1), address(token2), true, 0, 0);\n        uint256[] memory askPrices = matchingEngine.getPrices(\n            address(base),\n            address(quote),\n            false,\n            20\n        );\n        console.log(\"Bid prices: \");\n        for (uint256 i = 0; i < 3; i++) {\n            console.log(askPrices[i]);\n        }\n        (uint256 bidHead, uint256 askHead) = book.heads();\n        console.log(\"bidHead: \", bidHead);\n        console.log(\"askHead: \", askHead);\n        vm.stopBroadcast();\n    }\n}\n\ncontract TestOrderbookBuy is Deployer {\n    // Change address constants on deploying to other networks from DeployAssets\n    address constant matching_engine_address =\n        0x677B1CA9ACb800f7b40C89ef9BB441f79A7363f0;\n    address constant base_addr = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address constant quote_addr = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n    MatchingEngine public matchingEngine =\n        MatchingEngine(payable(matching_engine_address));\n    MockToken public base = MockToken(base_addr);\n    MockToken public quote = MockToken(quote_addr);\n    Orderbook public book;\n    uint256 price = 161498000000;\n\n    function run() external {\n        _setDeployer();\n\n        book = Orderbook(\n            payable(matchingEngine.getPair(address(base), address(quote)))\n        );\n\n        // make a price in matching engine where 1 feeToken = 1000 stablecoin with buy and sell order\n        base.approve(address(matchingEngine), 100000e18);\n\n        TransferHelper.safeApprove(address(quote), address(matchingEngine), 10000000000);\n        // add limit orders\n        matchingEngine.limitBuy(\n            address(base),\n            address(quote),\n            price,\n            1000000,\n            true,\n            5,\n            0,\n            msg.sender\n        );\n        //matchingEngine.getOrders(address(token1), address(token2), true, 0, 0);\n        uint256[] memory askPrices = matchingEngine.getPrices(\n            address(base),\n            address(quote),\n            false,\n            20\n        );\n        console.log(\"Bid prices: \");\n        for (uint256 i = 0; i < 3; i++) {\n            console.log(askPrices[i]);\n        }\n        (uint256 bidHead, uint256 askHead) = book.heads();\n        console.log(\"bidHead: \", bidHead);\n        console.log(\"askHead: \", askHead);\n        vm.stopBroadcast();\n    }\n}\n\ncontract TestGetPrices is Deployer {\n    // Change address constants on deploying to other networks from DeployAssets\n    address constant matching_engine_address =\n        0x677B1CA9ACb800f7b40C89ef9BB441f79A7363f0;\n    address constant feeToken_address =\n        0xE57Cdf5796C2f5281EDF1B81129E1D4Ff9190815;\n    address constant stablecoin_address =\n        0xfB4c8b2658AB2bf32ab5Fc1627f115974B52FeA7;\n    MatchingEngine public matchingEngine =\n        MatchingEngine(payable(matching_engine_address));\n    MockToken public feeToken = MockToken(feeToken_address);\n    MockToken public stablecoin = MockToken(stablecoin_address);\n\n    function run() external {\n        _setDeployer();\n\n        uint256[] memory bidPrices = matchingEngine.getPrices(\n            address(feeToken),\n            address(stablecoin),\n            true,\n            20\n        );\n        console.log(\"Ask prices: \");\n        for (uint256 i = 0; i < 4; i++) {\n            console.log(bidPrices[i]);\n        }\n        //matchingEngine.getOrders(address(token1), address(token2), true, 0, 0);\n        uint256[] memory askPrices = matchingEngine.getPrices(\n            address(feeToken),\n            address(stablecoin),\n            false,\n            20\n        );\n        console.log(\"Bid prices: \");\n        for (uint256 i = 0; i < 3; i++) {\n            console.log(askPrices[i]);\n        }\n\n        vm.stopBroadcast();\n    }\n}\n\ncontract ShowOrderbook is Deployer {\n    address constant token1 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address constant token2 = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n    MatchingEngine matchingEngine =\n        MatchingEngine(payable(0x677B1CA9ACb800f7b40C89ef9BB441f79A7363f0));\n\n    function _showOrderbook(\n        MatchingEngine matchingEngine,\n        address base,\n        address quote\n    ) internal view {\n        (uint256 bidHead, uint256 askHead) = matchingEngine.heads(base, quote);\n        console.log(\"Bid Head: \", bidHead);\n        console.log(\"Ask Head: \", askHead);\n        uint256[] memory bidPrices = matchingEngine.getPrices(\n            address(token1),\n            address(token2),\n            true,\n            20\n        );\n        uint256[] memory askPrices = matchingEngine.getPrices(\n            address(token1),\n            address(token2),\n            false,\n            20\n        );\n        console.log(\"Ask prices: \");\n        for (uint256 i = 0; i < 3; i++) {\n            console.log(askPrices[i]);\n        }\n        console.log(\"Ask Orders: \");\n        for (uint256 i = 0; i < askPrices.length; i++) {\n            console.log(\"Ask price: \", askPrices[i]);\n            ExchangeOrderbook.Order[] memory askOrders = matchingEngine\n                .getOrders(\n                    address(token1),\n                    address(token2),\n                    false,\n                    askPrices[i],\n                    10\n                );\n            for (uint256 j = 0; j < 10; j++) {\n                console.log(askOrders[j].owner, askOrders[j].depositAmount);\n            }\n        }\n        console.log(\"Bid prices: \");\n        for (uint256 i = 0; i < 4; i++) {\n            console.log(bidPrices[i]);\n        }\n        console.log(\"Bid Orders: \");\n        for (uint256 i = 0; i < bidPrices.length; i++) {\n            console.log(\"Bid price: \", bidPrices[i]);\n            ExchangeOrderbook.Order[] memory bidOrders = matchingEngine\n                .getOrders(\n                    address(token1),\n                    address(token2),\n                    true,\n                    bidPrices[i],\n                    10\n                );\n            for (uint256 j = 0; j < 10; j++) {\n                console.log(bidOrders[j].owner, bidOrders[j].depositAmount);\n            }\n        }\n    }\n\n    function run() external {\n        _setDeployer();\n        _showOrderbook(matchingEngine, address(token1), address(token2));\n        vm.stopBroadcast();\n    }\n}\n"
        },
        "script/exchange/Ethereum.s.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"forge-std/Script.sol\";\nimport {console} from \"forge-std/console.sol\";\nimport {MockBTC} from \"../../contracts/mock/MockBTC.sol\";\nimport {SABT} from \"../../contracts/sabt/SABT.sol\";\nimport {BlockAccountant} from \"../../contracts/sabt/BlockAccountant.sol\";\nimport {Membership} from \"../../contracts/sabt/Membership.sol\";\nimport {Treasury} from \"../../contracts/sabt/Treasury.sol\";\nimport {MockToken} from \"../../contracts/mock/MockToken.sol\";\nimport {MatchingEngine} from \"../../contracts/safex/MatchingEngine.sol\";\nimport {OrderbookFactory} from \"../../contracts/safex/orderbooks/OrderbookFactory.sol\";\nimport {Orderbook} from \"../../contracts/safex/orderbooks/Orderbook.sol\";\nimport {Multicall3} from \"../Multicall3.sol\";\nimport {TokenDispenser} from \"../../contracts/safex/airdrops/TokenDispenser.sol\";\nimport {ExchangeOrderbook} from \"../../contracts/safex/libraries/ExchangeOrderbook.sol\";\nimport {TransferHelper} from \"../../contracts/safex/libraries/TransferHelper.sol\";\n\ncontract Deployer is Script {\n    function _setDeployer() internal {\n        uint256 deployerPrivateKey = vm.envUint(\"LINEA_TESTNET_DEPLOYER_KEY\");\n        vm.startBroadcast(deployerPrivateKey);\n    }\n}\n\ncontract DeployMulticall3 is Deployer {\n    function run() external {\n        _setDeployer();\n        new Multicall3();\n        vm.stopBroadcast();\n    }\n}\n\ncontract DeployWETH is Deployer {\n    function run() external {\n        _setDeployer();\n        vm.stopBroadcast();\n    }\n}\n\ncontract DeploySAFEXMainnetContracts is Deployer {\n    // Change address constants on deploying to other networks from DeployAssets\n    /// Second per block to finalize\n    uint32 constant spb = 12;\n    address constant deployer_address =\n        0x34CCCa03631830cD8296c172bf3c31e126814ce9;\n    address constant foundation_address =\n        0x34CCCa03631830cD8296c172bf3c31e126814ce9;\n    address constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    Treasury public treasury;\n\n    function run() external {\n        _setDeployer();\n        OrderbookFactory orderbookFactory = new OrderbookFactory();\n        MatchingEngine matchingEngine = new MatchingEngine();\n        treasury = new Treasury();\n        \n        matchingEngine.initialize(\n            address(orderbookFactory),\n            address(treasury),\n            address(weth)\n        );\n        \n        orderbookFactory.initialize(address(matchingEngine));\n        vm.stopBroadcast();\n    }\n}\n\ncontract DeploySABTMainnetContracts is Deployer {\n    Treasury constant treasury =\n        Treasury(0xAF70BD3B32f70206a17DfdBe66529917E2Bf8c7B);\n    uint32 constant spb = 12;\n    address constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // weth on mainnet\n    address constant stablecoin = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48; // usdc on mainnet\n    address constant matchingEngine =\n        0x677B1CA9ACb800f7b40C89ef9BB441f79A7363f0;\n    address constant foundation_address =\n        0x34CCCa03631830cD8296c172bf3c31e126814ce9;\n\n    function run() external {\n        Membership membership = new Membership();\n        SABT sabt = new SABT();\n        membership.initialize(address(sabt), foundation_address, weth);\n        sabt.initialize(address(membership));\n        // Setup accountant and treasury\n        BlockAccountant accountant = new BlockAccountant();\n        accountant.initialize(\n            address(membership),\n            address(matchingEngine),\n            address(stablecoin),\n            spb\n        );\n        treasury.set(address(membership), address(accountant), address(sabt));\n        // Wire up matching engine with them\n        accountant.grantRole(accountant.REPORTER_ROLE(), address(treasury));\n        treasury.grantRole(treasury.REPORTER_ROLE(), address(matchingEngine));\n    }\n}\n\ncontract DeployTokenDispenser is Deployer {\n    function run() external {\n        _setDeployer();\n        TokenDispenser dispenser = new TokenDispenser();\n        vm.stopBroadcast();\n    }\n}\n\ncontract AddAirdrop is Deployer {\n    address constant airdrop_token_address =\n        0xE57Cdf5796C2f5281EDF1B81129E1D4Ff9190815;\n    address constant dispenser_address =\n        0xA8800c10F7276E2cfe025aAc849b812A2eC601fF;\n    address constant deployer_address =\n        0x34CCCa03631830cD8296c172bf3c31e126814ce9;\n    MockToken public airdropToken = MockToken(airdrop_token_address);\n    TokenDispenser public dispenser = TokenDispenser(dispenser_address);\n    uint256 public deposit_amount = 1e40;\n    uint256 public airdrop_amount = 100000e18;\n\n    function run() external {\n        _setDeployer();\n        airdropToken.mint(deployer_address, deposit_amount);\n        airdropToken.transfer(dispenser_address, deposit_amount);\n        dispenser.setTokenAmount(airdrop_token_address, airdrop_amount);\n        vm.stopBroadcast();\n    }\n}\n\ncontract TestOrderbookSell is Deployer {\n    // Change address constants on deploying to other networks from DeployAssets\n    address constant matching_engine_address =\n        0x677B1CA9ACb800f7b40C89ef9BB441f79A7363f0;\n    address constant base_addr = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address constant quote_addr = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n    MatchingEngine public matchingEngine =\n        MatchingEngine(payable(matching_engine_address));\n    MockToken public base = MockToken(base_addr);\n    MockToken public quote = MockToken(quote_addr);\n    Orderbook public book;\n    uint256 price = 100000e6;\n\n    function run() external {\n        _setDeployer();\n\n        book = Orderbook(\n            payable(matchingEngine.getPair(address(base), address(quote)))\n        );\n\n        // make a price in matching engine where 1 feeToken = 1000 stablecoin with buy and sell order\n        base.approve(address(matchingEngine), 100000e18);\n        quote.approve(address(matchingEngine), 100000000e18);\n        // add limit orders\n        matchingEngine.limitSell(\n            address(base),\n            address(quote),\n            price,\n            10000e18,\n            true,\n            1,\n            0,\n            msg.sender\n        );\n        //matchingEngine.getOrders(address(token1), address(token2), true, 0, 0);\n        uint256[] memory askPrices = matchingEngine.getPrices(\n            address(base),\n            address(quote),\n            false,\n            20\n        );\n        console.log(\"Bid prices: \");\n        for (uint256 i = 0; i < 3; i++) {\n            console.log(askPrices[i]);\n        }\n        (uint256 bidHead, uint256 askHead) = book.heads();\n        console.log(\"bidHead: \", bidHead);\n        console.log(\"askHead: \", askHead);\n        vm.stopBroadcast();\n    }\n}\n\ncontract TestOrderbookBuy is Deployer {\n    // Change address constants on deploying to other networks from DeployAssets\n    address constant matching_engine_address =\n        0x677B1CA9ACb800f7b40C89ef9BB441f79A7363f0;\n    address constant base_addr = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address constant quote_addr = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n    MatchingEngine public matchingEngine =\n        MatchingEngine(payable(matching_engine_address));\n    MockToken public base = MockToken(base_addr);\n    MockToken public quote = MockToken(quote_addr);\n    Orderbook public book;\n    uint256 price = 161498000000;\n\n    function run() external {\n        _setDeployer();\n\n        book = Orderbook(\n            payable(matchingEngine.getPair(address(base), address(quote)))\n        );\n\n        // make a price in matching engine where 1 feeToken = 1000 stablecoin with buy and sell order\n        base.approve(address(matchingEngine), 100000e18);\n\n        TransferHelper.safeApprove(address(quote), address(matchingEngine), 10000000000);\n        // add limit orders\n        matchingEngine.limitBuy(\n            address(base),\n            address(quote),\n            price,\n            1000000,\n            true,\n            5,\n            0,\n            msg.sender\n        );\n        //matchingEngine.getOrders(address(token1), address(token2), true, 0, 0);\n        uint256[] memory askPrices = matchingEngine.getPrices(\n            address(base),\n            address(quote),\n            false,\n            20\n        );\n        console.log(\"Bid prices: \");\n        for (uint256 i = 0; i < 3; i++) {\n            console.log(askPrices[i]);\n        }\n        (uint256 bidHead, uint256 askHead) = book.heads();\n        console.log(\"bidHead: \", bidHead);\n        console.log(\"askHead: \", askHead);\n        vm.stopBroadcast();\n    }\n}\n\ncontract TestGetPrices is Deployer {\n    // Change address constants on deploying to other networks from DeployAssets\n    address constant matching_engine_address =\n        0x677B1CA9ACb800f7b40C89ef9BB441f79A7363f0;\n    address constant feeToken_address =\n        0xE57Cdf5796C2f5281EDF1B81129E1D4Ff9190815;\n    address constant stablecoin_address =\n        0xfB4c8b2658AB2bf32ab5Fc1627f115974B52FeA7;\n    MatchingEngine public matchingEngine =\n        MatchingEngine(payable(matching_engine_address));\n    MockToken public feeToken = MockToken(feeToken_address);\n    MockToken public stablecoin = MockToken(stablecoin_address);\n\n    function run() external {\n        _setDeployer();\n\n        uint256[] memory bidPrices = matchingEngine.getPrices(\n            address(feeToken),\n            address(stablecoin),\n            true,\n            20\n        );\n        console.log(\"Ask prices: \");\n        for (uint256 i = 0; i < 4; i++) {\n            console.log(bidPrices[i]);\n        }\n        //matchingEngine.getOrders(address(token1), address(token2), true, 0, 0);\n        uint256[] memory askPrices = matchingEngine.getPrices(\n            address(feeToken),\n            address(stablecoin),\n            false,\n            20\n        );\n        console.log(\"Bid prices: \");\n        for (uint256 i = 0; i < 3; i++) {\n            console.log(askPrices[i]);\n        }\n\n        vm.stopBroadcast();\n    }\n}\n\ncontract ShowOrderbook is Deployer {\n    address constant token1 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address constant token2 = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n    MatchingEngine matchingEngine =\n        MatchingEngine(payable(0x677B1CA9ACb800f7b40C89ef9BB441f79A7363f0));\n\n    function _showOrderbook(\n        MatchingEngine matchingEngine,\n        address base,\n        address quote\n    ) internal view {\n        (uint256 bidHead, uint256 askHead) = matchingEngine.heads(base, quote);\n        console.log(\"Bid Head: \", bidHead);\n        console.log(\"Ask Head: \", askHead);\n        uint256[] memory bidPrices = matchingEngine.getPrices(\n            address(token1),\n            address(token2),\n            true,\n            20\n        );\n        uint256[] memory askPrices = matchingEngine.getPrices(\n            address(token1),\n            address(token2),\n            false,\n            20\n        );\n        console.log(\"Ask prices: \");\n        for (uint256 i = 0; i < 3; i++) {\n            console.log(askPrices[i]);\n        }\n        console.log(\"Ask Orders: \");\n        for (uint256 i = 0; i < askPrices.length; i++) {\n            console.log(\"Ask price: \", askPrices[i]);\n            ExchangeOrderbook.Order[] memory askOrders = matchingEngine\n                .getOrders(\n                    address(token1),\n                    address(token2),\n                    false,\n                    askPrices[i],\n                    10\n                );\n            for (uint256 j = 0; j < 10; j++) {\n                console.log(askOrders[j].owner, askOrders[j].depositAmount);\n            }\n        }\n        console.log(\"Bid prices: \");\n        for (uint256 i = 0; i < 4; i++) {\n            console.log(bidPrices[i]);\n        }\n        console.log(\"Bid Orders: \");\n        for (uint256 i = 0; i < bidPrices.length; i++) {\n            console.log(\"Bid price: \", bidPrices[i]);\n            ExchangeOrderbook.Order[] memory bidOrders = matchingEngine\n                .getOrders(\n                    address(token1),\n                    address(token2),\n                    true,\n                    bidPrices[i],\n                    10\n                );\n            for (uint256 j = 0; j < 10; j++) {\n                console.log(bidOrders[j].owner, bidOrders[j].depositAmount);\n            }\n        }\n    }\n\n    function run() external {\n        _setDeployer();\n        _showOrderbook(matchingEngine, address(token1), address(token2));\n        vm.stopBroadcast();\n    }\n}\n"
        },
        "script/exchange/KucoinCommunityChain.s.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"forge-std/Script.sol\";\nimport {console} from \"forge-std/console.sol\";\nimport {MockBTC} from \"../../contracts/mock/MockBTC.sol\";\nimport {SABT} from \"../../contracts/sabt/SABT.sol\";\nimport {BlockAccountant} from \"../../contracts/sabt/BlockAccountant.sol\";\nimport {Membership} from \"../../contracts/sabt/Membership.sol\";\nimport {Treasury} from \"../../contracts/sabt/Treasury.sol\";\nimport {MockToken} from \"../../contracts/mock/MockToken.sol\";\nimport {MatchingEngine} from \"../../contracts/safex/MatchingEngine.sol\";\nimport {OrderbookFactory} from \"../../contracts/safex/orderbooks/OrderbookFactory.sol\";\nimport {Multicall3} from \"../Multicall3.sol\";\n\ncontract Deployer is Script {\n    function _setDeployer() internal {\n        uint256 deployerPrivateKey = vm.envUint(\"LINEA_TESTNET_DEPLOYER_KEY\");\n        vm.startBroadcast(deployerPrivateKey);\n    }\n}\n\ncontract DeployMulticall3 is Deployer {\n    function run() external {\n        _setDeployer();\n        new Multicall3();\n        vm.stopBroadcast();\n    }\n}\n\ncontract DeployWETH is Deployer {\n    function run() external {\n        _setDeployer();\n        vm.stopBroadcast();\n    }\n}\n\ncontract DeployTestnetAssetsAndContracts is Deployer {\n    // Change address constants on deploying to other networks from DeployAssets\n    /// Second per block to finalize\n    uint32 constant spb = 3;\n    address constant deployer_address = 0x34CCCa03631830cD8296c172bf3c31e126814ce9;\n    address constant foundation_address = 0x34CCCa03631830cD8296c172bf3c31e126814ce9;\n    address constant weth = 0x2C1b868d6596a18e32E61B901E4060C872647b6C;\n    Treasury public treasury;\n\n    function run() external {\n        _setDeployer();\n        MockToken feeToken = new MockToken(\"Standard\", \"STND\");\n        MockToken stablecoin = new MockToken(\"Stablecoin\", \"STBC\");\n        OrderbookFactory orderbookFactory = new OrderbookFactory();\n        MatchingEngine matchingEngine = new MatchingEngine();\n        Membership membership = new Membership();\n        SABT sabt = new SABT();\n        membership.initialize(address(sabt), foundation_address, weth);\n        sabt.initialize(address(membership));\n        // Setup accountant and treasury\n        BlockAccountant accountant = new BlockAccountant();\n        accountant.initialize(address(membership), address(matchingEngine), address(stablecoin), spb);\n        treasury = new Treasury();\n        treasury.set(address(membership), address(accountant), address(sabt));\n        matchingEngine.initialize(\n            address(orderbookFactory), address(treasury), weth\n        );\n        orderbookFactory.initialize(address(matchingEngine));\n        // Wire up matching engine with them\n        accountant.grantRole(\n            accountant.REPORTER_ROLE(),\n            address(treasury)\n        );\n        treasury.grantRole(treasury.REPORTER_ROLE(), address(matchingEngine));\n        vm.stopBroadcast();\n    }\n}\n\ncontract DistributeTestnetAssets is Deployer {\n    // Change address constants on deploying to other networks from DeployAssets\n    address constant deployer_address = 0x34CCCa03631830cD8296c172bf3c31e126814ce9;\n    address constant trader1_address = 0x6408fb579e106fC59f964eC33FE123738A2D0Da3;\n    address constant trader2_address = 0xf5aE3B9dF4e6972a229E7915D55F9FBE5900fE95;\n    address constant feeToken_address = 0xf3Db341c6001916121EB46eD669D08aDC7FF37e1;\n    address constant stablecoin_address = 0x4c5ecfF8f637BE60F093808babcd03b78170b828;\n\n    MockToken public feeToken = MockToken(feeToken_address);\n    MockToken public stablecoin = MockToken(stablecoin_address);\n\n    function run() external {\n        _setDeployer();\n        // Mint fee Token to the deployer, trader1, trader2\n        feeToken.mint(deployer_address, 1000000000000000000000000e18);\n        feeToken.mint(trader1_address, 100000e18);\n        feeToken.mint(trader2_address, 100000e18);\n\n        // Mint stablecoin to the deployer, trader1, trader2\n        stablecoin.mint(deployer_address, 100000e18);\n        stablecoin.mint(trader1_address, 100000e18);\n        stablecoin.mint(trader2_address, 100000e18);\n\n        vm.stopBroadcast();\n    }\n}\n\ncontract SetupSABTInitialParameters is Deployer {\n    // Change address constants on deploying to other networks from DeployAssets\n    address constant matching_engine_address = 0xa02d713DEBba20c8f81b35576A78D66Ef4E2f868;\n    address constant membership_address = 0x677B1CA9ACb800f7b40C89ef9BB441f79A7363f0;\n    address constant sabt_address = 0xf530A05B56bC6ed33F648F947FB749A8943f8dce;\n    address constant stablecoin_address = 0x4c5ecfF8f637BE60F093808babcd03b78170b828;\n    address constant feeToken_address = 0xf3Db341c6001916121EB46eD669D08aDC7FF37e1;\n    address constant block_accountant_address = 0x795367C6e4F0533273a9f5dc0Cd3a74B0b9c216f;\n    address constant treasury_address = 0xD840324346f137A8D34acBcC0475dd49e7621c55;\n    address constant deployer_address = 0x34CCCa03631830cD8296c172bf3c31e126814ce9;\n\n    Membership public membership = Membership(membership_address);\n    SABT public sabt = SABT(sabt_address);\n    MockToken public stablecoin = MockToken(stablecoin_address);\n    MockToken public feeToken = MockToken(feeToken_address);\n    BlockAccountant public accountant = BlockAccountant(block_accountant_address);\n    Treasury public treasury = Treasury(treasury_address);\n\n    function run() external {\n        _setDeployer();\n        // set Fee in membership contract\n        membership.setMembership(1, feeToken_address, 1000, 1000, 10000);\n\n        // Get membership\n        feeToken.approve(membership_address, 1e30);\n        membership.register(1, feeToken_address);\n        membership.subscribe(1, 100000, feeToken_address);\n\n        vm.stopBroadcast();\n    }\n}\n\ncontract SetupSAFEXInitialParameters is Deployer {\n    // Change address constants on deploying to other networks from DeployAssets\n    address constant matching_engine_address = 0xa02d713DEBba20c8f81b35576A78D66Ef4E2f868;\n    address constant feeToken_address = 0xf3Db341c6001916121EB46eD669D08aDC7FF37e1;\n    address constant stablecoin_address = 0x4c5ecfF8f637BE60F093808babcd03b78170b828;\n    MatchingEngine public matchingEngine = MatchingEngine(payable(matching_engine_address));\n    MockToken public feeToken = MockToken(feeToken_address);\n    MockToken public stablecoin = MockToken(stablecoin_address);\n\n    function run() external {\n        _setDeployer();\n        // Setup pair between stablecoin and feeToken with price\n        feeToken.approve(address(matchingEngine), 100000e18);\n        matchingEngine.addPair(address(feeToken), address(stablecoin));\n\n        // make a price in matching engine where 1 feeToken = 1000 stablecoin with buy and sell order\n        feeToken.approve(address(matchingEngine), 100000e18);\n        stablecoin.approve(address(matchingEngine), 100000e18);\n        // add limit orders\n        matchingEngine.limitSell(address(feeToken), address(stablecoin), 1000e8, 10000e18, true, 1, 0, msg.sender);\n        matchingEngine.limitBuy(address(feeToken), address(stablecoin), 1000e8, 10000e18, false, 1, 1, msg.sender);\n        vm.stopBroadcast();\n    }\n}\n\ncontract SetupSAFEXSampleOrders is Deployer {\n    // Change address constants on deploying to other networks from DeployAssets\n    address constant matching_engine_address = 0xa02d713DEBba20c8f81b35576A78D66Ef4E2f868;\n    address constant feeToken_address = 0xf3Db341c6001916121EB46eD669D08aDC7FF37e1;\n    address constant stablecoin_address = 0x4c5ecfF8f637BE60F093808babcd03b78170b828;\n    MatchingEngine public matchingEngine = MatchingEngine(payable(matching_engine_address));\n    MockToken public feeToken = MockToken(feeToken_address);\n    MockToken public stablecoin = MockToken(stablecoin_address);\n\n    function run() external {\n        _setDeployer();\n        // Setup pair between stablecoin and feeToken with price\n        feeToken.approve(address(matchingEngine), 100000e18);\n\n        // make a price in matching engine where 1 feeToken = 1000 stablecoin with buy and sell order\n        feeToken.approve(address(matchingEngine), 100000e18);\n        stablecoin.approve(address(matchingEngine), 100000e18);\n        // add limit orders\n        matchingEngine.limitSell(address(feeToken), address(stablecoin), 1001e8, 10000e18, true, 1, 0, msg.sender);\n        matchingEngine.limitBuy(address(feeToken), address(stablecoin), 999e8, 10000e18, true, 1, 1, msg.sender);\n        vm.stopBroadcast();\n    }\n}\n\ncontract SetupSAFEXSampleOrders2 is Deployer {\n    // Change address constants on deploying to other networks from DeployAssets\n    address constant matching_engine_address = 0xa02d713DEBba20c8f81b35576A78D66Ef4E2f868;\n    address constant feeToken_address = 0xf3Db341c6001916121EB46eD669D08aDC7FF37e1;\n    address constant stablecoin_address = 0x4c5ecfF8f637BE60F093808babcd03b78170b828;\n    MatchingEngine public matchingEngine = MatchingEngine(payable(matching_engine_address));\n    MockToken public feeToken = MockToken(feeToken_address);\n    MockToken public stablecoin = MockToken(stablecoin_address);\n\n    function run() external {\n        _setDeployer();\n        // Setup pair between stablecoin and feeToken with price\n        feeToken.approve(address(matchingEngine), 100000e18);\n\n        // make a price in matching engine where 1 feeToken = 1000 stablecoin with buy and sell order\n        feeToken.approve(address(matchingEngine), 100000e18);\n        stablecoin.approve(address(matchingEngine), 100000e18);\n        matchingEngine.limitBuy(address(feeToken), address(stablecoin), 10000e18, 1000e8, true, 1, 1, msg.sender);\n        vm.stopBroadcast();\n    }\n}\n"
        },
        "script/exchange/Linea.s.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"forge-std/Script.sol\";\nimport {console} from \"forge-std/console.sol\";\nimport {MockBTC} from \"../../contracts/mock/MockBTC.sol\";\nimport {SABT} from \"../../contracts/sabt/SABT.sol\";\nimport {BlockAccountant} from \"../../contracts/sabt/BlockAccountant.sol\";\nimport {Membership} from \"../../contracts/sabt/Membership.sol\";\nimport {Treasury} from \"../../contracts/sabt/Treasury.sol\";\nimport {MockToken} from \"../../contracts/mock/MockToken.sol\";\nimport {MatchingEngine} from \"../../contracts/safex/MatchingEngine.sol\";\nimport {OrderbookFactory} from \"../../contracts/safex/orderbooks/OrderbookFactory.sol\";\nimport {Orderbook} from \"../../contracts/safex/orderbooks/Orderbook.sol\";\nimport {Multicall3} from \"../Multicall3.sol\";\nimport {TokenDispenser} from \"../../contracts/safex/airdrops/TokenDispenser.sol\";\nimport {ExchangeOrderbook} from \"../../contracts/safex/libraries/ExchangeOrderbook.sol\";\n\ncontract Deployer is Script {\n    function _setDeployer() internal {\n        uint256 deployerPrivateKey = vm.envUint(\"LINEA_TESTNET_DEPLOYER_KEY\");\n        vm.startBroadcast(deployerPrivateKey);\n    }\n}\n\ncontract DeployMulticall3 is Deployer {\n    function run() external {\n        _setDeployer();\n        new Multicall3();\n        vm.stopBroadcast();\n    }\n}\n\ncontract DeployWETH is Deployer {\n    function run() external {\n        _setDeployer();\n        vm.stopBroadcast();\n    }\n}\n\ncontract DeploySAFEXMainnetContracts is Deployer {\n    // Change address constants on deploying to other networks from DeployAssets\n    /// Second per block to finalize\n    uint32 constant spb = 12;\n    address constant deployer_address =\n        0x34CCCa03631830cD8296c172bf3c31e126814ce9;\n    address constant foundation_address =\n        0x34CCCa03631830cD8296c172bf3c31e126814ce9;\n    address constant weth = 0xe5D7C2a44FfDDf6b295A15c148167daaAf5Cf34f;\n\n    Treasury public treasury;\n\n    function run() external {\n        _setDeployer();\n        OrderbookFactory orderbookFactory = new OrderbookFactory();\n        MatchingEngine matchingEngine = new MatchingEngine();\n        //treasury = new Treasury();\n        matchingEngine.initialize(\n            address(orderbookFactory),\n            address(0x7a2e3a7A1bf8FaCCAd68115DC509DB5a5af4e7e4),\n            address(weth)\n        );\n        orderbookFactory.initialize(address(matchingEngine));\n        vm.stopBroadcast();\n    }\n}\n\ncontract DeploySABTMainnetContracts is Deployer {\n    Treasury constant treasury =\n        Treasury(0x7a2e3a7A1bf8FaCCAd68115DC509DB5a5af4e7e4);\n    uint32 constant spb = 12;\n    address constant weth = 0xe5D7C2a44FfDDf6b295A15c148167daaAf5Cf34f; // weth on mainnet\n    address constant stablecoin = 0x176211869cA2b568f2A7D4EE941E073a821EE1ff; // usdc on mainnet\n    address constant matchingEngine =\n        0xa2F02d36206EDD2EAE9Fd5FBaBd90CdFCE939614;\n    address constant orderbookFactory =\n        0x73EbE91068d0908cbF51f83B5c7b58824f3Ae69B;\n    address constant foundation_address =\n        0x34CCCa03631830cD8296c172bf3c31e126814ce9;\n\n    function run() external {\n        Membership membership = new Membership();\n        SABT sabt = new SABT();\n        membership.initialize(address(sabt), foundation_address, weth);\n        sabt.initialize(address(membership));\n        // Setup accountant and treasury\n        BlockAccountant accountant = new BlockAccountant();\n        accountant.initialize(\n            address(membership),\n            address(matchingEngine),\n            address(stablecoin),\n            spb\n        );\n        treasury.set(address(membership), address(accountant), address(sabt));\n        // Wire up matching engine with them\n        accountant.grantRole(accountant.REPORTER_ROLE(), address(treasury));\n        treasury.grantRole(treasury.REPORTER_ROLE(), address(matchingEngine));\n    }\n}\n\ncontract DeployTokenDispenser is Deployer {\n    function run() external {\n        _setDeployer();\n        TokenDispenser dispenser = new TokenDispenser();\n        vm.stopBroadcast();\n    }\n}\n\ncontract AddAirdrop is Deployer {\n    address constant airdrop_token_address =\n        0xE57Cdf5796C2f5281EDF1B81129E1D4Ff9190815;\n    address constant dispenser_address =\n        0xA8800c10F7276E2cfe025aAc849b812A2eC601fF;\n    address constant deployer_address =\n        0x34CCCa03631830cD8296c172bf3c31e126814ce9;\n    MockToken public airdropToken = MockToken(airdrop_token_address);\n    TokenDispenser public dispenser = TokenDispenser(dispenser_address);\n    uint256 public deposit_amount = 1e40;\n    uint256 public airdrop_amount = 100000e18;\n\n    function run() external {\n        _setDeployer();\n        airdropToken.mint(deployer_address, deposit_amount);\n        airdropToken.transfer(dispenser_address, deposit_amount);\n        dispenser.setTokenAmount(airdrop_token_address, airdrop_amount);\n        vm.stopBroadcast();\n    }\n}\n\ncontract TestAddPair is Deployer {\n    address constant matching_engine_address =\n        0x99e87D3f46079CeeE33859Fb6055A912090c9683;\n    address constant base_address = 0xA219439258ca9da29E9Cc4cE5596924745e12B93;\n    address constant quote_address = 0xe5D7C2a44FfDDf6b295A15c148167daaAf5Cf34f;\n\n    function run() external {\n        _setDeployer();\n\n        MatchingEngine matchingEngine = MatchingEngine(\n            payable(matching_engine_address)\n        );\n        matchingEngine.addPair(address(base_address), address(quote_address));\n    }\n}\n\ncontract TestOrderbookSell is Deployer {\n    // Change address constants on deploying to other networks from DeployAssets\n    address constant matching_engine_address =\n        0x66a8b38D8B573Dbb6beBe163324b2DC0070d3430;\n    address constant base_address = 0xA219439258ca9da29E9Cc4cE5596924745e12B93;\n    address constant quote_address = 0xe5D7C2a44FfDDf6b295A15c148167daaAf5Cf34f;\n    MatchingEngine public matchingEngine =\n        MatchingEngine(payable(matching_engine_address));\n    MockToken public base = MockToken(base_address);\n    MockToken public quote = MockToken(quote_address);\n    Orderbook public book;\n\n    function run() external {\n        _setDeployer();\n\n        book = Orderbook(\n            payable(matchingEngine.getPair(address(base), address(quote)))\n        );\n\n        // make a price in matching engine where 1 feeToken = 1000 stablecoin with buy and sell order\n        base.approve(address(matchingEngine), 1e18);\n        quote.approve(address(matchingEngine), 1e18);\n\n        matchingEngine.mktPrice(address(base), address(quote));\n        // add limit orders\n        matchingEngine.limitSell(\n            address(base),\n            address(quote),\n            50600,\n            100000,\n            true,\n            1,\n            0,\n            msg.sender\n        );\n        //matchingEngine.getOrders(address(base), address(quote), true, 0, 0);\n        uint256[] memory askPrices = matchingEngine.getPrices(\n            address(base),\n            address(quote),\n            false,\n            20\n        );\n        console.log(\"Bid prices: \");\n        for (uint256 i = 0; i < 3; i++) {\n            console.log(askPrices[i]);\n        }\n        (uint256 bidHead, uint256 askHead) = book.heads();\n        console.log(\"bidHead: \", bidHead);\n        console.log(\"askHead: \", askHead);\n        vm.stopBroadcast();\n    }\n}\n\ncontract TestOrderbookBuy is Deployer {\n    // Change address constants on deploying to other networks from DeployAssets\n    address constant matching_engine_address =\n        0xa2F02d36206EDD2EAE9Fd5FBaBd90CdFCE939614;\n    address constant quote_address = 0xB79DD08EA68A908A97220C76d19A6aA9cBDE4376;\n    address constant base_address = 0xe5D7C2a44FfDDf6b295A15c148167daaAf5Cf34f;\n\n    MatchingEngine public matchingEngine =\n        MatchingEngine(payable(matching_engine_address));\n    MockToken public base = MockToken(base_address);\n    MockToken public quote = MockToken(quote_address);\n    Orderbook public book;\n\n    function run() external {\n        _setDeployer();\n\n        book = Orderbook(\n            payable(matchingEngine.getPair(address(base), address(quote)))\n        );\n\n        // make a price in matching engine where 1 feeToken = 1000 stablecoin with buy and sell order\n        base.approve(address(matchingEngine), 100000e18);\n        quote.approve(address(matchingEngine), 100000000e18);\n\n        matchingEngine.mktPrice(address(base), address(quote));\n        // add limit orders\n        matchingEngine.limitBuy(\n            address(base),\n            address(quote),\n            2234e8,\n            100000,\n            true,\n            1,\n            0,\n            msg.sender\n        );\n        //matchingEngine.getOrders(address(base), address(quote), true, 0, 0);\n        uint256[] memory askPrices = matchingEngine.getPrices(\n            address(base),\n            address(quote),\n            false,\n            20\n        );\n        console.log(\"Bid prices: \");\n        for (uint256 i = 0; i < 3; i++) {\n            console.log(askPrices[i]);\n        }\n        (uint256 bidHead, uint256 askHead) = book.heads();\n        console.log(\"bidHead: \", bidHead);\n        console.log(\"askHead: \", askHead);\n        vm.stopBroadcast();\n    }\n}\n\ncontract TestGetPrices is Deployer {\n    // Change address constants on deploying to other networks from DeployAssets\n    address constant matching_engine_address =\n        0x99e87D3f46079CeeE33859Fb6055A912090c9683;\n    address constant feeToken_address =\n        0xE57Cdf5796C2f5281EDF1B81129E1D4Ff9190815;\n    address constant stablecoin_address =\n        0xfB4c8b2658AB2bf32ab5Fc1627f115974B52FeA7;\n    MatchingEngine public matchingEngine =\n        MatchingEngine(payable(matching_engine_address));\n    MockToken public feeToken = MockToken(feeToken_address);\n    MockToken public stablecoin = MockToken(stablecoin_address);\n\n    function run() external {\n        _setDeployer();\n\n        uint256[] memory bidPrices = matchingEngine.getPrices(\n            address(feeToken),\n            address(stablecoin),\n            true,\n            20\n        );\n        console.log(\"Ask prices: \");\n        for (uint256 i = 0; i < 4; i++) {\n            console.log(bidPrices[i]);\n        }\n        //matchingEngine.getOrders(address(base), address(quote), true, 0, 0);\n        uint256[] memory askPrices = matchingEngine.getPrices(\n            address(feeToken),\n            address(stablecoin),\n            false,\n            20\n        );\n        console.log(\"Bid prices: \");\n        for (uint256 i = 0; i < 3; i++) {\n            console.log(askPrices[i]);\n        }\n\n        vm.stopBroadcast();\n    }\n}\n\ncontract ShowOrderbook is Deployer {\n    address constant matching_engine_address =\n        0xa2F02d36206EDD2EAE9Fd5FBaBd90CdFCE939614;\n    address constant base_address = 0xe5D7C2a44FfDDf6b295A15c148167daaAf5Cf34f;\n    address constant quote_address = 0x176211869cA2b568f2A7D4EE941E073a821EE1ff; \n    MatchingEngine public matchingEngine =\n        MatchingEngine(payable(matching_engine_address));\n\n    function _orderbookIsEmpty(address b_addr, address q_addr, uint256 price, bool isBid) internal view returns (bool) {\n        address orderbook = matchingEngine.getPair(b_addr, q_addr);\n        console.log(\"Orderbook\", orderbook);\n        return Orderbook(payable(orderbook)).isEmpty(isBid, price);\n    }\n\n    function _showOrderbook(\n        MatchingEngine matchingEngine,\n        address base,\n        address quote\n    ) internal view {\n        (uint256 bidHead, uint256 askHead) = matchingEngine.heads(base, quote);\n        console.log(\"Bid Head: \", bidHead);\n        console.log(\"Ask Head: \", askHead);\n        console.log(\"is empty: \", _orderbookIsEmpty(base, quote, askHead, false));\n        uint256[] memory bidPrices = matchingEngine.getPrices(\n            address(base),\n            address(quote),\n            true,\n            20\n        );\n        uint256[] memory askPrices = matchingEngine.getPrices(\n            address(base),\n            address(quote),\n            false,\n            20\n        );\n        console.log(\"Ask prices: \");\n        for (uint256 i = 0; i < 6; i++) {\n            console.log(askPrices[i]);\n            console.log(\"Ask Orders: \");\n            uint32[] memory askOrderIds = matchingEngine.getOrderIds(\n                address(base),\n                address(quote),\n                false,\n                askPrices[i],\n                10\n            );\n            ExchangeOrderbook.Order[] memory askOrders = matchingEngine\n                .getOrders(\n                    address(base),\n                    address(quote),\n                    false,\n                    askPrices[i],\n                    10\n                );\n            for (uint256 j = 0; j < 10; j++) {\n                console.log(askOrderIds[j], askOrders[j].owner, askOrders[j].depositAmount);\n            }\n        }\n\n        console.log(\"Bid prices: \");\n        for (uint256 i = 0; i < 6; i++) {\n            console.log(bidPrices[i]);\n            console.log(\"Bid Orders: \");\n            uint32[] memory bidOrderIds = matchingEngine.getOrderIds(\n                address(base),\n                address(quote),\n                false,\n                bidPrices[i],\n                10\n            );\n            ExchangeOrderbook.Order[] memory bidOrders = matchingEngine\n                .getOrders(\n                    address(base),\n                    address(quote),\n                    true,\n                    bidPrices[i],\n                    10\n                );\n            for (uint256 j = 0; j < 10; j++) {\n                console.log(bidOrderIds[j], bidOrders[j].owner, bidOrders[j].depositAmount);\n            }\n        }\n    }\n\n    function run() external {\n        _setDeployer();\n        _showOrderbook(\n            MatchingEngine(payable(matching_engine_address)),\n            base_address,\n            quote_address\n        );\n        vm.stopBroadcast();\n    }\n}\n"
        },
        "script/exchange/LineaTestnet.s.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"forge-std/Script.sol\";\nimport {console} from \"forge-std/console.sol\";\nimport {MockBTC} from \"../../contracts/mock/MockBTC.sol\";\nimport {SABT} from \"../../contracts/sabt/SABT.sol\";\nimport {BlockAccountant} from \"../../contracts/sabt/BlockAccountant.sol\";\nimport {Membership} from \"../../contracts/sabt/Membership.sol\";\nimport {Treasury} from \"../../contracts/sabt/Treasury.sol\";\nimport {MockToken} from \"../../contracts/mock/MockToken.sol\";\nimport {MatchingEngine} from \"../../contracts/safex/MatchingEngine.sol\";\nimport {OrderbookFactory} from \"../../contracts/safex/orderbooks/OrderbookFactory.sol\";\nimport {Orderbook} from \"../../contracts/safex/orderbooks/Orderbook.sol\";\nimport {Multicall3} from \"../Multicall3.sol\";\nimport {TokenDispenser} from \"../../contracts/safex/airdrops/TokenDispenser.sol\";\nimport {ExchangeOrderbook} from \"../../contracts/safex/libraries/ExchangeOrderbook.sol\";\n\ncontract Deployer is Script {\n    function _setDeployer() internal {\n        uint256 deployerPrivateKey = vm.envUint(\"LINEA_TESTNET_DEPLOYER_KEY\");\n        vm.startBroadcast(deployerPrivateKey);\n    }\n}\n\ncontract DeployMulticall3 is Deployer {\n    function run() external {\n        _setDeployer();\n        new Multicall3();\n        vm.stopBroadcast();\n    }\n}\n\ncontract DeployWETH is Deployer {\n    function run() external {\n        _setDeployer();\n        vm.stopBroadcast();\n    }\n}\n\ncontract DeployTestnetAssets is Deployer {\n    function run() external {\n        _setDeployer();\n        MockToken feeToken = new MockToken(\"Standard\", \"STND\");\n        MockToken stablecoin = new MockToken(\"Stablecoin\", \"STBC\");\n        vm.stopBroadcast();\n    }\n}\n\ncontract DeploySAFEXMainnetContracts is Deployer {\n    // Change address constants on deploying to other networks from DeployAssets\n    /// Second per block to finalize\n    uint32 constant spb = 12;\n    address constant deployer_address = 0x34CCCa03631830cD8296c172bf3c31e126814ce9;\n    address constant foundation_address = 0x34CCCa03631830cD8296c172bf3c31e126814ce9;\n    address constant weth = 0x2C1b868d6596a18e32E61B901E4060C872647b6C;\n\n    Treasury public treasury;\n    \n    function run() external {\n        _setDeployer();\n        OrderbookFactory orderbookFactory = new OrderbookFactory();\n        MatchingEngine matchingEngine = new MatchingEngine();\n        treasury = new Treasury();\n        matchingEngine.initialize(\n            address(orderbookFactory), address(treasury), address(weth)\n        );\n        orderbookFactory.initialize(address(matchingEngine));\n        vm.stopBroadcast();\n    }\n}\n\n\ncontract DeploySABTMainnetContracts is Deployer {\n    Treasury constant treasury = Treasury(0xC9bbB43A3b09055002b50bdce62314C2CC3ad73F);\n    uint32 constant spb = 12;\n    address constant weth = 0xe5D7C2a44FfDDf6b295A15c148167daaAf5Cf34f; // weth on mainnet\n    address constant feeToken = 0xE57Cdf5796C2f5281EDF1B81129E1D4Ff9190815;\n    address constant stablecoin = 0xfB4c8b2658AB2bf32ab5Fc1627f115974B52FeA7;\n    address constant matchingEngine = 0xfBBE74C50540BAE8B8746FDf3918c66CfBc9Db9A;\n    address constant foundation_address = 0x34CCCa03631830cD8296c172bf3c31e126814ce9;\n\n    function run() external {\n        Membership membership = new Membership();\n        SABT sabt = new SABT();\n        membership.initialize(address(sabt), foundation_address, weth);\n        sabt.initialize(address(membership));\n        // Setup accountant and treasury\n        BlockAccountant accountant = new BlockAccountant();\n        accountant.initialize(address(membership), address(matchingEngine), address(stablecoin), spb);\n        treasury.set(address(membership), address(accountant), address(sabt));\n        // Wire up matching engine with them\n        accountant.grantRole(\n            accountant.REPORTER_ROLE(),\n            address(treasury)\n        );\n        treasury.grantRole(treasury.REPORTER_ROLE(), address(matchingEngine));\n    }\n}\n\ncontract DeployAll is Deployer {\n    // Change address constants on deploying to other networks or private keys\n    address constant deployer_address =\n        0x34CCCa03631830cD8296c172bf3c31e126814ce9;\n    address constant trader1_address =\n        0x6408fb579e106fC59f964eC33FE123738A2D0Da3;\n    address constant trader2_address =\n        0xf5aE3B9dF4e6972a229E7915D55F9FBE5900fE95;\n    address constant foundation_address =\n        0x34CCCa03631830cD8296c172bf3c31e126814ce9;\n    address constant weth_address = 0x2C1b868d6596a18e32E61B901E4060C872647b6C;\n    // seconds per block\n    uint32 spb = 12;\n    Treasury public treasury;\n\n    function run() external {\n        _setDeployer();\n\n        // DeployAssets\n        MockToken feeToken = new MockToken(\"Standard\", \"STND\");\n        MockToken stablecoin = new MockToken(\"Stablecoin\", \"STBC\");\n\n        // DeployContracts\n        OrderbookFactory orderbookFactory = new OrderbookFactory();\n        MatchingEngine matchingEngine = new MatchingEngine();\n        Membership membership = new Membership();\n        SABT sabt = new SABT();\n        membership.initialize(address(sabt), foundation_address, weth_address);\n        sabt.initialize(address(membership));\n        // Setup accountant and treasury\n        BlockAccountant accountant = new BlockAccountant();\n        accountant.initialize(\n            address(membership),\n            address(matchingEngine),\n            address(stablecoin),\n            spb\n        );\n        treasury = new Treasury();\n        treasury.set(address(membership), address(accountant), address(sabt));\n        matchingEngine.initialize(\n            address(orderbookFactory),\n            address(treasury),\n            address(weth_address)\n        );\n        orderbookFactory.initialize(address(matchingEngine));\n        // Wire up matching engine with them\n        accountant.grantRole(\n            accountant.REPORTER_ROLE(),\n            address(treasury)\n        );\n        treasury.grantRole(treasury.REPORTER_ROLE(), address(matchingEngine));\n\n        // DistributeAssets\n        // Mint fee Token to the deployer, trader1, trader2\n        feeToken.mint(deployer_address, 1000000000000000000000000e18);\n        feeToken.mint(trader1_address, 100000e18);\n        feeToken.mint(trader2_address, 100000e18);\n\n        // Mint stablecoin to the deployer, trader1, trader2\n        stablecoin.mint(deployer_address, 1000000000000000000000000000e18);\n        stablecoin.mint(trader1_address, 100000e18);\n        stablecoin.mint(trader2_address, 100000e18);\n\n        // SetupSABTInitialParameters\n        // set Fee in membership contract\n        membership.setMembership(1, address(feeToken), 1000, 1000, 10000);\n\n        // Get membership\n        feeToken.approve(address(membership), 1e30);\n        membership.register(1, address(feeToken));\n        membership.subscribe(1, 1000000, address(feeToken));\n\n        // SetupSAFEXInitialParameters\n        // Setup pair between stablecoin and feeToken with price\n        feeToken.approve(address(matchingEngine), 100000e18);\n        matchingEngine.addPair(address(feeToken), address(stablecoin));\n\n        // make a price in matching engine where 1 feeToken = 1000 stablecoin with buy and sell order\n        feeToken.approve(address(matchingEngine), 100000e18);\n        stablecoin.approve(address(matchingEngine), 100000000e18);\n        // add limit orders\n        matchingEngine.limitSell(\n            address(feeToken),\n            address(stablecoin),\n            1000e8,\n            10000e18,\n            true,\n            1,\n            0,\n            msg.sender\n        );\n        matchingEngine.limitBuy(\n            address(feeToken),\n            address(stablecoin),\n            1000e8,\n            10000000e18,\n            false,\n            1,\n            1,\n            msg.sender\n        );\n\n        // DeployTokenDispenser\n        TokenDispenser dispenser = new TokenDispenser();\n\n        uint256 deposit_amount = 1e40;\n        uint256 airdrop_amount = 100000e18;\n\n        // AddAirdrop\n        feeToken.mint(deployer_address, deposit_amount);\n        feeToken.transfer(address(dispenser), deposit_amount);\n        dispenser.setTokenAmount(address(feeToken), airdrop_amount);\n\n        stablecoin.mint(deployer_address, deposit_amount);\n        stablecoin.transfer(address(dispenser), deposit_amount);\n        dispenser.setTokenAmount(address(stablecoin), airdrop_amount);\n\n        vm.stopBroadcast();\n    }\n}\n\n\ncontract DeployTestnetContracts is Deployer {\n    // Change address constants on deploying to other networks from DeployAssets\n    /// Second per block to finalize\n    uint32 constant spb = 12;\n    address constant deployer_address = 0x34CCCa03631830cD8296c172bf3c31e126814ce9;\n    address constant foundation_address = 0x34CCCa03631830cD8296c172bf3c31e126814ce9;\n    address constant weth = 0x2C1b868d6596a18e32E61B901E4060C872647b6C;\n    address constant feeToken = 0xE57Cdf5796C2f5281EDF1B81129E1D4Ff9190815;\n    address constant stablecoin = 0xfB4c8b2658AB2bf32ab5Fc1627f115974B52FeA7;\n    Treasury public treasury;\n\n    function run() external {\n        _setDeployer();\n        OrderbookFactory orderbookFactory = new OrderbookFactory();\n        MatchingEngine matchingEngine = new MatchingEngine();\n        Membership membership = new Membership();\n        SABT sabt = new SABT();\n        membership.initialize(address(sabt), foundation_address, weth);\n        sabt.initialize(address(membership));\n        // Setup accountant and treasury\n        BlockAccountant accountant = new BlockAccountant();\n        accountant.initialize(address(membership), address(matchingEngine), address(stablecoin), spb);\n        treasury = new Treasury();\n        treasury.set(address(membership), address(accountant), address(sabt));\n        matchingEngine.initialize(\n            address(orderbookFactory), address(treasury), address(weth)\n        );\n        orderbookFactory.initialize(address(matchingEngine));\n        // Wire up matching engine with them\n        accountant.grantRole(\n            accountant.REPORTER_ROLE(),\n            address(treasury)\n        );\n        treasury.grantRole(treasury.REPORTER_ROLE(), address(matchingEngine));\n        vm.stopBroadcast();\n    }\n}\n\ncontract DistributeTestnetAssets is Deployer {\n    // Change address constants on deploying to other networks from DeployAssets\n    address constant deployer_address =\n        0x34CCCa03631830cD8296c172bf3c31e126814ce9;\n    address constant trader1_address =\n        0x6408fb579e106fC59f964eC33FE123738A2D0Da3;\n    address constant trader2_address =\n        0xf5aE3B9dF4e6972a229E7915D55F9FBE5900fE95;\n    address constant feeToken_address =\n        0xE57Cdf5796C2f5281EDF1B81129E1D4Ff9190815;\n    address constant stablecoin_address =\n        0xfB4c8b2658AB2bf32ab5Fc1627f115974B52FeA7;\n\n    MockToken public feeToken = MockToken(feeToken_address);\n    MockToken public stablecoin = MockToken(stablecoin_address);\n\n    function run() external {\n        _setDeployer();\n        // Mint fee Token to the deployer, trader1, trader2\n        feeToken.mint(deployer_address, 1000000000000000000000000e18);\n        feeToken.mint(trader1_address, 100000e18);\n        feeToken.mint(trader2_address, 100000e18);\n\n        // Mint stablecoin to the deployer, trader1, trader2\n        stablecoin.mint(deployer_address, 1000000000000000000000000000e18);\n        stablecoin.mint(trader1_address, 100000e18);\n        stablecoin.mint(trader2_address, 100000e18);\n\n        vm.stopBroadcast();\n    }\n}\n\ncontract SetupSABTInitialParameters is Deployer {\n    // Change address constants on deploying to other networks from DeployAssets\n    address constant matching_engine_address =\n        0x1779583579564b34232021590E6d19cAd0277973;\n    address constant membership_address =\n        0xc46344c6d449CD510f8080cD361e12624c1D91DF;\n    address constant sabt_address = 0x4062731e9330301ca5C4DEFEcF7C20A81acF2d43;\n    address constant feeToken_address =\n        0xE57Cdf5796C2f5281EDF1B81129E1D4Ff9190815;\n    address constant stablecoin_address =\n        0xfB4c8b2658AB2bf32ab5Fc1627f115974B52FeA7;\n    address constant block_accountant_address =\n        0xc9033EFD4CD42fC6Fdd22dFdCbbf391099BD6d22;\n    address constant treasury_address =\n        0xd47F27E3312B946c9C38Ca08bB1e9dF2Fac04724;\n    address constant deployer_address =\n        0x34CCCa03631830cD8296c172bf3c31e126814ce9;\n\n    Membership public membership = Membership(membership_address);\n    SABT public sabt = SABT(sabt_address);\n    MockToken public stablecoin = MockToken(stablecoin_address);\n    MockToken public feeToken = MockToken(feeToken_address);\n    BlockAccountant public accountant =\n        BlockAccountant(block_accountant_address);\n    Treasury public treasury = Treasury(treasury_address);\n\n    function run() external {\n        _setDeployer();\n        // set Fee in membership contract\n        membership.setMembership(1, feeToken_address, 1000, 1000, 10000);\n\n        // Get membership\n        feeToken.approve(membership_address, 1e30);\n        membership.register(1, feeToken_address);\n        membership.subscribe(1, 1000000, feeToken_address);\n\n        vm.stopBroadcast();\n    }\n}\n\ncontract SetupSAFEXInitialParameters is Deployer {\n    // Change address constants on deploying to other networks from DeployAssets\n    address constant matching_engine_address =\n        0x1779583579564b34232021590E6d19cAd0277973;\n    address constant feeToken_address =\n        0xE57Cdf5796C2f5281EDF1B81129E1D4Ff9190815;\n    address constant stablecoin_address =\n        0xfB4c8b2658AB2bf32ab5Fc1627f115974B52FeA7;\n    MatchingEngine public matchingEngine =\n        MatchingEngine(payable(matching_engine_address));\n    MockToken public feeToken = MockToken(feeToken_address);\n    MockToken public stablecoin = MockToken(stablecoin_address);\n\n    function run() external {\n        _setDeployer();\n        // Setup pair between stablecoin and feeToken with price\n        feeToken.approve(address(matchingEngine), 100000e18);\n        matchingEngine.addPair(address(feeToken), address(stablecoin));\n\n        // make a price in matching engine where 1 feeToken = 1000 stablecoin with buy and sell order\n        feeToken.approve(address(matchingEngine), 100000e18);\n        stablecoin.approve(address(matchingEngine), 100000000e18);\n        // add limit orders\n        matchingEngine.limitSell(\n            address(feeToken),\n            address(stablecoin),\n            1000e8,\n            10000e18,\n            true,\n            1,\n            0,\n            msg.sender\n        );\n        matchingEngine.limitBuy(\n            address(feeToken),\n            address(stablecoin),\n            1000e8,\n            10000000e18,\n            false,\n            1,\n            1,\n            msg.sender\n        );\n        vm.stopBroadcast();\n    }\n}\n\ncontract DeployTokenDispenser is Deployer {\n    function run() external {\n        _setDeployer();\n        TokenDispenser dispenser = new TokenDispenser();\n        vm.stopBroadcast();\n    }\n}\n\ncontract AddAirdrop is Deployer {\n    address constant airdrop_token_address =\n        0xE57Cdf5796C2f5281EDF1B81129E1D4Ff9190815;\n    address constant dispenser_address =\n        0xA8800c10F7276E2cfe025aAc849b812A2eC601fF;\n    address constant deployer_address =\n        0x34CCCa03631830cD8296c172bf3c31e126814ce9;\n    MockToken public airdropToken = MockToken(airdrop_token_address);\n    TokenDispenser public dispenser = TokenDispenser(dispenser_address);\n    uint256 public deposit_amount = 1e40;\n    uint256 public airdrop_amount = 100000e18;\n\n    function run() external {\n        _setDeployer();\n        airdropToken.mint(deployer_address, deposit_amount);\n        //airdropToken.transfer(dispenser_address, deposit_amount);\n        dispenser.setTokenAmount(airdrop_token_address, airdrop_amount);\n        vm.stopBroadcast();\n    }\n}\n\ncontract TestOrderbookSell is Deployer {\n    // Change address constants on deploying to other networks from DeployAssets\n    address constant matching_engine_address =\n        0xa7431faC42c7D5ff6C5EE297B9D65960B9970f12;\n    address constant feeToken_address =\n        0xE57Cdf5796C2f5281EDF1B81129E1D4Ff9190815;\n    address constant stablecoin_address =\n        0xfB4c8b2658AB2bf32ab5Fc1627f115974B52FeA7;\n    MatchingEngine public matchingEngine =\n        MatchingEngine(payable(matching_engine_address));\n    MockToken public feeToken = MockToken(feeToken_address);\n    MockToken public stablecoin = MockToken(stablecoin_address);\n    Orderbook public book;\n\n    function run() external {\n        _setDeployer();\n\n        book = Orderbook(\n            payable(matchingEngine.getPair(address(feeToken), address(stablecoin)))\n        );\n\n        // make a price in matching engine where 1 feeToken = 1000 stablecoin with buy and sell order\n        feeToken.approve(address(matchingEngine), 100000e18);\n        stablecoin.approve(address(matchingEngine), 100000000e18);\n        // add limit orders\n        matchingEngine.limitSell(\n            address(feeToken),\n            address(stablecoin),\n            100002e6,\n            10000e18,\n            true,\n            1,\n            0,\n            msg.sender\n        );\n        //matchingEngine.getOrders(address(token1), address(token2), true, 0, 0);\n        uint256[] memory askPrices = matchingEngine.getPrices(\n            address(feeToken),\n            address(stablecoin),\n            false,\n            20\n        );\n        console.log(\"Bid prices: \");\n        for (uint256 i = 0; i < 3; i++) {\n            console.log(askPrices[i]);\n        }\n        (uint256 bidHead, uint256 askHead) = book.heads();\n        console.log(\"bidHead: \", bidHead);\n        console.log(\"askHead: \", askHead);\n        vm.stopBroadcast();\n    }\n}\n\ncontract TestGetPrices is Deployer {\n    // Change address constants on deploying to other networks from DeployAssets\n    address constant matching_engine_address =\n        0xa7431faC42c7D5ff6C5EE297B9D65960B9970f12;\n    address constant feeToken_address =\n        0xE57Cdf5796C2f5281EDF1B81129E1D4Ff9190815;\n    address constant stablecoin_address =\n        0xfB4c8b2658AB2bf32ab5Fc1627f115974B52FeA7;\n    MatchingEngine public matchingEngine =\n        MatchingEngine(payable(matching_engine_address));\n    MockToken public feeToken = MockToken(feeToken_address);\n    MockToken public stablecoin = MockToken(stablecoin_address);\n\n    function run() external {\n        _setDeployer();\n\n        uint256[] memory bidPrices = matchingEngine.getPrices(\n            address(feeToken),\n            address(stablecoin),\n            true,\n            20\n        );\n        console.log(\"Ask prices: \");\n        for (uint256 i = 0; i < 4; i++) {\n            console.log(bidPrices[i]);\n        }\n        //matchingEngine.getOrders(address(token1), address(token2), true, 0, 0);\n        uint256[] memory askPrices = matchingEngine.getPrices(\n            address(feeToken),\n            address(stablecoin),\n            false,\n            20\n        );\n        console.log(\"Bid prices: \");\n        for (uint256 i = 0; i < 3; i++) {\n            console.log(askPrices[i]);\n        }\n\n        vm.stopBroadcast();\n    }\n}\n\ncontract ShowOrderbook is Deployer {\n    address constant matching_engine_address =\n        0x6Dd6A2D269b2e971272e3a29fc204Fe35B20E827;\n    address constant base_address = 0xE57Cdf5796C2f5281EDF1B81129E1D4Ff9190815;\n    address constant quote_address = 0xfB4c8b2658AB2bf32ab5Fc1627f115974B52FeA7;\n    MatchingEngine public matchingEngine =\n        MatchingEngine(payable(matching_engine_address));\n\n    function _orderbookIsEmpty(address b_addr, address q_addr, uint256 price, bool isBid) internal view returns (bool) {\n        address orderbook = matchingEngine.getPair(b_addr, q_addr);\n        console.log(\"Orderbook\", orderbook);\n        return Orderbook(payable(orderbook)).isEmpty(isBid, price);\n    }\n\n    function _showOrderbook(\n        MatchingEngine matchingEngine,\n        address base,\n        address quote\n    ) internal view {\n        (uint256 bidHead, uint256 askHead) = matchingEngine.heads(base, quote);\n        console.log(\"Bid Head: \", bidHead);\n        console.log(\"Ask Head: \", askHead);\n        console.log(\"is empty: \", _orderbookIsEmpty(base, quote, askHead, false));\n        uint256[] memory bidPrices = matchingEngine.getPrices(\n            address(base),\n            address(quote),\n            true,\n            20\n        );\n        uint256[] memory askPrices = matchingEngine.getPrices(\n            address(base),\n            address(quote),\n            false,\n            20\n        );\n        console.log(\"Ask prices: \");\n        for (uint256 i = 0; i < 6; i++) {\n            console.log(askPrices[i]);\n            console.log(\"Ask Orders: \");\n            ExchangeOrderbook.Order[] memory askOrders = matchingEngine\n                .getOrders(\n                    address(base),\n                    address(quote),\n                    false,\n                    askPrices[i],\n                    10\n                );\n            for (uint256 j = 0; j < 10; j++) {\n                console.log(askOrders[j].owner, askOrders[j].depositAmount);\n            }\n        }\n\n        console.log(\"Bid prices: \");\n        for (uint256 i = 0; i < 6; i++) {\n            console.log(bidPrices[i]);\n            console.log(\"Bid Orders: \");\n            ExchangeOrderbook.Order[] memory bidOrders = matchingEngine\n                .getOrders(\n                    address(base),\n                    address(quote),\n                    true,\n                    bidPrices[i],\n                    10\n                );\n            for (uint256 j = 0; j < 10; j++) {\n                console.log(bidOrders[j].owner, bidOrders[j].depositAmount);\n            }\n        }\n    }\n\n    function run() external {\n        _setDeployer();\n        _showOrderbook(\n            MatchingEngine(payable(0x6Dd6A2D269b2e971272e3a29fc204Fe35B20E827)),\n            0xfB4c8b2658AB2bf32ab5Fc1627f115974B52FeA7,\n            0xE57Cdf5796C2f5281EDF1B81129E1D4Ff9190815\n        );\n        vm.stopBroadcast();\n    }\n}\n"
        },
        "script/exchange/Mode.s.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"forge-std/Script.sol\";\nimport {console} from \"forge-std/console.sol\";\nimport {MockBTC} from \"../../contracts/mock/MockBTC.sol\";\nimport {SABT} from \"../../contracts/sabt/SABT.sol\";\nimport {BlockAccountant} from \"../../contracts/sabt/BlockAccountant.sol\";\nimport {Membership} from \"../../contracts/sabt/Membership.sol\";\nimport {Treasury} from \"../../contracts/sabt/Treasury.sol\";\nimport {MockToken} from \"../../contracts/mock/MockToken.sol\";\nimport {MatchingEngine} from \"../../contracts/safex/MatchingEngine.sol\";\nimport {OrderbookFactory} from \"../../contracts/safex/orderbooks/OrderbookFactory.sol\";\nimport {Orderbook} from \"../../contracts/safex/orderbooks/Orderbook.sol\";\nimport {Multicall3} from \"../Multicall3.sol\";\nimport {TokenDispenser} from \"../../contracts/safex/airdrops/TokenDispenser.sol\";\nimport {ExchangeOrderbook} from \"../../contracts/safex/libraries/ExchangeOrderbook.sol\";\n\ncontract Deployer is Script {\n    function _setDeployer() internal {\n        uint256 deployerPrivateKey = vm.envUint(\"LINEA_TESTNET_DEPLOYER_KEY\");\n        vm.startBroadcast(deployerPrivateKey);\n    }\n}\n\ncontract DeployMulticall3 is Deployer {\n    address multicall3 = 0x2CC505C4bc86B28503B5b8C450407D32e5E20A9f;\n    function run() external {\n        _setDeployer();\n        new Multicall3();\n        vm.stopBroadcast();\n    }\n}\n\ncontract DeployWETH is Deployer {\n    function run() external {\n        _setDeployer();\n        vm.stopBroadcast();\n    }\n}\n\ncontract DeploySAFEXMainnetContracts is Deployer {\n    // Change address constants on deploying to other networks from DeployAssets\n    /// Second per block to finalize\n    uint32 constant spb = 12;\n    address constant deployer_address =\n        0x34CCCa03631830cD8296c172bf3c31e126814ce9;\n    address constant foundation_address =\n        0x34CCCa03631830cD8296c172bf3c31e126814ce9;\n    address constant weth = 0x4200000000000000000000000000000000000006;\n\n    Treasury public treasury;\n\n    function run() external {\n        _setDeployer();\n        OrderbookFactory orderbookFactory = new OrderbookFactory();\n        MatchingEngine matchingEngine = new MatchingEngine();\n        treasury = Treasury(0xBDf1c8C3fFd6f6C8E4AC13dAA3436Eb239D3e203);\n        matchingEngine.initialize(\n            address(orderbookFactory),\n            address(treasury),\n            address(weth)\n        );\n        orderbookFactory.initialize(address(matchingEngine));\n        vm.stopBroadcast();\n    }\n}\n\npragma solidity 0.8.17;\n\n/// @notice Implementation of CIP-001 https://github.com/Canto-Improvement-Proposals/CIPs/blob/main/CIP-001.md\n/// @dev Every contract is responsible to register itself in the constructor by calling `register(address)`.\n///      If contract is using proxy pattern, it's possible to register retroactively, however past fees will be lost.\n///      Recipient withdraws fees by calling `withdraw(uint256,address,uint256)`.\ninterface IFeeSharing  {\n   \n    /// @notice Mints ownership NFT that allows the owner to collect fees earned by the smart contract.\n    ///         `msg.sender` is assumed to be a smart contract that earns fees. Only smart contract itself\n    ///         can register a fee receipient.\n    /// @param _recipient recipient of the ownership NFT\n    /// @return tokenId of the ownership NFT that collects fees\n    function register(address _recipient) external returns (uint256 tokenId);\n\n    /// @notice Assigns smart contract to existing NFT. That NFT will collect fees generated by the smart contract.\n    ///         Callable only by smart contract itself.\n    /// @param _tokenId tokenId which will collect fees\n    /// @return tokenId of the ownership NFT that collects fees\n    function assign(uint256 _tokenId) external returns (uint256);\n\n    function isRegistered(address _smartContract) external view returns (bool);\n\n    function getTokenId(address _smartContract) external view returns (uint256);\n\n\n}\n\n\ncontract RegisterSFS is Deployer {\n    address constant sfs = 0x8680CEaBcb9b56913c519c069Add6Bc3494B7020;\n    \n    function run() external {\n        IFeeSharing(sfs).isRegistered(0x34CCCa03631830cD8296c172bf3c31e126814ce9);\n        IFeeSharing(sfs).register(0x34CCCa03631830cD8296c172bf3c31e126814ce9);\n    }\n}\n\n\ncontract DeploySABTMainnetContracts is Deployer {\n    Treasury constant treasury =\n        Treasury(0xBDf1c8C3fFd6f6C8E4AC13dAA3436Eb239D3e203);\n    uint32 constant spb = 12;\n    address constant weth = 0xe5D7C2a44FfDDf6b295A15c148167daaAf5Cf34f; // weth on mainnet\n    address constant stablecoin = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48; // usdc on mainnet\n    address constant matchingEngine =\n        0x93d744De3c805e15136459FEad77F17E5Ac6Cfcf;\n    address constant orderbookFactory =\n        0x7a2e3a7A1bf8FaCCAd68115DC509DB5a5af4e7e4;\n    address constant foundation_address =\n        0x34CCCa03631830cD8296c172bf3c31e126814ce9;\n\n    function run() external {\n        Membership membership = new Membership();\n        SABT sabt = new SABT();\n        membership.initialize(address(sabt), foundation_address, weth);\n        sabt.initialize(address(membership));\n        // Setup accountant and treasury\n        BlockAccountant accountant = new BlockAccountant();\n        accountant.initialize(\n            address(membership),\n            address(matchingEngine),\n            address(stablecoin),\n            spb\n        );\n        treasury.set(address(membership), address(accountant), address(sabt));\n        // Wire up matching engine with them\n        accountant.grantRole(accountant.REPORTER_ROLE(), address(treasury));\n        treasury.grantRole(treasury.REPORTER_ROLE(), address(matchingEngine));\n    }\n}\n\ncontract DeployTokenDispenser is Deployer {\n    function run() external {\n        _setDeployer();\n        TokenDispenser dispenser = new TokenDispenser();\n        vm.stopBroadcast();\n    }\n}\n\ncontract AddAirdrop is Deployer {\n    address constant airdrop_token_address =\n        0xE57Cdf5796C2f5281EDF1B81129E1D4Ff9190815;\n    address constant dispenser_address =\n        0xA8800c10F7276E2cfe025aAc849b812A2eC601fF;\n    address constant deployer_address =\n        0x34CCCa03631830cD8296c172bf3c31e126814ce9;\n    MockToken public airdropToken = MockToken(airdrop_token_address);\n    TokenDispenser public dispenser = TokenDispenser(dispenser_address);\n    uint256 public deposit_amount = 1e40;\n    uint256 public airdrop_amount = 100000e18;\n\n    function run() external {\n        _setDeployer();\n        airdropToken.mint(deployer_address, deposit_amount);\n        airdropToken.transfer(dispenser_address, deposit_amount);\n        dispenser.setTokenAmount(airdrop_token_address, airdrop_amount);\n        vm.stopBroadcast();\n    }\n}\n\ncontract TestAddPair is Deployer {\n    address constant matching_engine_address =\n        0x99e87D3f46079CeeE33859Fb6055A912090c9683;\n    address constant base_address = 0xA219439258ca9da29E9Cc4cE5596924745e12B93;\n    address constant quote_address = 0xe5D7C2a44FfDDf6b295A15c148167daaAf5Cf34f;\n\n    function run() external {\n        _setDeployer();\n\n        MatchingEngine matchingEngine = MatchingEngine(\n            payable(matching_engine_address)\n        );\n        matchingEngine.addPair(address(base_address), address(quote_address));\n    }\n}\n\ncontract CancelOrder is Deployer {\n    address constant matching_engine_address = 0xE02351341EE61f24BdddB9b03e8b30B145Ab1c60;\n    address constant base = 0x4200000000000000000000000000000000000006;\n    address constant quote = 0xf0F161fDA2712DB8b566946122a5af183995e2eD;\n\n    function run() external {\n        _setDeployer();\n\n        MatchingEngine matchingEngine = MatchingEngine(payable(matching_engine_address));\n        matchingEngine.cancelOrder(\n            base,\n            quote,\n            true,\n            5,\n            0\n        );\n    }\n}\n\ncontract TestOrderbookSell is Deployer {\n    // Change address constants on deploying to other networks from DeployAssets\n    address constant matching_engine_address =\n        0x66a8b38D8B573Dbb6beBe163324b2DC0070d3430;\n    address constant base_address = 0xA219439258ca9da29E9Cc4cE5596924745e12B93;\n    address constant quote_address = 0xe5D7C2a44FfDDf6b295A15c148167daaAf5Cf34f;\n    MatchingEngine public matchingEngine =\n        MatchingEngine(payable(matching_engine_address));\n    MockToken public base = MockToken(base_address);\n    MockToken public quote = MockToken(quote_address);\n    Orderbook public book;\n\n    function run() external {\n        _setDeployer();\n\n        book = Orderbook(\n            payable(matchingEngine.getPair(address(base), address(quote)))\n        );\n\n        // make a price in matching engine where 1 feeToken = 1000 stablecoin with buy and sell order\n        base.approve(address(matchingEngine), 1e18);\n        quote.approve(address(matchingEngine), 1e18);\n\n        matchingEngine.mktPrice(address(base), address(quote));\n        // add limit orders\n        matchingEngine.limitSell(\n            address(base),\n            address(quote),\n            50600,\n            100000,\n            true,\n            1,\n            0,\n            msg.sender\n        );\n        //matchingEngine.getOrders(address(base), address(quote), true, 0, 0);\n        uint256[] memory askPrices = matchingEngine.getPrices(\n            address(base),\n            address(quote),\n            false,\n            20\n        );\n        console.log(\"Bid prices: \");\n        for (uint256 i = 0; i < 3; i++) {\n            console.log(askPrices[i]);\n        }\n        (uint256 bidHead, uint256 askHead) = book.heads();\n        console.log(\"bidHead: \", bidHead);\n        console.log(\"askHead: \", askHead);\n        vm.stopBroadcast();\n    }\n}\n\ncontract TestOrderbookBuy is Deployer {\n    // Change address constants on deploying to other networks from DeployAssets\n    address constant matching_engine_address =\n        0xa2F02d36206EDD2EAE9Fd5FBaBd90CdFCE939614;\n    address constant quote_address = 0xB79DD08EA68A908A97220C76d19A6aA9cBDE4376;\n    address constant base_address = 0xe5D7C2a44FfDDf6b295A15c148167daaAf5Cf34f;\n\n    MatchingEngine public matchingEngine =\n        MatchingEngine(payable(matching_engine_address));\n    MockToken public base = MockToken(base_address);\n    MockToken public quote = MockToken(quote_address);\n    Orderbook public book;\n\n    function run() external {\n        _setDeployer();\n\n        book = Orderbook(\n            payable(matchingEngine.getPair(address(base), address(quote)))\n        );\n\n        // make a price in matching engine where 1 feeToken = 1000 stablecoin with buy and sell order\n        base.approve(address(matchingEngine), 100000e18);\n        quote.approve(address(matchingEngine), 100000000e18);\n\n        matchingEngine.mktPrice(address(base), address(quote));\n        // add limit orders\n        matchingEngine.limitBuy(\n            address(base),\n            address(quote),\n            2234e8,\n            100000,\n            true,\n            1,\n            0,\n            msg.sender\n        );\n        //matchingEngine.getOrders(address(base), address(quote), true, 0, 0);\n        uint256[] memory askPrices = matchingEngine.getPrices(\n            address(base),\n            address(quote),\n            false,\n            20\n        );\n        console.log(\"Bid prices: \");\n        for (uint256 i = 0; i < 3; i++) {\n            console.log(askPrices[i]);\n        }\n        (uint256 bidHead, uint256 askHead) = book.heads();\n        console.log(\"bidHead: \", bidHead);\n        console.log(\"askHead: \", askHead);\n        vm.stopBroadcast();\n    }\n}\n\ncontract TestGetPrices is Deployer {\n    // Change address constants on deploying to other networks from DeployAssets\n    address constant matching_engine_address =\n        0x99e87D3f46079CeeE33859Fb6055A912090c9683;\n    address constant feeToken_address =\n        0xE57Cdf5796C2f5281EDF1B81129E1D4Ff9190815;\n    address constant stablecoin_address =\n        0xfB4c8b2658AB2bf32ab5Fc1627f115974B52FeA7;\n    MatchingEngine public matchingEngine =\n        MatchingEngine(payable(matching_engine_address));\n    MockToken public feeToken = MockToken(feeToken_address);\n    MockToken public stablecoin = MockToken(stablecoin_address);\n\n    function run() external {\n        _setDeployer();\n\n        uint256[] memory bidPrices = matchingEngine.getPrices(\n            address(feeToken),\n            address(stablecoin),\n            true,\n            20\n        );\n        console.log(\"Ask prices: \");\n        for (uint256 i = 0; i < 4; i++) {\n            console.log(bidPrices[i]);\n        }\n        //matchingEngine.getOrders(address(base), address(quote), true, 0, 0);\n        uint256[] memory askPrices = matchingEngine.getPrices(\n            address(feeToken),\n            address(stablecoin),\n            false,\n            20\n        );\n        console.log(\"Bid prices: \");\n        for (uint256 i = 0; i < 3; i++) {\n            console.log(askPrices[i]);\n        }\n\n        vm.stopBroadcast();\n    }\n}\n\ncontract ShowOrderbook is Deployer {\n    address constant matching_engine_address =\n        0x2CC505C4bc86B28503B5b8C450407D32e5E20A9f;\n    address constant base_address = 0x176211869cA2b568f2A7D4EE941E073a821EE1ff;\n    address constant quote_address = 0xe5D7C2a44FfDDf6b295A15c148167daaAf5Cf34f;\n    MatchingEngine public matchingEngine =\n        MatchingEngine(payable(matching_engine_address));\n\n    function _orderbookIsEmpty(address b_addr, address q_addr, uint256 price, bool isBid) internal view returns (bool) {\n        address orderbook = matchingEngine.getPair(b_addr, q_addr);\n        console.log(\"Orderbook\", orderbook);\n        return Orderbook(payable(orderbook)).isEmpty(isBid, price);\n    }\n\n    function _showOrderbook(\n        MatchingEngine matchingEngine,\n        address base,\n        address quote\n    ) internal view {\n        (uint256 bidHead, uint256 askHead) = matchingEngine.heads(base, quote);\n        console.log(\"Bid Head: \", bidHead);\n        console.log(\"Ask Head: \", askHead);\n        console.log(\"is empty: \", _orderbookIsEmpty(base, quote, askHead, false));\n        uint256[] memory bidPrices = matchingEngine.getPrices(\n            address(base),\n            address(quote),\n            true,\n            20\n        );\n        uint256[] memory askPrices = matchingEngine.getPrices(\n            address(base),\n            address(quote),\n            false,\n            20\n        );\n        console.log(\"Ask prices: \");\n        for (uint256 i = 0; i < 6; i++) {\n            console.log(askPrices[i]);\n            console.log(\"Ask Orders: \");\n            uint32[] memory askOrderIds = matchingEngine.getOrderIds(\n                address(base),\n                address(quote),\n                false,\n                askPrices[i],\n                10\n            );\n            ExchangeOrderbook.Order[] memory askOrders = matchingEngine\n                .getOrders(\n                    address(base),\n                    address(quote),\n                    false,\n                    askPrices[i],\n                    10\n                );\n            for (uint256 j = 0; j < 10; j++) {\n                console.log(askOrderIds[j], askOrders[j].owner, askOrders[j].depositAmount);\n            }\n        }\n\n        console.log(\"Bid prices: \");\n        for (uint256 i = 0; i < 6; i++) {\n            console.log(bidPrices[i]);\n            console.log(\"Bid Orders: \");\n            uint32[] memory bidOrderIds = matchingEngine.getOrderIds(\n                address(base),\n                address(quote),\n                false,\n                bidPrices[i],\n                10\n            );\n            ExchangeOrderbook.Order[] memory bidOrders = matchingEngine\n                .getOrders(\n                    address(base),\n                    address(quote),\n                    true,\n                    bidPrices[i],\n                    10\n                );\n            for (uint256 j = 0; j < 10; j++) {\n                console.log(bidOrderIds[j], bidOrders[j].owner, bidOrders[j].depositAmount);\n            }\n        }\n    }\n\n    function run() external {\n        _setDeployer();\n        _showOrderbook(\n            MatchingEngine(payable(0x66a8b38D8B573Dbb6beBe163324b2DC0070d3430)),\n            0xA219439258ca9da29E9Cc4cE5596924745e12B93,\n            0xe5D7C2a44FfDDf6b295A15c148167daaAf5Cf34f\n        );\n        vm.stopBroadcast();\n    }\n}\n"
        },
        "script/exchange/opBNB.s.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"forge-std/Script.sol\";\nimport {console} from \"forge-std/console.sol\";\nimport {MockBTC} from \"../../contracts/mock/MockBTC.sol\";\nimport {SABT} from \"../../contracts/sabt/SABT.sol\";\nimport {BlockAccountant} from \"../../contracts/sabt/BlockAccountant.sol\";\nimport {Membership} from \"../../contracts/sabt/Membership.sol\";\nimport {Treasury} from \"../../contracts/sabt/Treasury.sol\";\nimport {MockToken} from \"../../contracts/mock/MockToken.sol\";\nimport {MatchingEngine} from \"../../contracts/safex/MatchingEngine.sol\";\nimport {OrderbookFactory} from \"../../contracts/safex/orderbooks/OrderbookFactory.sol\";\nimport {Orderbook} from \"../../contracts/safex/orderbooks/Orderbook.sol\";\nimport {Multicall3} from \"../Multicall3.sol\";\nimport {TokenDispenser} from \"../../contracts/safex/airdrops/TokenDispenser.sol\";\n\ncontract Deployer is Script {\n    function _setDeployer() internal {\n        uint256 deployerPrivateKey = vm.envUint(\"LINEA_TESTNET_DEPLOYER_KEY\");\n        vm.startBroadcast(deployerPrivateKey);\n    }\n}\n\ncontract DeployMulticall3 is Deployer {\n    function run() external {\n        _setDeployer();\n        new Multicall3();\n        vm.stopBroadcast();\n    }\n}\n\ncontract DeployWETH is Deployer {\n    function run() external {\n        _setDeployer();\n        vm.stopBroadcast();\n    }\n}\n\ncontract DeployTestnetAssets is Deployer {\n    function run() external {\n        _setDeployer();\n        MockToken feeToken = new MockToken(\"Standard\", \"STND\");\n        MockToken stablecoin = new MockToken(\"Stablecoin\", \"STBC\");\n        vm.stopBroadcast();\n    }\n}\n\ncontract DeployAll is Deployer {\n    // Change address constants on deploying to other networks or private keys\n    address constant deployer_address =\n        0x34CCCa03631830cD8296c172bf3c31e126814ce9;\n    address constant trader1_address =\n        0x6408fb579e106fC59f964eC33FE123738A2D0Da3;\n    address constant trader2_address =\n        0xf5aE3B9dF4e6972a229E7915D55F9FBE5900fE95;\n    address constant foundation_address =\n        0x34CCCa03631830cD8296c172bf3c31e126814ce9;\n    address constant weth_address = 0x2C1b868d6596a18e32E61B901E4060C872647b6C;\n    // seconds per block\n    uint32 spb = 12;\n    Treasury public treasury;\n\n    function run() external {\n        _setDeployer();\n\n        // DeployAssets\n        MockToken feeToken = new MockToken(\"Standard\", \"STND\");\n        MockToken stablecoin = new MockToken(\"Stablecoin\", \"STBC\");\n\n        // DeployContracts\n        OrderbookFactory orderbookFactory = new OrderbookFactory();\n        MatchingEngine matchingEngine = new MatchingEngine();\n        Membership membership = new Membership();\n        SABT sabt = new SABT();\n        membership.initialize(address(sabt), foundation_address, weth_address);\n        sabt.initialize(address(membership));\n        // Setup accountant and treasury\n        BlockAccountant accountant = new BlockAccountant();\n        accountant.initialize(\n            address(membership),\n            address(matchingEngine),\n            address(stablecoin),\n            spb\n        );\n        treasury = new Treasury();\n        treasury.set(address(membership), address(accountant), address(sabt));\n        matchingEngine.initialize(\n            address(orderbookFactory),\n            address(treasury),\n            weth_address\n        );\n        orderbookFactory.initialize(address(matchingEngine));\n        // Wire up matching engine with them\n        accountant.grantRole(\n            accountant.REPORTER_ROLE(),\n            address(treasury)\n        );\n        treasury.grantRole(treasury.REPORTER_ROLE(), address(matchingEngine));\n\n        // DistributeAssets\n        // Mint fee Token to the deployer, trader1, trader2\n        feeToken.mint(deployer_address, 1000000000000000000000000e18);\n        feeToken.mint(trader1_address, 100000e18);\n        feeToken.mint(trader2_address, 100000e18);\n\n        // Mint stablecoin to the deployer, trader1, trader2\n        stablecoin.mint(deployer_address, 1000000000000000000000000000e18);\n        stablecoin.mint(trader1_address, 100000e18);\n        stablecoin.mint(trader2_address, 100000e18);\n\n        // SetupSABTInitialParameters\n        // set Fee in membership contract\n        membership.setMembership(1, address(feeToken), 1000, 1000, 10000);\n\n        // Get membership\n        feeToken.approve(address(membership), 1e30);\n        membership.register(1, address(feeToken));\n        membership.subscribe(1, 1000000, address(feeToken));\n\n        // SetupSAFEXInitialParameters\n        // Setup pair between stablecoin and feeToken with price\n        feeToken.approve(address(matchingEngine), 100000e18);\n        matchingEngine.addPair(address(feeToken), address(stablecoin));\n\n        // make a price in matching engine where 1 feeToken = 1000 stablecoin with buy and sell order\n        feeToken.approve(address(matchingEngine), 100000e18);\n        stablecoin.approve(address(matchingEngine), 100000000e18);\n        // add limit orders\n        matchingEngine.limitSell(\n            address(feeToken),\n            address(stablecoin),\n            1000e8,\n            10000e18,\n            true,\n            1,\n            0,\n            msg.sender\n        );\n        matchingEngine.limitBuy(\n            address(feeToken),\n            address(stablecoin),\n            1000e8,\n            10000000e18,\n            false,\n            1,\n            1,\n            msg.sender\n        );\n\n        // DeployTokenDispenser\n        TokenDispenser dispenser = new TokenDispenser();\n\n        uint256 deposit_amount = 1e40;\n        uint256 airdrop_amount = 100000e18;\n\n        // AddAirdrop\n        feeToken.mint(deployer_address, deposit_amount);\n        feeToken.transfer(address(dispenser), deposit_amount);\n        dispenser.setTokenAmount(address(feeToken), airdrop_amount);\n\n        stablecoin.mint(deployer_address, deposit_amount);\n        stablecoin.transfer(address(dispenser), deposit_amount);\n        dispenser.setTokenAmount(address(stablecoin), airdrop_amount);\n\n        vm.stopBroadcast();\n    }\n}\n\ncontract DeployTestnetContracts is Deployer {\n    // Change address constants on deploying to other networks from DeployAssets\n    /// Second per block to finalize\n    uint32 constant spb = 12;\n    address constant deployer_address =\n        0x34CCCa03631830cD8296c172bf3c31e126814ce9;\n    address constant foundation_address =\n        0x34CCCa03631830cD8296c172bf3c31e126814ce9;\n    address constant weth = 0x2C1b868d6596a18e32E61B901E4060C872647b6C;\n    address constant feeToken = 0x0622C0b5F53FF7252A5F90b4031a9adaa67a2d02;\n    address constant stablecoin = 0x11a681c574F8e1d72DDCEEe0855032A77dfF8355;\n    Treasury public treasury;\n\n    function run() external {\n        _setDeployer();\n        OrderbookFactory orderbookFactory = new OrderbookFactory();\n        MatchingEngine matchingEngine = new MatchingEngine();\n        Membership membership = new Membership();\n        SABT sabt = new SABT();\n        membership.initialize(address(sabt), foundation_address, weth);\n        sabt.initialize(address(membership));\n        // Setup accountant and treasury\n        BlockAccountant accountant = new BlockAccountant();\n        accountant.initialize(\n            address(membership),\n            address(matchingEngine),\n            address(stablecoin),\n            spb\n        );\n        treasury = new Treasury();\n        treasury.set(address(membership), address(accountant), address(sabt));\n        matchingEngine.initialize(\n            address(orderbookFactory),\n            address(treasury),\n            weth\n        );\n        orderbookFactory.initialize(address(matchingEngine));\n        // Wire up matching engine with them\n        accountant.grantRole(\n            accountant.REPORTER_ROLE(),\n            address(treasury)\n        );\n        treasury.grantRole(treasury.REPORTER_ROLE(), address(matchingEngine));\n        vm.stopBroadcast();\n    }\n}\n\ncontract DistributeTestnetAssets is Deployer {\n    // Change address constants on deploying to other networks from DeployAssets\n    address constant deployer_address =\n        0x34CCCa03631830cD8296c172bf3c31e126814ce9;\n    address constant trader1_address =\n        0x6408fb579e106fC59f964eC33FE123738A2D0Da3;\n    address constant trader2_address =\n        0xf5aE3B9dF4e6972a229E7915D55F9FBE5900fE95;\n    address constant feeToken_address =\n        0x0622C0b5F53FF7252A5F90b4031a9adaa67a2d02;\n    address constant stablecoin_address =\n        0xfB4c8b2658AB2bf32ab5Fc1627f115974B52FeA7;\n\n    MockToken public feeToken = MockToken(feeToken_address);\n    MockToken public stablecoin = MockToken(stablecoin_address);\n\n    function run() external {\n        _setDeployer();\n        // Mint fee Token to the deployer, trader1, trader2\n        feeToken.mint(deployer_address, 1000000000000000000000000e18);\n        feeToken.mint(trader1_address, 100000e18);\n        feeToken.mint(trader2_address, 100000e18);\n\n        // Mint stablecoin to the deployer, trader1, trader2\n        stablecoin.mint(deployer_address, 1000000000000000000000000000e18);\n        stablecoin.mint(trader1_address, 100000e18);\n        stablecoin.mint(trader2_address, 100000e18);\n\n        vm.stopBroadcast();\n    }\n}\n\ncontract SetupSABTInitialParameters is Deployer {\n    // Change address constants on deploying to other networks from DeployAssets\n    address constant matching_engine_address =\n        0x8a22e83Aaf7E90eEab385C4d97cbD5F6a58d5DF7;\n    address constant membership_address =\n        0xd5EC00dbaDF8d9369e5b330645478aAFA298A73D;\n    address constant sabt_address = 0x240aA2c15fBf6F65882A847462b04d5DA51A37Df;\n    address constant feeToken_address =\n        0x0622C0b5F53FF7252A5F90b4031a9adaa67a2d02;\n    address constant stablecoin_address =\n        0x11a681c574F8e1d72DDCEEe0855032A77dfF8355;\n    address constant block_accountant_address =\n        0xb31e69f571c3B4219710931e86a9BC8b8378fb1E;\n    address constant treasury_address =\n        0x86b3Bd0C9896b97f6aCfBA87E6CEe0033FF708F8;\n    address constant deployer_address =\n        0x34CCCa03631830cD8296c172bf3c31e126814ce9;\n\n    Membership public membership = Membership(membership_address);\n    SABT public sabt = SABT(sabt_address);\n    MockToken public stablecoin = MockToken(stablecoin_address);\n    MockToken public feeToken = MockToken(feeToken_address);\n    BlockAccountant public accountant =\n        BlockAccountant(block_accountant_address);\n    Treasury public treasury = Treasury(treasury_address);\n\n    function run() external {\n        _setDeployer();\n        // set Fee in membership contract\n        membership.setMembership(1, feeToken_address, 1000, 1000, 10000);\n\n        // Get membership\n        feeToken.approve(membership_address, 1e30);\n        membership.register(1, feeToken_address);\n        membership.subscribe(1, 1000000, feeToken_address);\n\n        vm.stopBroadcast();\n    }\n}\n\ncontract SetupSAFEXInitialParameters is Deployer {\n    // Change address constants on deploying to other networks from DeployAssets\n    address constant matching_engine_address =\n        0x8a22e83Aaf7E90eEab385C4d97cbD5F6a58d5DF7;\n    address constant feeToken_address =\n        0xE57Cdf5796C2f5281EDF1B81129E1D4Ff9190815;\n    address constant stablecoin_address =\n        0xfB4c8b2658AB2bf32ab5Fc1627f115974B52FeA7;\n    MatchingEngine public matchingEngine =\n        MatchingEngine(payable(matching_engine_address));\n    MockToken public feeToken = MockToken(feeToken_address);\n    MockToken public stablecoin = MockToken(stablecoin_address);\n\n    function run() external {\n        _setDeployer();\n        // Setup pair between stablecoin and feeToken with price\n        feeToken.approve(address(matchingEngine), 100000e18);\n        matchingEngine.addPair(address(feeToken), address(stablecoin));\n\n        // make a price in matching engine where 1 feeToken = 1000 stablecoin with buy and sell order\n        feeToken.approve(address(matchingEngine), 100000e18);\n        stablecoin.approve(address(matchingEngine), 100000000e18);\n        // add limit orders\n        matchingEngine.limitSell(\n            address(feeToken),\n            address(stablecoin),\n            1000e8,\n            10000e18,\n            true,\n            1,\n            0,\n            msg.sender\n        );\n        matchingEngine.limitBuy(\n            address(feeToken),\n            address(stablecoin),\n            1000e8,\n            10000000e18,\n            false,\n            1,\n            1,\n            msg.sender\n        );\n        vm.stopBroadcast();\n    }\n}\n\ncontract DeployTokenDispenser is Deployer {\n    function run() external {\n        _setDeployer();\n        TokenDispenser dispenser = new TokenDispenser();\n        vm.stopBroadcast();\n    }\n}\n\ncontract AddAirdrop is Deployer {\n    address constant airdrop_token_address =\n        0xE57Cdf5796C2f5281EDF1B81129E1D4Ff9190815;\n    address constant dispenser_address =\n        0xA8800c10F7276E2cfe025aAc849b812A2eC601fF;\n    address constant deployer_address =\n        0x34CCCa03631830cD8296c172bf3c31e126814ce9;\n    MockToken public airdropToken = MockToken(airdrop_token_address);\n    TokenDispenser public dispenser = TokenDispenser(dispenser_address);\n    uint256 public deposit_amount = 1e40;\n    uint256 public airdrop_amount = 100000e18;\n\n    function run() external {\n        _setDeployer();\n        airdropToken.mint(deployer_address, deposit_amount);\n        airdropToken.transfer(dispenser_address, deposit_amount);\n        dispenser.setTokenAmount(airdrop_token_address, airdrop_amount);\n        vm.stopBroadcast();\n    }\n}\n\ncontract TestOrderbookSell is Deployer {\n    // Change address constants on deploying to other networks from DeployAssets\n    address constant matching_engine_address =\n        0xa7431faC42c7D5ff6C5EE297B9D65960B9970f12;\n    address constant feeToken_address =\n        0xE57Cdf5796C2f5281EDF1B81129E1D4Ff9190815;\n    address constant stablecoin_address =\n        0xfB4c8b2658AB2bf32ab5Fc1627f115974B52FeA7;\n    MatchingEngine public matchingEngine =\n        MatchingEngine(payable(matching_engine_address));\n    MockToken public feeToken = MockToken(feeToken_address);\n    MockToken public stablecoin = MockToken(stablecoin_address);\n    Orderbook public book;\n\n    function run() external {\n        _setDeployer();\n\n        \n\n        // make a price in matching engine where 1 feeToken = 1000 stablecoin with buy and sell order\n        feeToken.approve(address(matchingEngine), 100000e18);\n        stablecoin.approve(address(matchingEngine), 100000000e18);\n        // add limit orders\n        matchingEngine.limitSell(\n            address(feeToken),\n            address(stablecoin),\n            100002e6,\n            10000e18,\n            true,\n            1,\n            0,\n            msg.sender\n        );\n        //matchingEngine.getOrders(address(token1), address(token2), true, 0, 0);\n        uint256[] memory askPrices = matchingEngine.getPrices(\n            address(feeToken),\n            address(stablecoin),\n            false,\n            20\n        );\n        console.log(\"Bid prices: \");\n        for (uint256 i = 0; i < 3; i++) {\n            console.log(askPrices[i]);\n        }\n        (uint256 bidHead, uint256 askHead) = book.heads();\n        console.log(\"bidHead: \", bidHead);\n        console.log(\"askHead: \", askHead);\n        vm.stopBroadcast();\n    }\n}\n\ncontract TestGetPrices is Deployer {\n    // Change address constants on deploying to other networks from DeployAssets\n    address constant matching_engine_address =\n        0xa7431faC42c7D5ff6C5EE297B9D65960B9970f12;\n    address constant feeToken_address =\n        0xE57Cdf5796C2f5281EDF1B81129E1D4Ff9190815;\n    address constant stablecoin_address =\n        0xfB4c8b2658AB2bf32ab5Fc1627f115974B52FeA7;\n    MatchingEngine public matchingEngine =\n        MatchingEngine(payable(matching_engine_address));\n    MockToken public feeToken = MockToken(feeToken_address);\n    MockToken public stablecoin = MockToken(stablecoin_address);\n\n    function run() external {\n        _setDeployer();\n    \n        uint256[] memory bidPrices = matchingEngine.getPrices(\n            address(feeToken),\n            address(stablecoin),\n            true,\n            20\n        );\n        console.log(\"Ask prices: \");\n        for (uint256 i = 0; i < 4; i++) {\n            console.log(bidPrices[i]);\n        }\n        //matchingEngine.getOrders(address(token1), address(token2), true, 0, 0);\n        uint256[] memory askPrices = matchingEngine.getPrices(\n            address(feeToken),\n            address(stablecoin),\n            false,\n            20\n        );\n        console.log(\"Bid prices: \");\n        for (uint256 i = 0; i < 3; i++) {\n            console.log(askPrices[i]);\n        }\n\n        vm.stopBroadcast();\n    }\n}\n"
        },
        "test/sabt/Membership.t.sol": {
            "content": "pragma solidity >=0.8;\nimport {console} from \"forge-std/console.sol\";\nimport {stdStorage, StdStorage, Test} from \"forge-std/Test.sol\";\nimport {Utils} from \"../utils/Utils.sol\";\nimport {SABT} from \"../../contracts/sabt/SABT.sol\";\nimport {BlockAccountant} from \"../../contracts/sabt/BlockAccountant.sol\";\nimport {Membership} from \"../../contracts/sabt/Membership.sol\";\nimport {MatchingEngine} from \"../../contracts/safex/MatchingEngine.sol\";\nimport {OrderbookFactory} from \"../../contracts/safex/orderbooks/OrderbookFactory.sol\";\nimport {Treasury} from \"../../contracts/sabt/Treasury.sol\";\nimport {TreasuryLib} from \"../../contracts/sabt/libraries/TreasuryLib.sol\";\nimport {MockToken} from \"../../contracts/mock/MockToken.sol\";\nimport {Orderbook} from \"../../contracts/safex/orderbooks/Orderbook.sol\";\nimport {WETH9} from \"../../contracts/mock/WETH9.sol\";\n\ncontract MembershipBaseSetup is Test {\n    Membership public membership;\n    Treasury public treasury;\n    BlockAccountant public accountant;\n    SABT public sabt;\n    MockToken public stablecoin;\n    MockToken public feeToken;\n    WETH9 public weth;\n    address public foundation;\n    address public reporter;\n    OrderbookFactory orderbookFactory;\n    \n    Utils public utils;\n    MatchingEngine public matchingEngine;\n    address payable[] public users;\n    address public trader1;\n    address public trader2;\n    address public booker;\n    address public attacker;\n\n    function setUp() public {\n        utils = new Utils();\n        users = utils.addUsers(6, users);\n        trader1 = users[0];\n        vm.label(trader1, \"Trader 1\");\n        trader2 = users[1];\n        vm.label(trader2, \"Trader 2\");\n        booker = users[2];\n        vm.label(booker, \"Booker\");\n        attacker = users[3];\n        vm.label(attacker, \"Attacker\");\n        foundation = users[4];\n        vm.label(foundation, \"Foundation\");\n        reporter = users[5];\n        vm.label(reporter, \"Reporter\");\n        feeToken = new MockToken(\"FeeToken\", \"FEE\");\n        stablecoin = new MockToken(\"Stablecoin\", \"STBC\");\n        membership = new Membership();\n        sabt = new SABT();\n        accountant = new BlockAccountant();\n        treasury = new Treasury();\n        matchingEngine = new MatchingEngine();\n        orderbookFactory = new OrderbookFactory();\n        membership.initialize(address(sabt), foundation, address(weth));\n        sabt.initialize(address(membership));\n        treasury.set(address(membership), address(accountant), address(sabt));\n        matchingEngine.initialize(\n            address(orderbookFactory),\n            address(treasury),\n            address(weth)\n        );\n        orderbookFactory.initialize(address(matchingEngine));\n        accountant.initialize(\n            address(membership), address(matchingEngine), address(stablecoin), 1\n        );\n        accountant.grantRole(\n            accountant.REPORTER_ROLE(),\n            address(treasury)\n        );\n        treasury.grantRole(treasury.REPORTER_ROLE(), address(matchingEngine));\n        \n        feeToken.mint(trader1, 100000000e18);\n        feeToken.mint(trader2, 10000e18);\n        feeToken.mint(booker, 100000e18);\n        stablecoin.mint(trader1, 10000e18);\n        stablecoin.mint(trader2, 10000e18);\n        stablecoin.mint(address(treasury), 10000e18);\n        vm.prank(trader1);\n        feeToken.approve(address(membership), 10000e18);\n        vm.prank(trader1);\n        stablecoin.approve(address(membership), 10000e18);\n        // initialize membership contract\n        treasury.setClaim(1, 100);\n        // initialize SABT\n        // set Fee in membership contract\n        membership.setMembership(9, address(feeToken), 1000, 1000, 10000);\n        membership.setMembership(10, address(feeToken), 1000, 1000, 10000);\n        // membership.setMembership(2, address(feeToken), 1000, 1000, 10000, 10);\n        // set stablecoin price\n        vm.prank(booker);\n        feeToken.approve(address(matchingEngine), 100000e18);\n        vm.prank(booker);\n        matchingEngine.addPair(address(feeToken), address(stablecoin));\n        // Approve the matching engine to spend the trader's tokens\n        vm.prank(trader1);\n        stablecoin.approve(address(matchingEngine), 10000e18);\n        // Approve the matching engine to spend the trader's tokens\n        vm.prank(trader2);\n        feeToken.approve(address(matchingEngine), 10000e18);\n        membership.grantRole(membership.DEFAULT_ADMIN_ROLE(), trader1);\n        // register trader1 to investor\n        vm.prank(trader1);\n        membership.register(9, address(feeToken));\n        // subscribe\n        vm.prank(trader1);\n        feeToken.approve(address(membership), 1e25);\n        vm.prank(trader1);\n        membership.subscribe(1, 10000, address(feeToken));\n        // mine 1000 blocks\n        utils.mineBlocks(1000);\n        // make a price in matching engine where 1 feeToken = 1000 stablecoin with buy and sell order\n        vm.prank(trader2);\n        matchingEngine.limitSell(\n            address(feeToken),\n            address(stablecoin),\n            10000e8,\n            1000e10,\n            true,\n            1,\n            1,\n            trader2\n        );\n        // match the order to make lmp so that accountant can report\n        vm.prank(trader1);\n        feeToken.approve(address(matchingEngine), 10000e18);\n        vm.prank(trader1);\n        matchingEngine.limitBuy(\n            address(feeToken),\n            address(stablecoin),\n            10000e8,\n            1000e10,\n            true,\n            1,\n            1,\n            trader1\n        );\n    }\n}\n\ncontract MembershipTest is MembershipBaseSetup {\n\n    function mSetUp() internal {\n        super.setUp();\n        vm.prank(trader1);\n        feeToken.approve(address(membership), 1e40);\n    }\n\n    // register with fee token succeeds\n    function testRegisterWithMembership() public {\n        mSetUp();\n        vm.prank(trader1);\n        membership.register(9, address(feeToken));\n    }\n\n    // register with multiple fee token succeeds\n    function testRegisterWithMultipleFeeTokenSucceeds() public {\n        mSetUp();\n        membership.setMembership(9, address(feeToken), 1000, 1000, 10000);\n        vm.startPrank(trader1);\n        feeToken.approve(address(membership), 1e40);\n        membership.register(9, address(feeToken));\n    }\n\n    // registration is only possible with assigned token\n    function testRegisterWithUnassignedTokenFails() public {\n        mSetUp();\n        vm.prank(trader1);\n        vm.expectRevert();\n        membership.register(9, address(stablecoin));\n    }\n\n    // membership can be transferred\n    function testMembershipCanTransfer() public {\n        mSetUp();\n        vm.prank(trader1);\n        membership.register(9, address(feeToken));\n        vm.prank(trader1);\n        sabt.transfer(trader2, 1);\n    }\n\n    // membership shows the right json file for uri\n    function testMembershipShowsRightJsonFileForUri() public {\n        mSetUp();\n        vm.prank(trader1);\n        membership.register(9, address(feeToken));\n        vm.prank(trader1);\n        string memory uri = sabt.uri(1);\n        assert(\n            keccak256(abi.encodePacked(uri)) ==\n                keccak256(\n                    abi.encodePacked(\n                        \"https://raw.githubusercontent.com/standardweb3/nft-arts/main/nfts/sabt/9\"\n                    )\n                )\n        );\n    }\n}\n\ncontract SubscriptionTest is MembershipBaseSetup {\n    function subcSetUp() internal {\n        super.setUp();\n        vm.prank(trader1);\n        feeToken.approve(address(membership), 1e40);\n    }\n\n    // subscription can be canceled and sends closed payment to treasury\n    function testCancellationWorks() public {\n        subcSetUp();\n        vm.startPrank(trader1);\n        membership.register(9, address(feeToken));\n        membership.subscribe(1, 100, address(feeToken));\n        membership.unsubscribe(1);\n    }\n\n    // subscription can be reinititated and sends closed payment to treasury\n    function testReinitiateSubscriptionWorks() public {\n        subcSetUp();\n        vm.startPrank(trader1);\n        membership.register(9, address(feeToken));\n        membership.subscribe(1, 10000, address(feeToken));\n        membership.unsubscribe(1);\n        membership.subscribe(1, 10000, address(feeToken));\n    }\n\n    // subscription can be done on only one token\n    function testSubscriptionCanOnlyBeDoneOnOneToken() public {\n        subcSetUp();\n        vm.startPrank(trader1);\n        membership.register(9, address(feeToken));\n        membership.subscribe(1, 10000, address(feeToken));\n        vm.expectRevert();\n        membership.subscribe(1, 10000, address(stablecoin));\n    }\n\n    // trader point can be migrated into other ABT if one owns them all\n    function testTpMigrationBetweenSameOwnerWorks() public {\n        subcSetUp();\n        vm.startPrank(trader1);\n        membership.balanceOf(address(trader1), 1);\n        membership.register(9, address(feeToken));\n        membership.subscribe(1, 10000, address(feeToken));\n        accountant.migrate(1, 2, 0, 1);\n    }\n\n    // subscribing with stnd shows subscribed STND amount\n    function testSubSTNDIsChangedOnSTNDSubscription() public {\n        subcSetUp();\n        membership.setSTND(address(feeToken));\n        vm.startPrank(trader1);\n        membership.register(9, address(feeToken));\n        membership.subscribe(1, 10000, address(feeToken));\n        uint256 subSTND = membership.getSubSTND(1);\n        assert(subSTND == 10000000);\n    }\n}\n\ncontract MembershipTresuryTest is MembershipBaseSetup {\n    function tSetUp() internal {\n        super.setUp();\n        vm.prank(trader1);\n        feeToken.approve(address(membership), 1e40);\n    }\n\n    // members can exchange TP with token reward only after an era passes\n    function testExchangeWorksOnlyIfEraPasses() public {\n        tSetUp();\n        vm.startPrank(trader1);\n        vm.expectRevert(\n            abi.encodeWithSelector(TreasuryLib.EraNotPassed.selector, 1, 0)\n        );\n        treasury.exchange(address(feeToken), 1, 1, 1000);\n    }\n\n    // early adoptors can settle share of revenue from foundation\n    function testClaimtreasuryWorksWorksForOnlyEarlyAdoptors() public {\n        tSetUp();\n        membership.setMembership(1, address(feeToken), 1000, 1000, 10000);\n        vm.startPrank(trader1);\n        membership.register(1, address(feeToken));\n        membership.register(10, address(feeToken));\n        membership.subscribe(1, 10000, address(feeToken));\n        membership.unsubscribe(1);\n        membership.subscribe(1, 10000, address(feeToken));\n        vm.expectRevert(\n            abi.encodeWithSelector(TreasuryLib.InvalidMetaId.selector, 9, 2, 1)\n        );\n        treasury.claim(address(feeToken), 0, 2);\n        vm.expectRevert(\n            abi.encodeWithSelector(TreasuryLib.InvalidMetaId.selector, 9, 3, 10)\n        );\n        treasury.claim(address(feeToken), 0, 3);\n    }\n\n    // Only foundation can settle share of revenue on treasury\n    function testSettletreasuryWorksForOnlyFoundation() public {\n        tSetUp();\n        vm.startPrank(trader1);\n        membership.setMembership(1, address(feeToken), 1000, 1000, 10000);\n        membership.register(1, address(feeToken));\n        membership.register(9, address(feeToken));\n        membership.subscribe(1, 10000, address(feeToken));\n        vm.expectRevert(\n            abi.encodeWithSelector(TreasuryLib.InvalidMetaId.selector, 10, 2, 1)\n        );\n        treasury.settle(address(feeToken), 0, 2);\n        vm.expectRevert(\n            abi.encodeWithSelector(TreasuryLib.InvalidMetaId.selector, 10, 3, 9)\n        );\n        treasury.settle(address(feeToken), 0, 3);\n    }\n}\n"
        },
        "test/safex/OrderbookBaseSetup.sol": {
            "content": "pragma solidity >=0.8;\n\nimport {console} from \"forge-std/console.sol\";\nimport {stdStorage, StdStorage, Test} from \"forge-std/Test.sol\";\nimport {MockToken} from \"../../contracts/mock/MockToken.sol\";\nimport {MockBase} from \"../../contracts/mock/MockBase.sol\";\nimport {MockQuote} from \"../../contracts/mock/MockQuote.sol\";\nimport {MockBTC} from \"../../contracts/mock/MockBTC.sol\";\nimport {ErrToken} from \"../../contracts/mock/MockTokenOver18Decimals.sol\";\nimport {Utils} from \"../utils/Utils.sol\";\nimport {MatchingEngine} from \"../../contracts/safex/MatchingEngine.sol\";\nimport {OrderbookFactory} from \"../../contracts/safex/orderbooks/OrderbookFactory.sol\";\nimport {Orderbook} from \"../../contracts/safex/orderbooks/Orderbook.sol\";\nimport {ExchangeOrderbook} from \"../../contracts/safex/libraries/ExchangeOrderbook.sol\";\nimport {IOrderbookFactory} from \"../../contracts/safex/interfaces/IOrderbookFactory.sol\";\nimport {WETH9} from \"../../contracts/mock/WETH9.sol\";\nimport {Treasury} from \"../../contracts/sabt/Treasury.sol\";\n\ncontract BaseSetup is Test {\n    Utils public utils;\n    MatchingEngine public matchingEngine;\n    WETH9 public weth;\n    OrderbookFactory public orderbookFactory;\n    Orderbook public book;\n    MockBase public token1;\n    MockQuote public token2;\n    MockBTC public btc;\n    MockToken public feeToken;\n    Treasury public treasury;\n    address payable[] public users;\n    address public trader1;\n    address public trader2;\n    address public booker;\n    address public attacker;\n\n    function setUp() public virtual {\n        utils = new Utils();\n        users = utils.createUsers(4);\n        trader1 = users[0];\n        vm.label(trader1, \"Trader 1\");\n        trader2 = users[1];\n        vm.label(trader2, \"Trader 2\");\n        booker = users[2];\n        vm.label(booker, \"Booker\");\n        attacker = users[3];\n        vm.label(attacker, \"Attacker\");\n        token1 = new MockBase(\"Base\", \"BASE\");\n        token2 = new MockQuote(\"Quote\", \"QUOTE\");\n        btc = new MockBTC(\"Bitcoin\", \"BTC\");\n        weth = new WETH9();\n\n        token1.mint(trader1, 10000000e18);\n        token2.mint(trader1, 10000000e18);\n        btc.mint(trader1, 10000000e18);\n        token1.mint(trader2, 10000000e18);\n        token2.mint(trader2, 10000000e18);\n        btc.mint(trader2, 10000000e18);\n        feeToken = new MockToken(\"Fee Token\", \"FEE\");\n        feeToken.mint(booker, 40000e18);\n        matchingEngine = new MatchingEngine();\n        orderbookFactory = new OrderbookFactory();\n        orderbookFactory.initialize(address(matchingEngine));\n        treasury = new Treasury();\n        treasury.set(address(0), address(0), address(0));\n        matchingEngine.initialize(\n            address(orderbookFactory),\n            address(treasury),\n            address(weth)\n        );\n\n        vm.prank(trader1);\n        token1.approve(address(matchingEngine), 10000000e18);\n        vm.prank(trader1);\n        token2.approve(address(matchingEngine), 10000000e18);\n        vm.prank(trader1);\n        btc.approve(address(matchingEngine), 10000000e18);\n        vm.prank(trader2);\n        token1.approve(address(matchingEngine), 10000000e18);\n        vm.prank(trader2);\n        token2.approve(address(matchingEngine), 10000e18);\n        vm.prank(trader2);\n        btc.approve(address(matchingEngine), 10000e8);\n        vm.prank(booker);\n        feeToken.approve(address(matchingEngine), 40000e18);\n    }\n\n    function _showOrderbook(\n        MatchingEngine matchingEngine,\n        address base,\n        address quote\n    ) internal view {\n        (uint256 bidHead, uint256 askHead) = matchingEngine.heads(base, quote);\n        console.log(\"Bid Head: \", bidHead);\n        console.log(\"Ask Head: \", askHead);\n        uint256[] memory bidPrices = matchingEngine.getPrices(\n            address(base),\n            address(quote),\n            true,\n            20\n        );\n        uint256[] memory askPrices = matchingEngine.getPrices(\n            address(base),\n            address(quote),\n            false,\n            20\n        );\n        console.log(\"Ask prices: \");\n        for (uint256 i = 0; i < 6; i++) {\n            console.log(\"AskPrice: \", askPrices[i]);\n            console.log(\"Ask Orders: \");\n            uint32[] memory askOrderIds = matchingEngine.getOrderIds(\n                address(base),\n                address(quote),\n                false,\n                askPrices[i],\n                10\n            );\n            ExchangeOrderbook.Order[] memory askOrders = matchingEngine\n                .getOrders(\n                    address(base),\n                    address(quote),\n                    false,\n                    askPrices[i],\n                    10\n                );\n            for (uint256 j = 0; j < 10; j++) {\n                console.log(\n                    askOrderIds[j],\n                    askOrders[j].owner,\n                    askOrders[j].depositAmount\n                );\n            }\n        }\n\n        console.log(\"Bid prices: \");\n        for (uint256 i = 0; i < 6; i++) {\n            console.log(\"Bid Price: \", bidPrices[i]);\n            console.log(\"Bid Orders: \");\n            uint32[] memory bidOrderIds = matchingEngine.getOrderIds(\n                address(base),\n                address(quote),\n                false,\n                bidPrices[i],\n                10\n            );\n            ExchangeOrderbook.Order[] memory bidOrders = matchingEngine\n                .getOrders(\n                    address(base),\n                    address(quote),\n                    true,\n                    bidPrices[i],\n                    10\n                );\n            for (uint256 j = 0; j < 10; j++) {\n                console.log(\n                    bidOrderIds[j],\n                    bidOrders[j].owner,\n                    bidOrders[j].depositAmount\n                );\n            }\n        }\n    }\n\n    function _initOrderbook() internal {}\n}"
        },
        "test/safex/SAFEXFeeTierSetup.sol": {
            "content": "pragma solidity >=0.8;\n\nimport {BaseSetup} from \"./OrderbookBaseSetup.sol\";\n\nimport {console} from \"forge-std/console.sol\";\nimport {stdStorage, StdStorage, Test} from \"forge-std/Test.sol\";\nimport {SABT} from \"../../contracts/sabt/SABT.sol\";\nimport {BlockAccountant} from \"../../contracts/sabt/BlockAccountant.sol\";\nimport {Membership} from \"../../contracts/sabt/Membership.sol\";\nimport {MatchingEngine} from \"../../contracts/safex/MatchingEngine.sol\";\nimport {OrderbookFactory} from \"../../contracts/safex/orderbooks/OrderbookFactory.sol\";\nimport {Treasury} from \"../../contracts/sabt/Treasury.sol\";\nimport {MockToken} from \"../../contracts/mock/MockToken.sol\";\nimport {Orderbook} from \"../../contracts/safex/orderbooks/Orderbook.sol\";\nimport {WETH9} from \"../../contracts/mock/WETH9.sol\";\nimport {Treasury} from \"../../contracts/sabt/Treasury.sol\";\n\ncontract SAFEXFeeTierSetup is BaseSetup {\n    OrderbookFactory public orderbookFactoryFeeTier;\n    MatchingEngine public matchingEngineFeeTier;\n    Membership public membership;\n    BlockAccountant public accountant;\n    SABT public sabt;\n    MockToken public stablecoin;\n    address public foundation;\n    address public reporter;\n\n    function feeTierSetUp() public {\n        users = utils.addUsers(2, users);\n        foundation = users[4];\n        reporter = users[5];\n\n        stablecoin = new MockToken(\"Stablecoin\", \"STBC\");\n        membership = new Membership();\n        sabt = new SABT();\n\n        orderbookFactoryFeeTier = new OrderbookFactory();\n        matchingEngineFeeTier = new MatchingEngine();\n\n        accountant = new BlockAccountant();\n        accountant.initialize(\n            address(membership),\n            address(matchingEngineFeeTier),\n            address(stablecoin),\n            1\n        );\n        treasury = new Treasury();\n        treasury.set(address(membership), address(accountant), address(sabt));\n        orderbookFactoryFeeTier.initialize(address(matchingEngineFeeTier));\n        matchingEngineFeeTier.initialize(\n            address(orderbookFactoryFeeTier),\n            address(treasury),\n            address(weth)\n        );\n        accountant.grantRole(accountant.REPORTER_ROLE(), address(treasury));\n        treasury.grantRole(treasury.REPORTER_ROLE(), address(matchingEngineFeeTier));\n\n        feeToken.mint(trader1, 10e41);\n        feeToken.mint(trader2, 100000e18);\n        feeToken.mint(booker, 100000e18);\n        stablecoin.mint(trader1, 10000e18);\n        stablecoin.mint(trader2, 10000e18);\n        vm.prank(trader1);\n        feeToken.approve(address(membership), 10000e18);\n        vm.prank(trader1);\n        stablecoin.approve(address(membership), 10000e18);\n\n        // initialize  membership contract\n        membership.initialize(address(sabt), foundation, address(weth));\n        // initialize SABT\n        sabt.initialize(address(membership));\n        membership.setMembership(1, address(feeToken), 1000, 1000, 10000);\n\n        // set stablecoin price\n        vm.prank(booker);\n        feeToken.approve(address(matchingEngineFeeTier), 100000e18);\n        vm.prank(booker);\n        matchingEngineFeeTier.addPair(address(feeToken), address(stablecoin));\n        // Approve the matching engine to spend the trader's tokens\n        vm.prank(trader1);\n        stablecoin.approve(address(matchingEngineFeeTier), 10000e18);\n        // Approve the matching engine to spend the trader's tokens\n        vm.prank(trader2);\n        feeToken.approve(address(matchingEngineFeeTier), 10000e18);\n\n        // register trader1 into membership\n        vm.prank(trader1);\n        feeToken.approve(address(membership), 10000e18);\n        vm.prank(trader1);\n        membership.register(1, address(feeToken));\n        vm.prank(trader2);\n        feeToken.approve(address(membership), 10000e18);\n        vm.prank(trader2);\n        membership.register(1, address(feeToken));\n        assert(sabt.balanceOf(trader2, 2) == 1);\n\n        // subscribe\n        vm.prank(trader1);\n        feeToken.approve(address(membership), 1e40);\n        vm.prank(trader1);\n        membership.subscribe(1, 10000, address(feeToken));\n        feeToken.mint(trader2, 1e40);\n        vm.prank(trader2);\n        feeToken.approve(address(membership), 1e40);\n        vm.prank(trader2);\n        membership.subscribe(2, 10000, address(feeToken));\n\n        // mine 1000 blocks\n        utils.mineBlocks(1000);\n        console.log(\"Block number after mining 1000 blocks: \", block.number);\n        console.log(\n            \"Financial block where accountant started its accounting: \",\n            accountant.fb()\n        );\n    }\n}\n\n"
        },
        "test/safex/SafexFeeTierSetup.sol": {
            "content": "pragma solidity >=0.8;\n\nimport {BaseSetup} from \"./OrderbookBaseSetup.sol\";\n\nimport {console} from \"forge-std/console.sol\";\nimport {stdStorage, StdStorage, Test} from \"forge-std/Test.sol\";\nimport {SABT} from \"../../contracts/sabt/SABT.sol\";\nimport {BlockAccountant} from \"../../contracts/sabt/BlockAccountant.sol\";\nimport {Membership} from \"../../contracts/sabt/Membership.sol\";\nimport {MatchingEngine} from \"../../contracts/safex/MatchingEngine.sol\";\nimport {OrderbookFactory} from \"../../contracts/safex/orderbooks/OrderbookFactory.sol\";\nimport {Treasury} from \"../../contracts/sabt/Treasury.sol\";\nimport {MockToken} from \"../../contracts/mock/MockToken.sol\";\nimport {Orderbook} from \"../../contracts/safex/orderbooks/Orderbook.sol\";\nimport {WETH9} from \"../../contracts/mock/WETH9.sol\";\nimport {Treasury} from \"../../contracts/sabt/Treasury.sol\";\n\ncontract SAFEXFeeTierSetup is BaseSetup {\n    OrderbookFactory public orderbookFactoryFeeTier;\n    MatchingEngine public matchingEngineFeeTier;\n    Membership public membership;\n    BlockAccountant public accountant;\n    SABT public sabt;\n    MockToken public stablecoin;\n    address public foundation;\n    address public reporter;\n\n    function feeTierSetUp() public {\n        users = utils.addUsers(2, users);\n        foundation = users[4];\n        reporter = users[5];\n\n        stablecoin = new MockToken(\"Stablecoin\", \"STBC\");\n        membership = new Membership();\n        sabt = new SABT();\n\n        orderbookFactoryFeeTier = new OrderbookFactory();\n        matchingEngineFeeTier = new MatchingEngine();\n\n        accountant = new BlockAccountant();\n        accountant.initialize(\n            address(membership),\n            address(matchingEngineFeeTier),\n            address(stablecoin),\n            1\n        );\n        treasury = new Treasury();\n        treasury.set(address(membership), address(accountant), address(sabt));\n        orderbookFactoryFeeTier.initialize(address(matchingEngineFeeTier));\n        matchingEngineFeeTier.initialize(\n            address(orderbookFactoryFeeTier),\n            address(treasury),\n            address(weth)\n        );\n        accountant.grantRole(accountant.REPORTER_ROLE(), address(treasury));\n        treasury.grantRole(treasury.REPORTER_ROLE(), address(matchingEngineFeeTier));\n\n        feeToken.mint(trader1, 10e41);\n        feeToken.mint(trader2, 100000e18);\n        feeToken.mint(booker, 100000e18);\n        stablecoin.mint(trader1, 10000e18);\n        stablecoin.mint(trader2, 10000e18);\n        vm.prank(trader1);\n        feeToken.approve(address(membership), 10000e18);\n        vm.prank(trader1);\n        stablecoin.approve(address(membership), 10000e18);\n\n        // initialize  membership contract\n        membership.initialize(address(sabt), foundation, address(weth));\n        // initialize SABT\n        sabt.initialize(address(membership));\n        membership.setMembership(1, address(feeToken), 1000, 1000, 10000);\n\n        // set stablecoin price\n        vm.prank(booker);\n        feeToken.approve(address(matchingEngineFeeTier), 100000e18);\n        vm.prank(booker);\n        matchingEngineFeeTier.addPair(address(feeToken), address(stablecoin));\n        // Approve the matching engine to spend the trader's tokens\n        vm.prank(trader1);\n        stablecoin.approve(address(matchingEngineFeeTier), 10000e18);\n        // Approve the matching engine to spend the trader's tokens\n        vm.prank(trader2);\n        feeToken.approve(address(matchingEngineFeeTier), 10000e18);\n\n        // register trader1 into membership\n        vm.prank(trader1);\n        feeToken.approve(address(membership), 10000e18);\n        vm.prank(trader1);\n        membership.register(1, address(feeToken));\n        vm.prank(trader2);\n        feeToken.approve(address(membership), 10000e18);\n        vm.prank(trader2);\n        membership.register(1, address(feeToken));\n        assert(sabt.balanceOf(trader2, 2) == 1);\n\n        // subscribe\n        vm.prank(trader1);\n        feeToken.approve(address(membership), 1e40);\n        vm.prank(trader1);\n        membership.subscribe(1, 10000, address(feeToken));\n        feeToken.mint(trader2, 1e40);\n        vm.prank(trader2);\n        feeToken.approve(address(membership), 1e40);\n        vm.prank(trader2);\n        membership.subscribe(2, 10000, address(feeToken));\n\n        // mine 1000 blocks\n        utils.mineBlocks(1000);\n        console.log(\"Block number after mining 1000 blocks: \", block.number);\n        console.log(\n            \"Financial block where accountant started its accounting: \",\n            accountant.fb()\n        );\n    }\n}\n\n"
        },
        "test/safex/orderbook/Cancel.t.sol": {
            "content": "pragma solidity >=0.8;\n\nimport {MockToken} from \"../../../contracts/mock/MockToken.sol\";\nimport {MockBase} from \"../../../contracts/mock/MockBase.sol\";\nimport {MockQuote} from \"../../../contracts/mock/MockQuote.sol\";\nimport {MockBTC} from \"../../../contracts/mock/MockBTC.sol\";\nimport {ErrToken} from \"../../../contracts/mock/MockTokenOver18Decimals.sol\";\nimport {Utils} from \"../../utils/Utils.sol\";\nimport {MatchingEngine} from \"../../../contracts/safex/MatchingEngine.sol\";\nimport {OrderbookFactory} from \"../../../contracts/safex/orderbooks/OrderbookFactory.sol\";\nimport {Orderbook} from \"../../../contracts/safex/orderbooks/Orderbook.sol\";\nimport {ExchangeOrderbook} from \"../../../contracts/safex/libraries/ExchangeOrderbook.sol\";\nimport {IOrderbookFactory} from \"../../../contracts/safex/interfaces/IOrderbookFactory.sol\";\nimport {WETH9} from \"../../../contracts/mock/WETH9.sol\";\nimport {Treasury} from \"../../../contracts/sabt/Treasury.sol\";\nimport {BaseSetup} from \"../OrderbookBaseSetup.sol\";\nimport {console} from \"forge-std/console.sol\";\nimport {stdStorage, StdStorage, Test} from \"forge-std/Test.sol\";\n\ncontract CancelTest is BaseSetup {\n\n    function testCancelAtPriceZeroPasses() public {\n        vm.prank(booker);\n        matchingEngine.addPair(address(token1), address(token2));\n        book = Orderbook(\n            payable(orderbookFactory.getPair(address(token1), address(token2)))\n        );\n        vm.prank(trader1);\n        // placeBid or placeAsk two of them is using the _insertId function it will revert\n        // because the program will enter the \"if (amount > self.orders[head].depositAmount).\"\n        // statement, and eventually, it will cause an infinite loop.\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            500000000,\n            10,\n            true,\n            2,\n            0,\n            trader1\n        );\n\n        vm.prank(trader1);\n        //vm.expectRevert();\n        matchingEngine.cancelOrder(\n            address(token1),\n            address(token2),\n            false,\n            1,\n            0\n        );\n    }\n\n    function testCancelAtPriceWhateverPasses() public {\n        vm.prank(booker);\n        matchingEngine.addPair(address(token1), address(token2));\n        book = Orderbook(\n            payable(orderbookFactory.getPair(address(token1), address(token2)))\n        );\n        vm.prank(trader1);\n        // placeBid or placeAsk two of them is using the _insertId function it will revert\n        // because the program will enter the \"if (amount > self.orders[head].depositAmount).\"\n        // statement, and eventually, it will cause an infinite loop.\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            500000000,\n            10,\n            true,\n            2,\n            0,\n            trader1\n        );\n\n        vm.prank(trader1);\n        //vm.expectRevert();\n        matchingEngine.cancelOrder(\n            address(token1),\n            address(token2),\n            false,\n            1,\n            0\n        );\n    }\n\n    // edge cases on cancelling orders\n    function testCancelEdgeCase() public {\n        super.setUp();\n        vm.prank(booker);\n        matchingEngine.addPair(address(token1), address(token2));\n        book = Orderbook(\n            payable(orderbookFactory.getPair(address(token1), address(token2)))\n        );\n        vm.prank(trader1);\n        // placeBid or placeAsk two of them is using the _insertId function it will revert\n        // because the program will enter the \"if (amount > self.orders[head].depositAmount).\"\n        // statement, and eventually, it will cause an infinite loop.\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            500000000,\n            10,\n            true,\n            2,\n            0,\n            trader1\n        );\n\n        vm.prank(trader1);\n        //vm.expectRevert(\"OutOfGas\");\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            100000000,\n            10,\n            true,\n            2,\n            0,\n            trader1\n        );\n\n        vm.prank(trader1);\n        matchingEngine.limitBuy(\n            address(token1),\n            address(token2),\n            90000000,\n            10,\n            true,\n            5,\n            0,\n            trader1\n        );\n\n        vm.prank(trader1);\n        matchingEngine.limitBuy(\n            address(token1),\n            address(token2),\n            500000000,\n            10,\n            true,\n            5,\n            0,\n            trader1\n        );\n\n        _showOrderbook(matchingEngine, address(token1), address(token2));\n\n        for (uint256 i = 0; i < 10; i++) {\n            vm.prank(trader1);\n            matchingEngine.limitSell(\n                address(token1),\n                address(token2),\n                500000000,\n                i + 1,\n                true,\n                2,\n                0,\n                trader1\n            );\n        }\n\n        // cancel order\n        vm.prank(trader1);\n        matchingEngine.cancelOrder(\n            address(token1),\n            address(token2),\n            false,\n            1,\n            0\n        );\n\n        // recheck orders\n        _showOrderbook(matchingEngine, address(token1), address(token2));\n\n        // cancel order\n        vm.prank(trader1);\n        matchingEngine.cancelOrder(\n            address(token1),\n            address(token2),\n            false,\n            11,\n            0\n        );\n\n        // recheck orders\n        _showOrderbook(matchingEngine, address(token1), address(token2));\n\n        // limit buy to check passing cancelled order\n        vm.prank(trader1);\n        matchingEngine.limitBuy(\n            address(token1),\n            address(token2),\n            500000000,\n            55,\n            true,\n            5,\n            0,\n            trader1\n        );\n\n        // recheck orders\n        _showOrderbook(matchingEngine, address(token1), address(token2));\n    }\n\n    function testCancelEdgeCase2() public {\n        super.setUp();\n        vm.prank(booker);\n        matchingEngine.addPair(address(token1), address(token2));\n        book = Orderbook(\n            payable(orderbookFactory.getPair(address(token1), address(token2)))\n        );\n        vm.prank(trader1);\n        // placeBid or placeAsk two of them is using the _insertId function it will revert\n        // because the program will enter the \"if (amount > self.orders[head].depositAmount).\"\n        // statement, and eventually, it will cause an infinite loop.\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            500000000,\n            10,\n            true,\n            2,\n            0,\n            trader1\n        );\n\n        vm.prank(trader1);\n        //vm.expectRevert(\"OutOfGas\");\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            100000000,\n            10,\n            true,\n            2,\n            0,\n            trader1\n        );\n\n        vm.prank(trader1);\n        matchingEngine.limitBuy(\n            address(token1),\n            address(token2),\n            90000000,\n            10,\n            true,\n            5,\n            0,\n            trader1\n        );\n\n        vm.prank(trader1);\n        matchingEngine.limitBuy(\n            address(token1),\n            address(token2),\n            500000000,\n            10,\n            true,\n            5,\n            0,\n            trader1\n        );\n\n        _showOrderbook(matchingEngine, address(token1), address(token2));\n\n        for (uint256 i = 0; i < 10; i++) {\n            vm.prank(trader1);\n            matchingEngine.limitSell(\n                address(token1),\n                address(token2),\n                500000000,\n                i + 1,\n                true,\n                2,\n                0,\n                trader1\n            );\n        }\n\n        // cancel order\n        vm.prank(trader1);\n        matchingEngine.cancelOrder(\n            address(token1),\n            address(token2),\n            false,\n            1,\n            0\n        );\n\n        // recheck orders\n        _showOrderbook(matchingEngine, address(token1), address(token2));\n\n        // cancel order\n        vm.prank(trader1);\n        matchingEngine.cancelOrder(\n            address(token1),\n            address(token2),\n            false,\n            11,\n            0\n        );\n\n        // recheck orders\n        _showOrderbook(matchingEngine, address(token1), address(token2));\n\n        // limit buy to check passing cancelled order\n        vm.prank(trader1);\n        matchingEngine.limitBuy(\n            address(token1),\n            address(token2),\n            500000000,\n            55,\n            true,\n            5,\n            0,\n            trader1\n        );\n\n        // recheck orders\n        _showOrderbook(matchingEngine, address(token1), address(token2));\n    }\n\n    function testCancelEdgeCase3() public {\n        super.setUp();\n        vm.prank(booker);\n        matchingEngine.addPair(address(token1), address(token2));\n        book = Orderbook(\n            payable(orderbookFactory.getPair(address(token1), address(token2)))\n        );\n        vm.prank(trader1);\n        // placeBid or placeAsk two of them is using the _insertId function it will revert\n        // because the program will enter the \"if (amount > self.orders[head].depositAmount).\"\n        // statement, and eventually, it will cause an infinite loop.\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            500000000,\n            10,\n            true,\n            2,\n            0,\n            trader1\n        );\n\n        vm.prank(trader1);\n        //vm.expectRevert(\"OutOfGas\");\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            100000000,\n            10,\n            true,\n            2,\n            0,\n            trader1\n        );\n\n        vm.prank(trader1);\n        matchingEngine.limitBuy(\n            address(token1),\n            address(token2),\n            90000000,\n            10,\n            true,\n            5,\n            0,\n            trader1\n        );\n\n        vm.prank(trader1);\n        matchingEngine.limitBuy(\n            address(token1),\n            address(token2),\n            500000000,\n            10,\n            true,\n            5,\n            0,\n            trader1\n        );\n\n        _showOrderbook(matchingEngine, address(token1), address(token2));\n\n        for (uint256 i = 0; i < 10; i++) {\n            vm.prank(trader1);\n            matchingEngine.limitSell(\n                address(token1),\n                address(token2),\n                500000000,\n                i + 1,\n                true,\n                2,\n                0,\n                trader1\n            );\n        }\n\n        // cancel order\n        vm.prank(trader1);\n        matchingEngine.cancelOrder(\n            address(token1),\n            address(token2),\n            false,\n            1,\n            0\n        );\n\n        // recheck orders\n        _showOrderbook(matchingEngine, address(token1), address(token2));\n\n        // cancel order\n        vm.prank(trader1);\n        //vm.expectRevert();\n        matchingEngine.cancelOrder(\n            address(token1),\n            address(token2),\n            false,\n            11,\n            0\n        );\n\n        // recheck orders\n        _showOrderbook(matchingEngine, address(token1), address(token2));\n\n        // limit buy to check passing cancelled order\n        vm.prank(trader1);\n        matchingEngine.limitBuy(\n            address(token1),\n            address(token2),\n            500000000,\n            55,\n            true,\n            5,\n            0,\n            trader1\n        );\n\n        // recheck orders\n        _showOrderbook(matchingEngine, address(token1), address(token2));\n    }\n\n    function testCancelJammingOrderbook() public {\n        super.setUp();\n        vm.prank(booker);\n        matchingEngine.addPair(address(token1), address(token2));\n        book = Orderbook(\n            payable(orderbookFactory.getPair(address(token1), address(token2)))\n        );\n\n        vm.prank(trader1);\n        token1.approve(address(matchingEngine), 1000000000000000000e18);\n\n        // deposit 10000e18(9990e18 after fee) for buying token1 for 1000 token2 * amount\n        vm.prank(trader1);\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            1000e8,\n            1000e18,\n            true,\n            5,\n            0,\n            trader1\n        );\n\n        vm.prank(trader1);\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            1100e8,\n            1000e18,\n            true,\n            5,\n            0,\n            trader1\n        );\n\n        vm.prank(trader1);\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            1200e8,\n            1000e18,\n            true,\n            5,\n            0,\n            trader1\n        );\n\n        vm.prank(trader1);\n        matchingEngine.cancelOrder(\n            address(token1),\n            address(token2),\n            false,\n            3,\n            0\n        );\n\n        //_showOrderbook(matchingEngine, address(token1), address(token2));\n\n        vm.prank(trader1);\n        matchingEngine.limitBuy(\n            address(token1),\n            address(token2),\n            1400e8,\n            3400000e18,\n            true,\n            5,\n            0,\n            trader1\n        );\n\n        console.log(\n            \"minRequired quote\",\n            matchingEngine.convert(address(token1), address(token2), 1, true)\n        );\n\n        console.log(\n            \"minRequired base\",\n            matchingEngine.convert(address(token1), address(token2), 1, false)\n        );\n    }\n\n    function testCancelAtHeadPrice() public {\n        super.setUp();\n        vm.prank(booker);\n        matchingEngine.addPair(address(token1), address(token2));\n        book = Orderbook(\n            payable(orderbookFactory.getPair(address(token1), address(token2)))\n        );\n\n        vm.prank(trader1);\n        token1.approve(address(matchingEngine), 1000000000000000000e18);\n\n        // Make buy order then cancel at head price\n        vm.prank(trader1);\n        matchingEngine.limitBuy(\n            address(token1),\n            address(token2),\n            1000e8,\n            1000e18,\n            true,\n            5,\n            0,\n            trader1\n        );\n\n        (uint256 bidHead, uint256 askHead) = matchingEngine.heads(\n            address(token1),\n            address(token2)\n        );\n\n        console.log(bidHead, askHead);\n\n        vm.prank(trader1);\n        matchingEngine.cancelOrder(\n            address(token1),\n            address(token2),\n            true,\n            1,\n            0\n        );\n\n        // Make sell orer then cancel at head price\n        vm.prank(trader1);\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            1001e8,\n            1000e18,\n            true,\n            5,\n            0,\n            trader1\n        );\n\n        (uint256 bidHead2, uint256 askHead2) = matchingEngine.heads(\n            address(token1),\n            address(token2)\n        );\n\n        console.log(bidHead2, askHead2);\n\n        vm.prank(trader1);\n        matchingEngine.cancelOrder(\n            address(token1),\n            address(token2),\n            false,\n            1,\n            0\n        );\n    }\n\n    function testCancelOrderDeletion() public {\n        super.setUp();\n        vm.prank(booker);\n        matchingEngine.addPair(address(token1), address(token2));\n        book = Orderbook(\n            payable(orderbookFactory.getPair(address(token1), address(token2)))\n        );\n        vm.prank(trader1);\n        // placeBid or placeAsk two of them is using the _insertId function it will revert\n        // because the program will enter the \"if (amount > self.orders[head].depositAmount).\"\n        // statement, and eventually, it will cause an infinite loop.\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            100000000,\n            10,\n            true,\n            2,\n            0,\n            trader1\n        );\n\n        vm.prank(trader1);\n        //vm.expectRevert(\"OutOfGas\");\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            100000000,\n            10,\n            true,\n            2,\n            0,\n            trader1\n        );\n\n        vm.prank(trader1);\n        //vm.expectRevert(\"OutOfGas\");\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            100000000,\n            10,\n            true,\n            2,\n            0,\n            trader1\n        );\n        vm.prank(trader1);\n        //vm.expectRevert(\"OutOfGas\");\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            100000000,\n            10,\n            true,\n            2,\n            0,\n            trader1\n        );\n\n        ExchangeOrderbook.Order[] memory orders = matchingEngine.getOrders(\n            address(token1),\n            address(token2),\n            false,\n            100000000,\n            4\n        );\n        console.log(\"Ask Orders before cancel: \");\n        for (uint256 i = 0; i < 4; i++) {\n            console.log(orders[i].owner, orders[i].depositAmount);\n        }\n\n        // cancel order\n\n        vm.prank(trader1);\n        matchingEngine.cancelOrder(\n            address(token1),\n            address(token2),\n            false,\n            3,\n            0\n        );\n\n        ExchangeOrderbook.Order[] memory orders2 = matchingEngine.getOrders(\n            address(token1),\n            address(token2),\n            false,\n            100000000,\n            4\n        );\n        console.log(\"Ask Orders: \");\n        for (uint256 i = 0; i < 4; i++) {\n            console.log(orders2[i].owner, orders2[i].depositAmount);\n        }\n    }\n}\n"
        },
        "test/safex/orderbook/Conversion.t.sol": {
            "content": "pragma solidity >=0.8;\n\nimport {MockToken} from \"../../../contracts/mock/MockToken.sol\";\nimport {MockBase} from \"../../../contracts/mock/MockBase.sol\";\nimport {MockQuote} from \"../../../contracts/mock/MockQuote.sol\";\nimport {MockBTC} from \"../../../contracts/mock/MockBTC.sol\";\nimport {ErrToken} from \"../../../contracts/mock/MockTokenOver18Decimals.sol\";\nimport {Utils} from \"../../utils/Utils.sol\";\nimport {MatchingEngine} from \"../../../contracts/safex/MatchingEngine.sol\";\nimport {OrderbookFactory} from \"../../../contracts/safex/orderbooks/OrderbookFactory.sol\";\nimport {Orderbook} from \"../../../contracts/safex/orderbooks/Orderbook.sol\";\nimport {ExchangeOrderbook} from \"../../../contracts/safex/libraries/ExchangeOrderbook.sol\";\nimport {IOrderbookFactory} from \"../../../contracts/safex/interfaces/IOrderbookFactory.sol\";\nimport {WETH9} from \"../../../contracts/mock/WETH9.sol\";\nimport {Treasury} from \"../../../contracts/sabt/Treasury.sol\";\nimport {BaseSetup} from \"../OrderbookBaseSetup.sol\";\nimport {console} from \"forge-std/console.sol\";\nimport {stdStorage, StdStorage, Test} from \"forge-std/Test.sol\";\n\n// test cases for orderbooks\ncontract ConversionTest is BaseSetup {\n    \n    function testOrderWithPriceZeroFails() public {\n        vm.prank(booker);\n        matchingEngine.addPair(address(token1), address(token2));\n        book = Orderbook(\n            payable(orderbookFactory.getPair(address(token1), address(token2)))\n        );\n        vm.prank(trader1);\n        vm.expectRevert();\n        // placeBid or placeAsk two of them is using the _insertId function it will revert\n        // because the program will enter the \"if (amount > self.orders[head].depositAmount).\"\n        // statement, and eventually, it will cause an infinite loop.\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            0,\n            10,\n            true,\n            2,\n            0,\n            trader1\n        );\n    }\n\n    function testInvalidConversion() public {\n        super.setUp();\n        vm.prank(booker);\n        matchingEngine.addPair(address(token1), address(token2));\n        console.log(\n            \"Base/Quote Pair: \",\n            matchingEngine.getPair(address(token1), address(token2))\n        );\n        console.log(\"Buy and sell with one price (Fee off)\");\n        vm.prank(trader1);\n        uint256 trader1Token1BalanceBeforeTrade = token1.balanceOf(\n            address(trader1)\n        );\n        uint256 trader1Token2BalanceBeforeTrade = token2.balanceOf(\n            address(trader1)\n        );\n        uint256 trader2Token1BalanceBeforeTrade = token1.balanceOf(\n            address(trader2)\n        );\n        uint256 trader2Token2BalanceBeforeTrade = token2.balanceOf(\n            address(trader2)\n        );\n        vm.prank(trader1);\n        matchingEngine.limitBuy(\n            address(token1),\n            address(token2),\n            1,\n            100e18,\n            true,\n            2,\n            0,\n            trader1\n        );\n        vm.prank(trader2);\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            1,\n            100e18,\n            true,\n            2,\n            0,\n            trader2\n        );\n        uint256 trader1Token1BalanceAfterTrade = token1.balanceOf(\n            address(trader1)\n        );\n        uint256 trader1Token2BalanceAfterTrade = token2.balanceOf(\n            address(trader1)\n        );\n        uint256 trader2Token1BalanceAfterTrade = token1.balanceOf(\n            address(trader2)\n        );\n        uint256 trader2Token2BalanceAfterTrade = token2.balanceOf(\n            address(trader2)\n        );\n        uint256 diffToken1Trader1 = trader1Token1BalanceAfterTrade -\n            trader1Token1BalanceBeforeTrade;\n        uint256 diffToken2Trader1 = trader1Token2BalanceBeforeTrade -\n            trader1Token2BalanceAfterTrade;\n        uint256 diffToken1Trader2 = trader2Token1BalanceBeforeTrade -\n            trader2Token1BalanceAfterTrade;\n        uint256 diffToken2Trader2 = trader2Token2BalanceAfterTrade -\n            trader2Token2BalanceBeforeTrade;\n        console.log(\"trader1 received Token1: \", diffToken1Trader1);\n        console.log(\"trader1 spent Token2:    \", diffToken2Trader1);\n        console.log(\"trader2 spent Token1:    \", diffToken1Trader2);\n        console.log(\"trader1 received Token2: \", diffToken2Trader2);\n        console.log(\n            \"------------------------------------------------------------------------\"\n        );\n        console.log(\"Sell and buy with one price (Fee off)\");\n        trader1Token1BalanceBeforeTrade = token1.balanceOf(address(trader1));\n        trader1Token2BalanceBeforeTrade = token2.balanceOf(address(trader1));\n        trader2Token1BalanceBeforeTrade = token1.balanceOf(address(trader2));\n        trader2Token2BalanceBeforeTrade = token2.balanceOf(address(trader2));\n        vm.prank(trader2);\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            1,\n            100e18,\n            true,\n            2,\n            0,\n            trader2\n        );\n        vm.prank(trader1);\n        matchingEngine.limitBuy(\n            address(token1),\n            address(token2),\n            1,\n            100e18,\n            true,\n            2,\n            0,\n            trader1\n        );\n        trader1Token1BalanceAfterTrade = token1.balanceOf(address(trader1));\n        trader1Token2BalanceAfterTrade = token2.balanceOf(address(trader1));\n        trader2Token1BalanceAfterTrade = token1.balanceOf(address(trader2));\n        trader2Token2BalanceAfterTrade = token2.balanceOf(address(trader2));\n        diffToken1Trader1 =\n            trader1Token1BalanceAfterTrade -\n            trader1Token1BalanceBeforeTrade;\n        diffToken2Trader1 =\n            trader1Token2BalanceBeforeTrade -\n            trader1Token2BalanceAfterTrade;\n        diffToken1Trader2 =\n            trader2Token1BalanceBeforeTrade -\n            trader2Token1BalanceAfterTrade;\n        diffToken2Trader2 =\n            trader2Token2BalanceAfterTrade -\n            trader2Token2BalanceBeforeTrade;\n        console.log(\"trader1 received Token1: \", diffToken1Trader1);\n        console.log(\"trader1 spent Token2:    \", diffToken2Trader1);\n        console.log(\"trader2 spent Token1:    \", diffToken1Trader2);\n        console.log(\"trader1 received Token2: \", diffToken2Trader2);\n    }\n\n    function testConvertBuySellOnDifferentDecimalWhereBaseBQuote() public {\n        super.setUp();\n        vm.prank(booker);\n        matchingEngine.addPair(address(token1), address(btc));\n        book = Orderbook(\n            payable(orderbookFactory.getPair(address(token1), address(btc)))\n        );\n        // before trade balances\n        uint256 beforeTrader2T1Balance = token1.balanceOf(address(trader2));\n        uint256 beforeTrader2BTCBalance = btc.balanceOf(address(trader2));\n        uint256 beforeTrader1T1Balance = token1.balanceOf(address(trader1));\n        uint256 beforeTrader1BTCBalance = btc.balanceOf(address(trader1));\n\n        // deposit 10000e8(9990e8 after fee) for buying 10e18 token1 for 1000 token2 * amount\n        vm.prank(trader1);\n        matchingEngine.limitBuy(\n            address(token1),\n            address(btc),\n            1000e8,\n            10000e8,\n            true,\n            5,\n            0,\n            trader1\n        );\n        // deposit 10e18(9.99e18 after fee) for selling token1 for 1000 token1 * amount\n        vm.prank(trader2);\n        matchingEngine.limitSell(\n            address(token1),\n            address(btc),\n            1000e8,\n            10e18,\n            true,\n            5,\n            0,\n            trader2\n        );\n\n        // after trade balances\n        uint256 afterTrader2T1Balance = token1.balanceOf(address(trader2));\n        uint256 afterTrader2BTCBalance = btc.balanceOf(address(trader2));\n        uint256 afterTrader1T1Balance = token1.balanceOf(address(trader1));\n        uint256 afterTrader1BTCBalance = btc.balanceOf(address(trader1));\n\n        // differences\n        uint256 diffTrader2T1Balance = beforeTrader2T1Balance -\n            afterTrader2T1Balance;\n        uint256 diffTrader2BTCBalance = afterTrader2BTCBalance -\n            beforeTrader2BTCBalance;\n        uint256 diffTrader1T1Balance = afterTrader1T1Balance -\n            beforeTrader1T1Balance;\n        uint256 diffTrader1BTCBalance = beforeTrader1BTCBalance -\n            afterTrader1BTCBalance;\n\n        console.log(\n            \"Trader2 diffs: \",\n            diffTrader2T1Balance,\n            diffTrader2BTCBalance\n        );\n        console.log(\n            \"Trader1 diffs: \",\n            diffTrader1T1Balance,\n            diffTrader1BTCBalance\n        );\n\n        // Trader2's btc balance should be increased by 9.99e11\n        assert(diffTrader2BTCBalance == 9990e8);\n        // Trader2's token1 balance should be decreased by 10e18\n        assert(diffTrader2T1Balance == 10e18);\n        // Trader1's btc balance should be decreased by 10000e8\n        assert(diffTrader1BTCBalance == 10000e8);\n        // Trader1's token1 balance should be increased by 9.99e18\n        assert(diffTrader1T1Balance == 9990e15);\n\n        (uint256 bidHead, uint256 askHead) = book.heads();\n        console.log(\"bidHead: \", bidHead);\n        console.log(\"askHead: \", askHead);\n    }\n\n    function testConvertSellBuyOnDifferentDecimalWhereBaseBQuote() public {\n        super.setUp();\n        vm.prank(booker);\n        matchingEngine.addPair(address(token1), address(btc));\n        book = Orderbook(\n            payable(orderbookFactory.getPair(address(token1), address(btc)))\n        );\n        // before trade balances\n        uint256 beforeTrader2T1Balance = token1.balanceOf(address(trader2));\n        uint256 beforeTrader2BTCBalance = btc.balanceOf(address(trader2));\n        uint256 beforeTrader1T1Balance = token1.balanceOf(address(trader1));\n        uint256 beforeTrader1BTCBalance = btc.balanceOf(address(trader1));\n\n        // deposit 10e18(9.99e18 after fee) for selling token1 for 1000 token1 * amount\n        vm.prank(trader2);\n        matchingEngine.limitSell(\n            address(token1),\n            address(btc),\n            1000e8,\n            10e18,\n            true,\n            5,\n            0,\n            trader2\n        );\n\n        // deposit 10000e8(9990e8 after fee) for buying 10e18 token1 for 1000 token2 * amount\n        vm.prank(trader1);\n        matchingEngine.limitBuy(\n            address(token1),\n            address(btc),\n            1000e8,\n            10000e8,\n            true,\n            5,\n            0,\n            trader1\n        );\n\n        // after trade balances\n        uint256 afterTrader2T1Balance = token1.balanceOf(address(trader2));\n        uint256 afterTrader2BTCBalance = btc.balanceOf(address(trader2));\n        uint256 afterTrader1T1Balance = token1.balanceOf(address(trader1));\n        uint256 afterTrader1BTCBalance = btc.balanceOf(address(trader1));\n\n        // differences\n        uint256 diffTrader2T1Balance = beforeTrader2T1Balance -\n            afterTrader2T1Balance;\n        uint256 diffTrader2BTCBalance = afterTrader2BTCBalance -\n            beforeTrader2BTCBalance;\n        uint256 diffTrader1T1Balance = afterTrader1T1Balance -\n            beforeTrader1T1Balance;\n        uint256 diffTrader1BTCBalance = beforeTrader1BTCBalance -\n            afterTrader1BTCBalance;\n\n        console.log(\n            \"Trader2 diffs: \",\n            diffTrader2T1Balance,\n            diffTrader2BTCBalance\n        );\n        console.log(\n            \"Trader1 diffs: \",\n            diffTrader1T1Balance,\n            diffTrader1BTCBalance\n        );\n\n        // Trader2's btc balance should be increased by 9.99e11\n        assert(diffTrader2BTCBalance == 9990e8);\n        // Trader2's token1 balance should be decreased by 10e18\n        assert(diffTrader2T1Balance == 10e18);\n        // Trader1's btc balance should be decreased by 10000e8\n        assert(diffTrader1BTCBalance == 10000e8);\n        // Trader1's token1 balance should be increased by 9.99e18\n        assert(diffTrader1T1Balance == 9990e15);\n\n        (uint256 bidHead, uint256 askHead) = book.heads();\n        console.log(\"bidHead: \", bidHead);\n        console.log(\"askHead: \", askHead);\n    }\n\n    function testConvertBuySellOnDifferentDecimalWhereNotBaseBQuote() public {\n        super.setUp();\n        vm.prank(booker);\n        matchingEngine.addPair(address(btc), address(token2));\n        book = Orderbook(\n            payable(orderbookFactory.getPair(address(btc), address(token2)))\n        );\n        // before trade balances\n        uint256 beforeTrader2T2Balance = token2.balanceOf(address(trader2));\n        uint256 beforeTrader2BTCBalance = btc.balanceOf(address(trader2));\n        uint256 beforeTrader1T2Balance = token2.balanceOf(address(trader1));\n        uint256 beforeTrader1BTCBalance = btc.balanceOf(address(trader1));\n\n        // deposit 10000e18(9990e18 after fee) for buying 10e8 token1 for 1000 token2 * amount\n        vm.prank(trader1);\n        matchingEngine.limitBuy(\n            address(btc),\n            address(token2),\n            1000e8,\n            10000e18,\n            true,\n            5,\n            0,\n            trader1\n        );\n        // deposit 10e8(9.99e8 after fee) for selling token1 for 1000 token1 * amount\n        vm.prank(trader2);\n        matchingEngine.limitSell(\n            address(btc),\n            address(token2),\n            1000e8,\n            10e8,\n            true,\n            5,\n            0,\n            trader2\n        );\n\n        // after trade balances\n        uint256 afterTrader2T2Balance = token2.balanceOf(address(trader2));\n        uint256 afterTrader2BTCBalance = btc.balanceOf(address(trader2));\n        uint256 afterTrader1T2Balance = token2.balanceOf(address(trader1));\n        uint256 afterTrader1BTCBalance = btc.balanceOf(address(trader1));\n\n        // differences\n        uint256 diffTrader2T2Balance = afterTrader2T2Balance -\n            beforeTrader2T2Balance;\n        uint256 diffTrader2BTCBalance = beforeTrader2BTCBalance -\n            afterTrader2BTCBalance;\n        uint256 diffTrader1T2Balance = beforeTrader1T2Balance -\n            afterTrader1T2Balance;\n        uint256 diffTrader1BTCBalance = afterTrader1BTCBalance -\n            beforeTrader1BTCBalance;\n\n        console.log(\n            \"Trader2 diffs: \",\n            diffTrader2T2Balance,\n            diffTrader2BTCBalance\n        );\n        console.log(\n            \"Trader1 diffs: \",\n            diffTrader1T2Balance,\n            diffTrader1BTCBalance\n        );\n\n        // Trader2's token2 balance should be increased by 9.99e21\n        assert(diffTrader2T2Balance == 9990e18);\n\n        // Trader2's token1 balance should be decreased by 10e8\n        assert(diffTrader2BTCBalance == 10e8);\n        // Trader1's token2 balance should be decreased by 10000e18\n        assert(diffTrader1T2Balance == 10000e18);\n        // Trader1's token1 balance should be increased by 9.99e8\n        assert(diffTrader1BTCBalance == 9990e5);\n\n        (uint256 bidHead, uint256 askHead) = book.heads();\n        console.log(\"bidHead: \", bidHead);\n        console.log(\"askHead: \", askHead);\n    }\n\n    function testConvertSellBuyOnDifferentDecimalWhereNotBaseBQuote() public {\n        super.setUp();\n        vm.prank(booker);\n        matchingEngine.addPair(address(btc), address(token2));\n        book = Orderbook(\n            payable(orderbookFactory.getPair(address(btc), address(token2)))\n        );\n        // before trade balances\n        uint256 beforeTrader2T2Balance = token2.balanceOf(address(trader2));\n        uint256 beforeTrader2BTCBalance = btc.balanceOf(address(trader2));\n        uint256 beforeTrader1T2Balance = token2.balanceOf(address(trader1));\n        uint256 beforeTrader1BTCBalance = btc.balanceOf(address(trader1));\n\n        // deposit 10e8(9.99e8 after fee) for selling token1 for 1000 token1 * amount\n        vm.prank(trader2);\n        matchingEngine.limitSell(\n            address(btc),\n            address(token2),\n            1000e8,\n            10e8,\n            true,\n            5,\n            0,\n            trader2\n        );\n        // deposit 10000e18(9990e18 after fee) for buying 10e8 token1 for 1000 token2 * amount\n        vm.prank(trader1);\n        matchingEngine.limitBuy(\n            address(btc),\n            address(token2),\n            1000e8,\n            10000e18,\n            true,\n            5,\n            0,\n            trader1\n        );\n\n        // after trade balances\n        uint256 afterTrader2T2Balance = token2.balanceOf(address(trader2));\n        uint256 afterTrader2BTCBalance = btc.balanceOf(address(trader2));\n        uint256 afterTrader1T2Balance = token2.balanceOf(address(trader1));\n        uint256 afterTrader1BTCBalance = btc.balanceOf(address(trader1));\n\n        // differences\n        uint256 diffTrader2T2Balance = afterTrader2T2Balance -\n            beforeTrader2T2Balance;\n        uint256 diffTrader2BTCBalance = beforeTrader2BTCBalance -\n            afterTrader2BTCBalance;\n        uint256 diffTrader1T2Balance = beforeTrader1T2Balance -\n            afterTrader1T2Balance;\n        uint256 diffTrader1BTCBalance = afterTrader1BTCBalance -\n            beforeTrader1BTCBalance;\n\n        console.log(\n            \"Trader2 diffs: \",\n            diffTrader2T2Balance,\n            diffTrader2BTCBalance\n        );\n        console.log(\n            \"Trader1 diffs: \",\n            diffTrader1T2Balance,\n            diffTrader1BTCBalance\n        );\n\n        // Trader2's token2 balance should be increased by 9.99e21\n        assert(diffTrader2T2Balance == 9990e18);\n\n        // Trader2's token1 balance should be decreased by 10e8\n        assert(diffTrader2BTCBalance == 10e8);\n        // Trader1's token2 balance should be decreased by 10000e18\n        assert(diffTrader1T2Balance == 10000e18);\n        // Trader1's token1 balance should be increased by 9.99e8\n        assert(diffTrader1BTCBalance == 9990e5);\n\n        (uint256 bidHead, uint256 askHead) = book.heads();\n        console.log(\"bidHead: \", bidHead);\n        console.log(\"askHead: \", askHead);\n    }\n\n    function testConvertBuySellOnSameDecimal() public {\n        super.setUp();\n        vm.prank(booker);\n        matchingEngine.addPair(address(token1), address(token2));\n        book = Orderbook(\n            payable(orderbookFactory.getPair(address(token1), address(token2)))\n        );\n        // before trade balances\n        uint256 beforeTrader2T2Balance = token2.balanceOf(address(trader2));\n        uint256 beforeTrader2T1Balance = token1.balanceOf(address(trader2));\n        uint256 beforeTrader1T2Balance = token2.balanceOf(address(trader1));\n        uint256 beforeTrader1T1Balance = token1.balanceOf(address(trader1));\n\n        // deposit 10000e18(9990e18 after fee) for buying token1 for 1000 token2 * amount\n        vm.prank(trader1);\n        matchingEngine.limitBuy(\n            address(token1),\n            address(token2),\n            1000e8,\n            10000e18,\n            true,\n            5,\n            0,\n            trader1\n        );\n        // deposit 10e18(9.99e18 after fee) for selling token1 for 1000 token2 * amount\n        vm.prank(trader2);\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            1000e8,\n            10e18,\n            true,\n            5,\n            0,\n            trader2\n        );\n\n        // after trade balances\n        uint256 afterTrader2T2Balance = token2.balanceOf(address(trader2));\n        uint256 afterTrader2T1Balance = token1.balanceOf(address(trader2));\n        uint256 afterTrader1T2Balance = token2.balanceOf(address(trader1));\n        uint256 afterTrader1T1Balance = token1.balanceOf(address(trader1));\n\n        // differences\n        uint256 diffTrader2T2Balance = afterTrader2T2Balance -\n            beforeTrader2T2Balance;\n        uint256 diffTrader2T1Balance = beforeTrader2T1Balance -\n            afterTrader2T1Balance;\n        uint256 diffTrader1T2Balance = beforeTrader1T2Balance -\n            afterTrader1T2Balance;\n        uint256 diffTrader1T1Balance = afterTrader1T1Balance -\n            beforeTrader1T1Balance;\n\n        console.log(\n            \"Trader2 diffs: \",\n            diffTrader2T2Balance,\n            diffTrader2T1Balance\n        );\n        console.log(\n            \"Trader1 diffs: \",\n            diffTrader1T2Balance,\n            diffTrader1T1Balance\n        );\n\n        // Trader2's token2 balance should be increased by 9.99e21\n        assert(diffTrader2T2Balance == 9990e18);\n        console.log(\"flag\");\n        // Trader2's token1 balance should be decreased by 10e18\n        assert(diffTrader2T1Balance == 10e18);\n        // Trader1's token2 balance should be decreased by 10000e18\n        assert(diffTrader1T2Balance == 10000e18);\n        // Trader1's token1 balance should be increased by 9.99e18\n        assert(diffTrader1T1Balance == 9990e15);\n\n        (uint256 bidHead, uint256 askHead) = book.heads();\n        console.log(\"bidHead: \", bidHead);\n        console.log(\"askHead: \", askHead);\n    }\n\n    function testConvertSellBuyOnSameDecimal() public {\n        super.setUp();\n        vm.prank(booker);\n        matchingEngine.addPair(address(token1), address(token2));\n        book = Orderbook(\n            payable(orderbookFactory.getPair(address(token1), address(token2)))\n        );\n        // before trade balances\n        uint256 beforeTrader2T2Balance = token2.balanceOf(address(trader2));\n        uint256 beforeTrader2T1Balance = token1.balanceOf(address(trader2));\n        uint256 beforeTrader1T2Balance = token2.balanceOf(address(trader1));\n        uint256 beforeTrader1T1Balance = token1.balanceOf(address(trader1));\n\n        // deposit 10e18(9.99e18 after fee) for selling token1 for 1000 token2 * amount\n        vm.prank(trader2);\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            1000e8,\n            10e18,\n            true,\n            5,\n            0,\n            trader2\n        );\n        // deposit 10000e18(9990e18 after fee) for buying token1 for 1000 token2 * amount\n        vm.prank(trader1);\n        matchingEngine.limitBuy(\n            address(token1),\n            address(token2),\n            1000e8,\n            10000e18,\n            true,\n            5,\n            0,\n            trader1\n        );\n\n        // after trade balances\n        uint256 afterTrader2T2Balance = token2.balanceOf(address(trader2));\n        uint256 afterTrader2T1Balance = token1.balanceOf(address(trader2));\n        uint256 afterTrader1T2Balance = token2.balanceOf(address(trader1));\n        uint256 afterTrader1T1Balance = token1.balanceOf(address(trader1));\n\n        // differences\n        uint256 diffTrader2T2Balance = afterTrader2T2Balance -\n            beforeTrader2T2Balance;\n        uint256 diffTrader2T1Balance = beforeTrader2T1Balance -\n            afterTrader2T1Balance;\n        uint256 diffTrader1T2Balance = beforeTrader1T2Balance -\n            afterTrader1T2Balance;\n        uint256 diffTrader1T1Balance = afterTrader1T1Balance -\n            beforeTrader1T1Balance;\n\n        console.log(\n            \"Trader2 diffs: \",\n            diffTrader2T2Balance,\n            diffTrader2T1Balance\n        );\n        console.log(\n            \"Trader1 diffs: \",\n            diffTrader1T2Balance,\n            diffTrader1T1Balance\n        );\n\n        // Trader2's token2 balance should be increased by 9.99e21\n        assert(diffTrader2T2Balance == 9990e18);\n\n        // Trader2's token1 balance should be decreased by 10e18\n        assert(diffTrader2T1Balance == 10e18);\n        // Trader1's token2 balance should be decreased by 10000e18\n        assert(diffTrader1T2Balance == 10000e18);\n        // Trader1's token1 balance should be increased by 9.99e18\n        assert(diffTrader1T1Balance == 9990e15);\n    }\n}\n"
        },
        "test/safex/orderbook/Getter.t.sol": {
            "content": "pragma solidity >=0.8;\n\nimport {MockToken} from \"../../../contracts/mock/MockToken.sol\";\nimport {MockBase} from \"../../../contracts/mock/MockBase.sol\";\nimport {MockQuote} from \"../../../contracts/mock/MockQuote.sol\";\nimport {MockBTC} from \"../../../contracts/mock/MockBTC.sol\";\nimport {ErrToken} from \"../../../contracts/mock/MockTokenOver18Decimals.sol\";\nimport {Utils} from \"../../utils/Utils.sol\";\nimport {MatchingEngine} from \"../../../contracts/safex/MatchingEngine.sol\";\nimport {OrderbookFactory} from \"../../../contracts/safex/orderbooks/OrderbookFactory.sol\";\nimport {Orderbook} from \"../../../contracts/safex/orderbooks/Orderbook.sol\";\nimport {ExchangeOrderbook} from \"../../../contracts/safex/libraries/ExchangeOrderbook.sol\";\nimport {IOrderbookFactory} from \"../../../contracts/safex/interfaces/IOrderbookFactory.sol\";\nimport {WETH9} from \"../../../contracts/mock/WETH9.sol\";\nimport {Treasury} from \"../../../contracts/sabt/Treasury.sol\";\nimport {BaseSetup} from \"../OrderbookBaseSetup.sol\";\nimport {console} from \"forge-std/console.sol\";\nimport {stdStorage, StdStorage, Test} from \"forge-std/Test.sol\";\n\ncontract GetterTest is BaseSetup {\n    function testGetPrices() public {\n        super.setUp();\n        vm.prank(booker);\n        matchingEngine.addPair(address(token1), address(token2));\n        book = Orderbook(\n            payable(\n                orderbookFactory.getPair(address(token1), address(token2))\n            )\n        );\n        vm.prank(trader1);\n        // placeBid or placeAsk two of them is using the _insertId function it will revert\n        // because the program will enter the \"if (amount > self.orders[head].depositAmount).\"\n        // statement, and eventually, it will cause an infinite loop.\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            500000000,\n            10,\n            true,\n            2,\n            0,\n            trader1\n        );\n\n        vm.prank(trader1);\n        //vm.expectRevert(\"OutOfGas\");\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            100000000,\n            10,\n            true,\n            2,\n            0,\n            trader1\n        );\n\n        vm.prank(trader1);\n        matchingEngine.limitBuy(\n            address(token1),\n            address(token2),\n            90000000,\n            10,\n            true,\n            5,\n            0,\n            trader1\n        );\n\n        vm.prank(trader1);\n        matchingEngine.limitBuy(\n            address(token1),\n            address(token2),\n            500000000,\n            10,\n            true,\n            5,\n            0,\n            trader1\n        );\n        uint256[] memory bidPrices = matchingEngine.getPrices(\n            address(token1),\n            address(token2),\n            true,\n            20\n        );\n        console.log(\"Bid prices: \");\n        for (uint256 i = 0; i < 4; i++) {\n            console.log(bidPrices[i]);\n        }\n        //matchingEngine.getOrders(address(token1), address(token2), true, 0, 0);\n        uint256[] memory askPrices = matchingEngine.getPrices(\n            address(token1),\n            address(token2),\n            false,\n            20\n        );\n        console.log(\"Ask prices: \");\n        for (uint256 i = 0; i < 3; i++) {\n            console.log(askPrices[i]);\n        }\n    }\n\n    function testGetPriceInsertion() public {\n        super.setUp();\n        vm.prank(booker);\n        matchingEngine.addPair(address(token1), address(token2));\n        book = Orderbook(\n            payable(\n                orderbookFactory.getPair(address(token1), address(token2))\n            )\n        );\n        vm.prank(trader1);\n        // placeBid or placeAsk two of them is using the _insertId function it will revert\n        // because the program will enter the \"if (amount > self.orders[head].depositAmount).\"\n        // statement, and eventually, it will cause an infinite loop.\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            100000000000,\n            10,\n            true,\n            2,\n            0,\n            trader1\n        );\n        vm.prank(trader1);\n        //vm.expectRevert(\"OutOfGas\");\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            100200000000,\n            10,\n            true,\n            2,\n            0,\n            trader1\n        );\n        vm.prank(trader1);\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            100100000000,\n            10,\n            true,\n            5,\n            0,\n            trader1\n        );\n        vm.prank(trader1);\n        matchingEngine.limitBuy(\n            address(token1),\n            address(token2),\n            99800000000,\n            998,\n            true,\n            5,\n            0,\n            trader1\n        );\n        vm.prank(trader1);\n        matchingEngine.limitBuy(\n            address(token1),\n            address(token2),\n            99900000000,\n            999,\n            true,\n            5,\n            0,\n            trader1\n        );\n        vm.prank(trader1);\n        matchingEngine.limitBuy(\n            address(token1),\n            address(token2),\n            99700000000,\n            997,\n            true,\n            5,\n            0,\n            trader1\n        );\n        uint256[] memory bidPrices = matchingEngine.getPrices(\n            address(token1),\n            address(token2),\n            true,\n            20\n        );\n        console.log(\"Bid prices: \");\n        for (uint256 i = 0; i < 3; i++) {\n            console.log(bidPrices[i]);\n        }\n        //matchingEngine.getOrders(address(token1), address(token2), true, 0, 0);\n        uint256[] memory askPrices = matchingEngine.getPrices(\n            address(token1),\n            address(token2),\n            false,\n            20\n        );\n        console.log(\"Ask prices: \");\n        for (uint256 i = 0; i < 3; i++) {\n            console.log(askPrices[i]);\n        }\n    }\n\n    function testGetOrders() public {\n        super.setUp();\n        vm.prank(booker);\n        matchingEngine.addPair(address(token1), address(token2));\n        book = Orderbook(\n            payable(\n                orderbookFactory.getPair(address(token1), address(token2))\n            )\n        );\n        vm.prank(trader1);\n        // placeBid or placeAsk two of them is using the _insertId function it will revert\n        // because the program will enter the \"if (amount > self.orders[head].depositAmount).\"\n        // statement, and eventually, it will cause an infinite loop.\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            500000000,\n            10,\n            true,\n            2,\n            0,\n            trader1\n        );\n        vm.prank(trader1);\n        //vm.expectRevert(\"OutOfGas\");\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            100000000,\n            10,\n            true,\n            2,\n            0,\n            trader1\n        );\n        vm.prank(trader1);\n        matchingEngine.limitBuy(\n            address(token1),\n            address(token2),\n            500000000,\n            10,\n            true,\n            5,\n            0,\n            trader1\n        );\n\n        console.log(\"Bid orders: \");\n        ExchangeOrderbook.Order[] memory bidOrders = matchingEngine.getOrders(\n            address(token1),\n            address(token2),\n            false,\n            500000000,\n            3\n        );\n\n        for (uint256 i = 0; i < 3; i++) {\n            console.log(bidOrders[i].owner, bidOrders[i].depositAmount);\n        }\n    }\n\n    function testGetAskHead() public {\n        super.setUp();\n        vm.prank(booker);\n        matchingEngine.addPair(address(token1), address(token2));\n        book = Orderbook(\n            payable(\n                orderbookFactory.getPair(address(token1), address(token2))\n            )\n        );\n        vm.prank(trader1);\n        // placeBid or placeAsk two of them is using the _insertId function it will revert\n        // because the program will enter the \"if (amount > self.orders[head].depositAmount).\"\n        // statement, and eventually, it will cause an infinite loop.\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            500000000,\n            10,\n            true,\n            2,\n            0,\n            trader1\n        );\n        vm.prank(trader1);\n        //vm.expectRevert(\"OutOfGas\");\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            100000000,\n            10,\n            true,\n            2,\n            0,\n            trader1\n        );\n        console.log(\"Ask Head:\");\n        console.log(book.askHead());\n    }\n\n    function testGetPairs() public {\n        super.setUp();\n        vm.prank(booker);\n        matchingEngine.addPair(address(token1), address(token2));\n        book = Orderbook(\n            payable(\n                orderbookFactory.getPair(address(token1), address(token2))\n            )\n        );\n        IOrderbookFactory.Pair[] memory pairs = matchingEngine.getPairs(0, 20);\n        console.log(\"Pairs:\");\n        console.log(pairs[0].base, pairs[0].quote);\n    }\n\n    function testGetPairNames() public {\n        super.setUp();\n        vm.prank(booker);\n        matchingEngine.addPair(address(token1), address(token2));\n        book = Orderbook(\n            payable(\n                orderbookFactory.getPair(address(token1), address(token2))\n            )\n        );\n        IOrderbookFactory.Pair[] memory pairs = matchingEngine.getPairs(0, 20);\n        console.log(\"Pairs:\");\n        console.log(pairs[0].base, pairs[0].quote);\n        string[] memory names = matchingEngine.getPairNames(0, 20);\n        console.log(names[0]);\n    }\n\n    function testGetOrderInsertion() public {\n        super.setUp();\n        vm.prank(booker);\n        matchingEngine.addPair(address(token1), address(token2));\n        book = Orderbook(\n            payable(\n                orderbookFactory.getPair(address(token1), address(token2))\n            )\n        );\n        vm.prank(trader1);\n        // placeBid or placeAsk two of them is using the _insertId function it will revert\n        // because the program will enter the \"if (amount > self.orders[head].depositAmount).\"\n        // statement, and eventually, it will cause an infinite loop.\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            100000000,\n            10,\n            true,\n            2,\n            0,\n            trader1\n        );\n        vm.prank(trader1);\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            100000000,\n            10,\n            true,\n            2,\n            0,\n            trader1\n        );\n        vm.prank(trader1);\n        //vm.expectRevert(\"OutOfGas\");\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            100000000,\n            5,\n            true,\n            2,\n            0,\n            trader1\n        );\n        vm.prank(trader1);\n        //vm.expectRevert(\"OutOfGas\");\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            100000000,\n            8,\n            true,\n            2,\n            0,\n            trader1\n        );\n        ExchangeOrderbook.Order[] memory orders = matchingEngine.getOrders(\n            address(token1),\n            address(token2),\n            false,\n            100000000,\n            4\n        );\n        console.log(\"Ask Orders: \");\n        for (uint256 i = 0; i < 4; i++) {\n            console.log(orders[i].owner, orders[i].depositAmount);\n        }\n    }\n}"
        },
        "test/safex/orderbook/InitialTrade.t.sol": {
            "content": "pragma solidity >=0.8;\n\nimport {MockToken} from \"../../../contracts/mock/MockToken.sol\";\nimport {MockBase} from \"../../../contracts/mock/MockBase.sol\";\nimport {MockQuote} from \"../../../contracts/mock/MockQuote.sol\";\nimport {MockBTC} from \"../../../contracts/mock/MockBTC.sol\";\nimport {ErrToken} from \"../../../contracts/mock/MockTokenOver18Decimals.sol\";\nimport {Utils} from \"../../utils/Utils.sol\";\nimport {MatchingEngine} from \"../../../contracts/safex/MatchingEngine.sol\";\nimport {OrderbookFactory} from \"../../../contracts/safex/orderbooks/OrderbookFactory.sol\";\nimport {Orderbook} from \"../../../contracts/safex/orderbooks/Orderbook.sol\";\nimport {ExchangeOrderbook} from \"../../../contracts/safex/libraries/ExchangeOrderbook.sol\";\nimport {IOrderbookFactory} from \"../../../contracts/safex/interfaces/IOrderbookFactory.sol\";\nimport {WETH9} from \"../../../contracts/mock/WETH9.sol\";\nimport {Treasury} from \"../../../contracts/sabt/Treasury.sol\";\nimport {BaseSetup} from \"../OrderbookBaseSetup.sol\";\nimport {console} from \"forge-std/console.sol\";\nimport {stdStorage, StdStorage, Test} from \"forge-std/Test.sol\";\n\ncontract InitialTradeTest is BaseSetup {\n    // edge cases on cancelling orders\n    function testInitialSell() public {\n        super.setUp();\n        vm.prank(trader1);\n        // placeBid or placeAsk two of them is using the _insertId function it will revert\n        // because the program will enter the \"if (amount > self.orders[head].depositAmount).\"\n        // statement, and eventually, it will cause an infinite loop.\n        matchingEngine.limitSellETH{value: 1e4}(\n            address(token2),\n            500000000,\n            true,\n            2,\n            0,\n            trader1\n        );\n\n        \n    }\n}\n"
        },
        "test/safex/orderbook/LimitOrder.t.sol": {
            "content": "pragma solidity >=0.8;\n\nimport {MockToken} from \"../../../contracts/mock/MockToken.sol\";\nimport {MockBase} from \"../../../contracts/mock/MockBase.sol\";\nimport {MockQuote} from \"../../../contracts/mock/MockQuote.sol\";\nimport {MockBTC} from \"../../../contracts/mock/MockBTC.sol\";\nimport {ErrToken} from \"../../../contracts/mock/MockTokenOver18Decimals.sol\";\nimport {Utils} from \"../../utils/Utils.sol\";\nimport {MatchingEngine} from \"../../../contracts/safex/MatchingEngine.sol\";\nimport {OrderbookFactory} from \"../../../contracts/safex/orderbooks/OrderbookFactory.sol\";\nimport {Orderbook} from \"../../../contracts/safex/orderbooks/Orderbook.sol\";\nimport {ExchangeOrderbook} from \"../../../contracts/safex/libraries/ExchangeOrderbook.sol\";\nimport {IOrderbookFactory} from \"../../../contracts/safex/interfaces/IOrderbookFactory.sol\";\nimport {WETH9} from \"../../../contracts/mock/WETH9.sol\";\nimport {Treasury} from \"../../../contracts/sabt/Treasury.sol\";\nimport {BaseSetup} from \"../OrderbookBaseSetup.sol\";\nimport {console} from \"forge-std/console.sol\";\nimport {stdStorage, StdStorage, Test} from \"forge-std/Test.sol\";\n\ncontract LimitOrderTest is BaseSetup {\n    function testLimitTradeWithDiffDecimals() public {\n        super.setUp();\n        vm.prank(booker);\n        matchingEngine.addPair(address(token1), address(btc));\n        console.log(\n            \"Base/Quote Pair: \",\n            matchingEngine.getPair(address(token1), address(btc))\n        );\n        vm.prank(trader1);\n        matchingEngine.limitBuy(\n            address(token1),\n            address(btc),\n            1e8,\n            1e8,\n            true,\n            2,\n            0,\n            trader1\n        );\n        vm.prank(trader2);\n        matchingEngine.limitSell(\n            address(token1),\n            address(btc),\n            1e8,\n            1e18,\n            true,\n            2,\n            0,\n            trader2\n        );\n    }\n\n    function testLimitTrade() public {\n        super.setUp();\n        vm.prank(booker);\n        matchingEngine.addPair(address(token1), address(token2));\n        console.log(\n            \"Base/Quote Pair: \",\n            matchingEngine.getPair(address(token1), address(token2))\n        );\n        vm.prank(trader1);\n        matchingEngine.limitBuy(\n            address(token1),\n            address(token2),\n            1e8,\n            100e18,\n            true,\n            2,\n            0,\n            trader1\n        );\n        vm.prank(trader2);\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            1e8,\n            100e18,\n            true,\n            2,\n            0,\n            trader2\n        );\n    }\n\n    function testLimitBuyETH() public {\n        super.setUp();\n        console.log(\"weth balance\");\n        console.log(trader1.balance / 1e18);\n        vm.prank(trader1);\n        matchingEngine.limitBuyETH{value: 1e18}(\n            address(token1),\n            1e8,\n            true,\n            5,\n            0,\n            trader1\n        );\n        vm.prank(trader1);\n        token1.approve(address(matchingEngine), 10e18);\n        vm.prank(trader1);\n        matchingEngine.limitSell(\n            address(token1),\n            address(weth),\n            1e8,\n            1e18,\n            true,\n            5,\n            0,\n            trader1\n        );\n        console.log(\"weth balance\");\n        console.log(trader1.balance / 1e18);\n    }\n\n    function testLimitSellETH() public {\n        super.setUp();\n        console.log(\"weth balance\");\n        console.log(trader1.balance / 1e18);\n        vm.prank(trader1);\n        matchingEngine.limitSellETH{value: 1e18}(\n            address(token1),\n            1e8,\n            true,\n            5,\n            0,\n            trader1\n        );\n        vm.prank(trader1);\n        matchingEngine.limitBuyETH{value: 1e18}(\n            address(token1),\n            1e8,\n            true,\n            5,\n            0,\n            trader1\n        );\n        vm.prank(trader1);\n        token1.approve(address(matchingEngine), 10e18);\n        vm.prank(trader1);\n        matchingEngine.limitBuy(\n            address(weth),\n            address(token1),\n            1e8,\n            1e18,\n            true,\n            5,\n            0,\n            trader1\n        );\n        console.log(\"weth balance\");\n        console.log(trader1.balance / 1e18);\n    }\n}"
        },
        "test/safex/orderbook/LoopOutOfGas.t.sol": {
            "content": "pragma solidity >=0.8;\n\nimport {MockToken} from \"../../../contracts/mock/MockToken.sol\";\nimport {MockBase} from \"../../../contracts/mock/MockBase.sol\";\nimport {MockQuote} from \"../../../contracts/mock/MockQuote.sol\";\nimport {MockBTC} from \"../../../contracts/mock/MockBTC.sol\";\nimport {ErrToken} from \"../../../contracts/mock/MockTokenOver18Decimals.sol\";\nimport {Utils} from \"../../utils/Utils.sol\";\nimport {MatchingEngine} from \"../../../contracts/safex/MatchingEngine.sol\";\nimport {OrderbookFactory} from \"../../../contracts/safex/orderbooks/OrderbookFactory.sol\";\nimport {Orderbook} from \"../../../contracts/safex/orderbooks/Orderbook.sol\";\nimport {ExchangeOrderbook} from \"../../../contracts/safex/libraries/ExchangeOrderbook.sol\";\nimport {IOrderbookFactory} from \"../../../contracts/safex/interfaces/IOrderbookFactory.sol\";\nimport {WETH9} from \"../../../contracts/mock/WETH9.sol\";\nimport {Treasury} from \"../../../contracts/sabt/Treasury.sol\";\nimport {BaseSetup} from \"../OrderbookBaseSetup.sol\";\nimport {console} from \"forge-std/console.sol\";\nimport {stdStorage, StdStorage, Test} from \"forge-std/Test.sol\";\n\ncontract LoopOutOfGasTest is BaseSetup {\n    function testExchangeLinkedListOutOfGas() public {\n        super.setUp();\n        vm.prank(booker);\n        matchingEngine.addPair(address(token1), address(token2));\n        book = Orderbook(\n            payable(\n                orderbookFactory.getPair(address(token1), address(token2))\n            )\n        );\n        vm.prank(trader1);\n\n        // placeBid or placeAsk two of them is using the _insert function it will revert\n        // because the program will enter the (price < last) statement\n        // and eventually, it will cause an infinite loop.\n        matchingEngine.limitBuy(\n            address(token1),\n            address(token2),\n            2,\n            10,\n            true,\n            2,\n            0,\n            trader1\n        );\n        vm.prank(trader1);\n        matchingEngine.limitBuy(\n            address(token1),\n            address(token2),\n            5,\n            10,\n            true,\n            2,\n            0,\n            trader1\n        );\n        vm.prank(trader1);\n        matchingEngine.limitBuy(\n            address(token1),\n            address(token2),\n            5,\n            10,\n            true,\n            2,\n            0,\n            trader1\n        );\n        vm.prank(trader1);\n        //vm.expectRevert(\"OutOfGas\");\n        matchingEngine.limitBuy(\n            address(token1),\n            address(token2),\n            1,\n            10,\n            true,\n            2,\n            0,\n            trader1\n        );\n    }\n\n    function testExchangeLinkedListOutOfGasPlaceBid() public {\n        super.setUp();\n        vm.prank(booker);\n        matchingEngine.addPair(address(token1), address(token2));\n        book = Orderbook(\n            payable(\n                orderbookFactory.getPair(address(token1), address(token2))\n            )\n        );\n        // We can create the same example with placeBid function\n        // This time the program will enter the while (price > last && last != 0) statement\n        // and it will cause an infinite loop.\n        vm.prank(trader1);\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            2,\n            5e7,\n            true,\n            2,\n            0,\n            trader1\n        );\n        vm.prank(trader1);\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            5,\n            2e7,\n            true,\n            2,\n            0,\n            trader1\n        );\n        vm.prank(trader1);\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            5,\n            2e7,\n            true,\n            2,\n            0,\n            trader1\n        );\n        vm.prank(trader1);\n        //vm.expectRevert(\"OutOfGas\");\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            6,\n            2e7,\n            true,\n            2,\n            0,\n            trader1\n        );\n    }\n\n    function testExchangeOrderbookOutOfGas() public {\n        super.setUp();\n        vm.prank(booker);\n        matchingEngine.addPair(address(token1), address(token2));\n        book = Orderbook(\n            payable(\n                orderbookFactory.getPair(address(token1), address(token2))\n            )\n        );\n        vm.prank(trader1);\n        // placeBid or placeAsk two of them is using the _insertId function it will revert\n        // because the program will enter the \"if (amount > self.orders[head].depositAmount).\"\n        // statement, and eventually, it will cause an infinite loop.\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            5,\n            2e7,\n            true,\n            2,\n            0,\n            trader1\n        );\n        vm.prank(trader1);\n        //vm.expectRevert(\"OutOfGas\");\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            1,\n            1e8,\n            true,\n            2,\n            0,\n            trader1\n        );\n    }\n}"
        },
        "test/safex/orderbook/Manipulation.t.sol": {
            "content": "pragma solidity >=0.8;\n\nimport {MockToken} from \"../../../contracts/mock/MockToken.sol\";\nimport {MockBase} from \"../../../contracts/mock/MockBase.sol\";\nimport {MockQuote} from \"../../../contracts/mock/MockQuote.sol\";\nimport {MockBTC} from \"../../../contracts/mock/MockBTC.sol\";\nimport {ErrToken} from \"../../../contracts/mock/MockTokenOver18Decimals.sol\";\nimport {Utils} from \"../../utils/Utils.sol\";\nimport {MatchingEngine} from \"../../../contracts/safex/MatchingEngine.sol\";\nimport {OrderbookFactory} from \"../../../contracts/safex/orderbooks/OrderbookFactory.sol\";\nimport {Orderbook} from \"../../../contracts/safex/orderbooks/Orderbook.sol\";\nimport {ExchangeOrderbook} from \"../../../contracts/safex/libraries/ExchangeOrderbook.sol\";\nimport {IOrderbookFactory} from \"../../../contracts/safex/interfaces/IOrderbookFactory.sol\";\nimport {WETH9} from \"../../../contracts/mock/WETH9.sol\";\nimport {Treasury} from \"../../../contracts/sabt/Treasury.sol\";\nimport {BaseSetup} from \"../OrderbookBaseSetup.sol\";\nimport {console} from \"forge-std/console.sol\";\nimport {stdStorage, StdStorage, Test} from \"forge-std/Test.sol\";\n\ncontract ManipulationTest is BaseSetup {\n    function testManipulateMarketPrice() public {\n        super.setUp();\n        vm.prank(booker);\n        matchingEngine.addPair(address(token1), address(token2));\n        vm.prank(trader1);\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            90e8,\n            100e18,\n            true,\n            2,\n            0,\n            trader1\n        );\n        vm.prank(trader1);\n        matchingEngine.limitBuy(\n            address(token1),\n            address(token2),\n            110e8,\n            100e18,\n            true,\n            2,\n            0,\n            trader1\n        );\n        book = Orderbook(\n            payable(\n                orderbookFactory.getPair(address(token1), address(token2))\n            )\n        );\n        console.log(\"Market price before manipulation: \", book.mktPrice());\n        vm.prank(attacker);\n        //book.placeBid(address(trader1), 1e7, 100e18);\n        //vm.prank(attacker);\n        //book.placeAsk(address(trader1), 1e8, 100e18);\n        console.log(\"Market price after manipulation:\", book.mktPrice());\n    }\n}"
        },
        "test/safex/orderbook/MarketOrder.t.sol": {
            "content": "pragma solidity >=0.8;\n\nimport {MockToken} from \"../../../contracts/mock/MockToken.sol\";\nimport {MockBase} from \"../../../contracts/mock/MockBase.sol\";\nimport {MockQuote} from \"../../../contracts/mock/MockQuote.sol\";\nimport {MockBTC} from \"../../../contracts/mock/MockBTC.sol\";\nimport {ErrToken} from \"../../../contracts/mock/MockTokenOver18Decimals.sol\";\nimport {Utils} from \"../../utils/Utils.sol\";\nimport {MatchingEngine} from \"../../../contracts/safex/MatchingEngine.sol\";\nimport {OrderbookFactory} from \"../../../contracts/safex/orderbooks/OrderbookFactory.sol\";\nimport {Orderbook} from \"../../../contracts/safex/orderbooks/Orderbook.sol\";\nimport {ExchangeOrderbook} from \"../../../contracts/safex/libraries/ExchangeOrderbook.sol\";\nimport {IOrderbookFactory} from \"../../../contracts/safex/interfaces/IOrderbookFactory.sol\";\nimport {WETH9} from \"../../../contracts/mock/WETH9.sol\";\nimport {Treasury} from \"../../../contracts/sabt/Treasury.sol\";\nimport {BaseSetup} from \"../OrderbookBaseSetup.sol\";\nimport {console} from \"forge-std/console.sol\";\nimport {stdStorage, StdStorage, Test} from \"forge-std/Test.sol\";\n\ncontract MarketOrderTest is BaseSetup {\n    function testMarketBuyETH() public {\n        super.setUp();\n        console.log(\"weth balance\");\n        console.log(trader1.balance / 1e18);\n        vm.prank(trader1);\n        matchingEngine.limitSell(\n            address(token1),\n            address(weth),\n            1e8,\n            1e18,\n            true,\n            5,\n            0,\n            trader1\n        );\n        (uint256 bidHead, uint256 askHead) = matchingEngine.heads(\n            address(token1),\n            address(weth)\n        );\n        console.log(bidHead, askHead);\n        vm.prank(trader1);\n        matchingEngine.marketBuyETH{value: 1e18}(\n            address(token1),\n            true,\n            5,\n            0,\n            trader1\n        );\n        vm.prank(trader1);\n        token1.approve(address(matchingEngine), 10e18);\n        vm.prank(trader1);\n        matchingEngine.marketSell(\n            address(token1),\n            address(weth),\n            1e18,\n            true,\n            5,\n            0,\n            trader1\n        );\n        console.log(\"weth balance\");\n        console.log(trader1.balance / 1e18);\n    }\n\n    function testMarketSellETH() public {\n        super.setUp();\n        console.log(\"weth balance\");\n        console.log(trader1.balance / 1e18);\n        vm.prank(trader1);\n        matchingEngine.limitBuy(\n            address(weth),\n            address(token1),\n            1e8,\n            1e18,\n            true,\n            5,\n            0,\n            trader1\n        );\n        vm.prank(trader1);\n        matchingEngine.marketSellETH{value: 1e18}(\n            address(token1),\n            true,\n            5,\n            0,\n            trader1\n        );\n        vm.prank(trader1);\n        token1.approve(address(matchingEngine), 10e18);\n        vm.prank(trader1);\n        matchingEngine.marketBuy(\n            address(weth),\n            address(token1),\n            1e18,\n            true,\n            5,\n            0,\n            trader1\n        );\n        console.log(\"weth balance\");\n        console.log(trader1.balance / 1e18);\n    }\n\n    function testCancelJammingOrderbook() public {\n        super.setUp();\n        vm.prank(booker);\n        matchingEngine.addPair(address(token1), address(token2));\n        book = Orderbook(\n            payable(orderbookFactory.getPair(address(token1), address(token2)))\n        );\n\n        vm.prank(trader1);\n        token1.approve(address(matchingEngine), 1000000000000000000e18);\n\n        // deposit 10000e18(9990e18 after fee) for buying token1 for 1000 token2 * amount\n        vm.prank(trader1);\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            1000e8,\n            1000e18,\n            true,\n            5,\n            0,\n            trader1\n        );\n\n        vm.prank(trader1);\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            1100e8,\n            1000e18,\n            true,\n            5,\n            0,\n            trader1\n        );\n\n        vm.prank(trader1);\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            1200e8,\n            1000e18,\n            true,\n            5,\n            0,\n            trader1\n        );\n\n        vm.prank(trader1);\n        matchingEngine.cancelOrder(\n            address(token1),\n            address(token2),\n            false,\n            1,\n            0\n        );\n        vm.prank(trader1);\n        matchingEngine.cancelOrder(\n            address(token1),\n            address(token2),\n            false,\n            2,\n            0\n        );\n        ExchangeOrderbook.Order memory order = matchingEngine.getOrder(\n            address(token1),\n            address(token2),\n            false,\n            3\n        );\n        console.log(\"Order id 3: \", order.owner, order.depositAmount);\n        _showOrderbook(matchingEngine, address(token1), address(token2));\n\n        vm.prank(trader1);\n        matchingEngine.marketBuy(\n            address(token1),\n            address(token2),\n            //1400e8,\n            3400000e18,\n            true,\n            5,\n            0,\n            trader1\n        );\n\n        console.log(\n            \"Mkt Price: \",\n            matchingEngine.mktPrice(address(token1), address(token2))\n        );\n\n        console.log(\n            \"minRequired quote\",\n            matchingEngine.convert(address(token1), address(token2), 1, true)\n        );\n\n        console.log(\n            \"minRequired base\",\n            matchingEngine.convert(address(token1), address(token2), 1, false)\n        );\n    }\n}\n"
        },
        "test/safex/orderbook/OrderMatch.t.sol": {
            "content": "pragma solidity >=0.8;\n\nimport {MockToken} from \"../../../contracts/mock/MockToken.sol\";\nimport {MockBase} from \"../../../contracts/mock/MockBase.sol\";\nimport {MockQuote} from \"../../../contracts/mock/MockQuote.sol\";\nimport {MockBTC} from \"../../../contracts/mock/MockBTC.sol\";\nimport {ErrToken} from \"../../../contracts/mock/MockTokenOver18Decimals.sol\";\nimport {Utils} from \"../../utils/Utils.sol\";\nimport {MatchingEngine} from \"../../../contracts/safex/MatchingEngine.sol\";\nimport {OrderbookFactory} from \"../../../contracts/safex/orderbooks/OrderbookFactory.sol\";\nimport {Orderbook} from \"../../../contracts/safex/orderbooks/Orderbook.sol\";\nimport {ExchangeOrderbook} from \"../../../contracts/safex/libraries/ExchangeOrderbook.sol\";\nimport {IOrderbookFactory} from \"../../../contracts/safex/interfaces/IOrderbookFactory.sol\";\nimport {WETH9} from \"../../../contracts/mock/WETH9.sol\";\nimport {Treasury} from \"../../../contracts/sabt/Treasury.sol\";\nimport {BaseSetup} from \"../OrderbookBaseSetup.sol\";\nimport {console} from \"forge-std/console.sol\";\nimport {stdStorage, StdStorage, Test} from \"forge-std/Test.sol\";\n\ncontract OrderMatchTest is BaseSetup {\n    function testRemoveHeadOnMatch() public {\n        super.setUp();\n        vm.prank(booker);\n        matchingEngine.addPair(address(token1), address(token2));\n        book = Orderbook(\n            payable(\n                orderbookFactory.getPair(address(token1), address(token2))\n            )\n        );\n        vm.prank(trader1);\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            1000e8,\n            10000e18,\n            true,\n            2,\n            0,\n            trader1\n        );\n        console.log(\"Ask Orders: \");\n        ExchangeOrderbook.Order[] memory askOrders0 = matchingEngine.getOrders(\n            address(token1),\n            address(token2),\n            false,\n            1000e8,\n            4\n        );\n        for (uint256 i = 0; i < 4; i++) {\n            console.log(askOrders0[i].owner, askOrders0[i].depositAmount);\n        }\n        vm.prank(trader1);\n        matchingEngine.limitBuy(\n            address(token1),\n            address(token2),\n            1000e8,\n            10000e18,\n            false,\n            2,\n            0,\n            trader1\n        );\n        (uint256 bidHead, uint256 askHead) = book.heads();\n        console.log(bidHead, askHead);\n        console.log(\"Ask Orders: \");\n        ExchangeOrderbook.Order[] memory askOrders = matchingEngine.getOrders(\n            address(token1),\n            address(token2),\n            false,\n            1000e8,\n            4\n        );\n        for (uint256 i = 0; i < 4; i++) {\n            console.log(askOrders[i].owner, askOrders[i].depositAmount);\n        }\n        console.log(book.isEmpty(false, 1000e8));\n        //console.log(book.checkRequired());\n        vm.prank(trader1);\n\n        matchingEngine.limitBuy(\n            address(token1),\n            address(token2),\n            1000e8,\n            10000e18,\n            true,\n            2,\n            0,\n            trader1\n        );\n    }\n\n    function testMatchOrders() public {\n        super.setUp();\n        vm.prank(booker);\n        matchingEngine.addPair(address(token1), address(token2));\n        book = Orderbook(\n            payable(\n                orderbookFactory.getPair(address(token1), address(token2))\n            )\n        );\n        vm.prank(trader2);\n        // placeBid or placeAsk two of them is using the _insertId function it will revert\n        // because the program will enter the \"if (amount > self.orders[head].depositAmount).\"\n        // statement, and eventually, it will cause an infinite loop.\n        matchingEngine.limitBuy(\n            address(token1),\n            address(token2),\n            1000e8,\n            3000e18,\n            true,\n            2,\n            0,\n            trader2\n        );\n\n        ExchangeOrderbook.Order[] memory bidOrders0 = matchingEngine.getOrders(\n            address(token1),\n            address(token2),\n            true,\n            1000e8,\n            4\n        );\n        console.log(\"Bid Orders: \");\n        for (uint256 i = 0; i < 4; i++) {\n            console.log(bidOrders0[i].owner, bidOrders0[i].depositAmount);\n        }\n\n        ExchangeOrderbook.Order[] memory askOrders0 = matchingEngine.getOrders(\n            address(token1),\n            address(token2),\n            false,\n            1000e8,\n            4\n        );\n        console.log(\"Ask Orders: \");\n        for (uint256 i = 0; i < 4; i++) {\n            console.log(askOrders0[i].owner, askOrders0[i].depositAmount);\n        }\n\n        vm.prank(trader1);\n        //vm.expectRevert(\"OutOfGas\");\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            1000e8,\n            1e18,\n            true,\n            2,\n            0,\n            trader1\n        );\n\n        ExchangeOrderbook.Order[] memory bidOrders = matchingEngine.getOrders(\n            address(token1),\n            address(token2),\n            true,\n            1000e8,\n            4\n        );\n        console.log(\"Bid Orders: \");\n        for (uint256 i = 0; i < 4; i++) {\n            console.log(bidOrders[i].owner, bidOrders[i].depositAmount);\n        }\n\n        ExchangeOrderbook.Order[] memory askOrders = matchingEngine.getOrders(\n            address(token1),\n            address(token2),\n            false,\n            1000e8,\n            4\n        );\n        console.log(\"Ask Orders: \");\n        for (uint256 i = 0; i < 4; i++) {\n            console.log(askOrders[i].owner, askOrders[i].depositAmount);\n        }\n        (uint256 bidHead, uint256 askHead) = book.heads();\n        console.log(bidHead, askHead);\n\n        vm.prank(trader2);\n        //vm.expectRevert(\"OutOfGas\");\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            1000e8,\n            1e18,\n            true,\n            2,\n            0,\n            trader2\n        );\n    }\n\n    function testAmountIsZero() public {\n        super.setUp();\n        vm.prank(booker);\n        matchingEngine.addPair(address(token1), address(token2));\n        book = Orderbook(\n            payable(\n                orderbookFactory.getPair(address(token1), address(token2))\n            )\n        );\n        vm.prank(trader1);\n        // placeBid or placeAsk two of them is using the _insertId function it will revert\n        // because the program will enter the \"if (amount > self.orders[head].depositAmount).\"\n        // statement, and eventually, it will cause an infinite loop.\n        matchingEngine.limitSell(\n            address(token1),\n            address(token2),\n            500000000,\n            10,\n            true,\n            2,\n            0,\n            trader1\n        );\n    }\n}"
        },
        "test/safex/orderbook/Pair.t.sol": {
            "content": "pragma solidity >=0.8;\n\nimport {MockToken} from \"../../../contracts/mock/MockToken.sol\";\nimport {MockBase} from \"../../../contracts/mock/MockBase.sol\";\nimport {MockQuote} from \"../../../contracts/mock/MockQuote.sol\";\nimport {MockBTC} from \"../../../contracts/mock/MockBTC.sol\";\nimport {ErrToken} from \"../../../contracts/mock/MockTokenOver18Decimals.sol\";\nimport {Utils} from \"../../utils/Utils.sol\";\nimport {MatchingEngine} from \"../../../contracts/safex/MatchingEngine.sol\";\nimport {OrderbookFactory} from \"../../../contracts/safex/orderbooks/OrderbookFactory.sol\";\nimport {Orderbook} from \"../../../contracts/safex/orderbooks/Orderbook.sol\";\nimport {ExchangeOrderbook} from \"../../../contracts/safex/libraries/ExchangeOrderbook.sol\";\nimport {IOrderbookFactory} from \"../../../contracts/safex/interfaces/IOrderbookFactory.sol\";\nimport {WETH9} from \"../../../contracts/mock/WETH9.sol\";\nimport {Treasury} from \"../../../contracts/sabt/Treasury.sol\";\nimport {BaseSetup} from \"../OrderbookBaseSetup.sol\";\nimport {console} from \"forge-std/console.sol\";\nimport {stdStorage, StdStorage, Test} from \"forge-std/Test.sol\";\n\n\ncontract PairTest is BaseSetup {\n    ErrToken public err;\n\n    function testAddPair() public {\n        // create orderbook\n        super.setUp();\n        vm.prank(booker);\n        matchingEngine.addPair(address(token1), address(token2));\n        matchingEngine.addPair(address(token2), address(token1));\n    }\n\n    function testAddPairWithOver18DecFails() public {\n        // create orderbook\n        super.setUp();\n\n        err = new ErrToken(\"Error 1\", \"ERR1\");\n        vm.prank(booker);\n        vm.expectRevert();\n        matchingEngine.addPair(address(token1), address(err));\n        vm.expectRevert();\n        matchingEngine.addPair(address(err), address(token2));\n    }\n\n    function testOrderbookAccess() public {\n        super.setUp();\n        vm.prank(booker);\n        matchingEngine.addPair(address(token1), address(token2));\n        book = Orderbook(\n            payable(\n                orderbookFactory.getPair(address(token1), address(token2))\n            )\n        );\n        vm.prank(trader1);\n        vm.expectRevert();\n        book.placeBid(trader1, 1e8, 2);\n    }\n\n    function testPairAlreadyAdded() public {\n        super.setUp();\n        vm.prank(booker);\n        MockToken token3 = new MockToken(\"Mock3\", \"MOCK3\");\n        matchingEngine.addPair(address(token1), address(token3));\n        book = Orderbook(\n            payable(\n                orderbookFactory.getPair(address(token1), address(token3))\n            )\n        );\n        vm.expectRevert();\n        matchingEngine.addPair(address(token1), address(token3));\n    }\n\n    function testPairSameBaseQuote() public {\n        super.setUp();\n        vm.prank(booker);\n        vm.expectRevert();\n        matchingEngine.addPair(address(token1), address(token1));\n    }\n\n    function testPairOrderbookQuery() public {\n        super.setUp();\n        vm.prank(booker);\n        MockToken token3 = new MockToken(\"Mock3\", \"MOCK3\");\n        matchingEngine.addPair(address(token1), address(token3));\n        book = Orderbook(\n            payable(\n                orderbookFactory.getPair(address(token1), address(token3))\n            )\n        );\n    }\n\n    function testProxyImplCorruption() public {\n        book = Orderbook(payable(orderbookFactory.impl()));\n        book.initialize(\n            0,\n            address(weth),\n            address(btc),\n            address(matchingEngine)\n        );\n        // check if generated new pair follows impl's pair state\n        MockBase mockBase2 = new MockBase(\"BASE2\", \"BASE2\");\n        address book2 = matchingEngine.addPair(\n            address(token1),\n            address(mockBase2)\n        );\n        (address bookBase, address bookQuote) = book.getBaseQuote();\n        (address book2Base, address book2Quote) = Orderbook(payable(book2))\n            .getBaseQuote();\n        assert(bookBase != book2Base);\n        assert(bookQuote != book2Quote);\n    }\n}"
        },
        "test/safex/tiered-fees/FeeTier.t.sol": {
            "content": "import {console} from \"forge-std/console.sol\";\nimport {stdStorage, StdStorage, Test} from \"forge-std/Test.sol\";\nimport {MockToken} from \"../../../contracts/mock/MockToken.sol\";\nimport {MockBase} from \"../../../contracts/mock/MockBase.sol\";\nimport {MockQuote} from \"../../../contracts/mock/MockQuote.sol\";\nimport {MockBTC} from \"../../../contracts/mock/MockBTC.sol\";\nimport {ErrToken} from \"../../../contracts/mock/MockTokenOver18Decimals.sol\";\nimport {Utils} from \"../../utils/Utils.sol\";\nimport {MatchingEngine} from \"../../../contracts/safex/MatchingEngine.sol\";\nimport {OrderbookFactory} from \"../../../contracts/safex/orderbooks/OrderbookFactory.sol\";\nimport {Orderbook} from \"../../../contracts/safex/orderbooks/Orderbook.sol\";\nimport {ExchangeOrderbook} from \"../../../contracts/safex/libraries/ExchangeOrderbook.sol\";\nimport {IOrderbookFactory} from \"../../../contracts/safex/interfaces/IOrderbookFactory.sol\";\nimport {WETH9} from \"../../../contracts/mock/WETH9.sol\";\nimport {Treasury} from \"../../../contracts/sabt/Treasury.sol\";\nimport {SAFEXFeeTierSetup} from \"../SAFEXFeeTierSetup.sol\";\n\ncontract FeeTierTest is SAFEXFeeTierSetup {\n    // After trading, TI and trader level can be shown\n\n    function _trade() internal {\n        Orderbook book = Orderbook(\n            payable(\n                orderbookFactoryFeeTier.getPair(address(feeToken), address(stablecoin))\n            )\n        );\n        vm.prank(trader2);\n        matchingEngineFeeTier.limitSell(\n            address(feeToken),\n            address(stablecoin),\n            1000e8,\n            10000e18,\n            true,\n            1,\n            0,\n            trader2\n        );\n        // match the order to make lmp so that accountant can report\n        stablecoin.mint(address(trader1), 1000000000e18);\n        vm.prank(trader1);\n        stablecoin.approve(address(matchingEngineFeeTier), 1000000000e18);\n        vm.prank(trader1);\n        matchingEngineFeeTier.limitBuy(\n            address(feeToken),\n            address(stablecoin),\n            1000e8,\n            100000e18,\n            true,\n            5,\n            1,\n            trader1\n        );\n        vm.prank(trader1);\n        matchingEngineFeeTier.limitBuy(\n            address(feeToken),\n            address(stablecoin),\n            1000e8,\n            10000000e18,\n            true,\n            5,\n            1,\n            trader1\n        );\n        vm.prank(trader1);\n        matchingEngineFeeTier.cancelOrder(\n            address(feeToken),\n            address(stablecoin),\n            true,\n            1,\n            1\n        );\n    }\n\n    function _trade2() internal {\n        Orderbook book = Orderbook(\n            payable(\n                orderbookFactoryFeeTier.getPair(address(feeToken), address(stablecoin))\n            )\n        );\n        vm.prank(trader2);\n        matchingEngineFeeTier.limitSell(\n            address(feeToken),\n            address(stablecoin),\n            1000e8,\n            10000e18,\n            true,\n            1,\n            2,\n            trader2\n        );\n        // match the order to make lmp so that accountant can report\n        stablecoin.mint(address(trader1), 1000000000e18);\n        vm.prank(trader1);\n        stablecoin.approve(address(matchingEngineFeeTier), 1000000000e18);\n        vm.prank(trader1);\n        matchingEngineFeeTier.limitBuy(\n            address(feeToken),\n            address(stablecoin),\n            1000e8,\n            100000e18,\n            true,\n            5,\n            1,\n            trader1\n        );\n        vm.prank(trader1);\n        matchingEngineFeeTier.limitBuy(\n            address(feeToken),\n            address(stablecoin),\n            1000e8,\n            10000000e18,\n            true,\n            5,\n            1,\n            trader1\n        );\n        vm.prank(trader1);\n        matchingEngineFeeTier.cancelOrder(\n            address(feeToken),\n            address(stablecoin),\n            true,\n            1,\n            1\n        );\n        feeToken.mint(trader2, 1e40);\n        vm.prank(trader2);\n        feeToken.approve(address(matchingEngineFeeTier), 1e40);\n        vm.prank(trader2);\n        matchingEngineFeeTier.limitSell(\n            address(feeToken),\n            address(stablecoin),\n            1000e8,\n            10000e18,\n            true,\n            1,\n            2,\n            trader2\n        );\n    }\n\n    function testTraderProfileShowsTIandLvl() public {\n        super.feeTierSetUp();\n        _trade();\n        uint256 point = accountant.pointOf(1, 0);\n        uint256 ti = accountant.getTI(1);\n        console.log(\"Trader 1 Trader Point:\");\n        console.log(point);\n        console.log(\"Trader 1 TI(%):\");\n        console.log(ti);\n    }\n\n    // Traders with premium accounts shows assigned level regardless of trading performance\n    function testTraderProfileShowsAssignedLvl() public {\n        super.feeTierSetUp();\n        uint256 level = accountant.levelOf(1);\n        console.log(\"Trader 1 level:\");\n        console.log(level);\n    }\n\n    function testMultipleTraderProfileShowsAssignedTIandLvl() public {\n        super.feeTierSetUp();\n        _trade2();\n        uint256 point = accountant.pointOf(1, 0);\n        uint256 ti = accountant.getTI(1);\n        console.log(\"Trader 1 Trader Point:\");\n        console.log(point);\n        console.log(\"Trader 1 TI(%):\");\n        console.log(ti);\n        uint256 point2 = accountant.pointOf(2, 0);\n        uint256 ti2 = accountant.getTI(2);\n        console.log(\"Trader 2 Trader Point:\");\n        console.log(point2);\n        console.log(\"Trader 2 TI(%):\");\n        console.log(ti2);\n    }\n}"
        },
        "test/safex/tiered-fees/ZellicSays.t.sol": {
            "content": "import {console} from \"forge-std/console.sol\";\nimport {stdStorage, StdStorage, Test} from \"forge-std/Test.sol\";\nimport {MockToken} from \"../../../contracts/mock/MockToken.sol\";\nimport {MockBase} from \"../../../contracts/mock/MockBase.sol\";\nimport {MockQuote} from \"../../../contracts/mock/MockQuote.sol\";\nimport {MockBTC} from \"../../../contracts/mock/MockBTC.sol\";\nimport {ErrToken} from \"../../../contracts/mock/MockTokenOver18Decimals.sol\";\nimport {Utils} from \"../../utils/Utils.sol\";\nimport {MatchingEngine} from \"../../../contracts/safex/MatchingEngine.sol\";\nimport {OrderbookFactory} from \"../../../contracts/safex/orderbooks/OrderbookFactory.sol\";\nimport {Orderbook} from \"../../../contracts/safex/orderbooks/Orderbook.sol\";\nimport {ExchangeOrderbook} from \"../../../contracts/safex/libraries/ExchangeOrderbook.sol\";\nimport {IOrderbookFactory} from \"../../../contracts/safex/interfaces/IOrderbookFactory.sol\";\nimport {WETH9} from \"../../../contracts/mock/WETH9.sol\";\nimport {Treasury} from \"../../../contracts/sabt/Treasury.sol\";\nimport {SAFEXFeeTierSetup} from \"../SAFEXFeeTierSetup.sol\";\n\ncontract FeeTierTest is SAFEXFeeTierSetup {\n    // After trading, TI and trader level can be shown\n\n    function _trade() internal {\n        Orderbook book = Orderbook(\n            payable(\n                orderbookFactoryFeeTier.getPair(address(feeToken), address(stablecoin))\n            )\n        );\n        vm.prank(trader2);\n        matchingEngineFeeTier.limitSell(\n            address(feeToken),\n            address(stablecoin),\n            1000e8,\n            10000e18,\n            true,\n            1,\n            0,\n            trader2\n        );\n        // match the order to make lmp so that accountant can report\n        stablecoin.mint(address(trader1), 1000000000e18);\n        vm.prank(trader1);\n        stablecoin.approve(address(matchingEngineFeeTier), 1000000000e18);\n        vm.prank(trader1);\n        matchingEngineFeeTier.limitBuy(\n            address(feeToken),\n            address(stablecoin),\n            1000e8,\n            100000e18,\n            true,\n            5,\n            1,\n            trader1\n        );\n        vm.prank(trader1);\n        matchingEngineFeeTier.limitBuy(\n            address(feeToken),\n            address(stablecoin),\n            1000e8,\n            10000000e18,\n            true,\n            5,\n            1,\n            trader1\n        );\n        vm.prank(trader1);\n        matchingEngineFeeTier.cancelOrder(\n            address(feeToken),\n            address(stablecoin),\n            true,\n            1,\n            1\n        );\n    }\n\n    function _trade2() internal {\n        Orderbook book = Orderbook(\n            payable(\n                orderbookFactoryFeeTier.getPair(address(feeToken), address(stablecoin))\n            )\n        );\n        vm.prank(trader2);\n        matchingEngineFeeTier.limitSell(\n            address(feeToken),\n            address(stablecoin),\n            1000e8,\n            10000e18,\n            true,\n            1,\n            2,\n            trader2\n        );\n        // match the order to make lmp so that accountant can report\n        stablecoin.mint(address(trader1), 1000000000e18);\n        vm.prank(trader1);\n        stablecoin.approve(address(matchingEngineFeeTier), 1000000000e18);\n        vm.prank(trader1);\n        matchingEngineFeeTier.limitBuy(\n            address(feeToken),\n            address(stablecoin),\n            1000e8,\n            100000e18,\n            true,\n            5,\n            1,\n            trader1\n        );\n        vm.prank(trader1);\n        matchingEngineFeeTier.limitBuy(\n            address(feeToken),\n            address(stablecoin),\n            1000e8,\n            10000000e18,\n            true,\n            5,\n            1,\n            trader1\n        );\n        vm.prank(trader1);\n        matchingEngineFeeTier.cancelOrder(\n            address(feeToken),\n            address(stablecoin),\n            true,\n            1,\n            1\n        );\n        feeToken.mint(trader2, 1e40);\n        vm.prank(trader2);\n        feeToken.approve(address(matchingEngineFeeTier), 1e40);\n        vm.prank(trader2);\n        matchingEngineFeeTier.limitSell(\n            address(feeToken),\n            address(stablecoin),\n            1000e8,\n            10000e18,\n            true,\n            1,\n            2,\n            trader2\n        );\n    }\n\n    function testTraderProfileShowsTIandLvl() public {\n        super.feeTierSetUp();\n        _trade();\n        uint256 point = accountant.pointOf(1, 0);\n        uint256 ti = accountant.getTI(1);\n        console.log(\"Trader 1 Trader Point:\");\n        console.log(point);\n        console.log(\"Trader 1 TI(%):\");\n        console.log(ti);\n    }\n\n    // Traders with premium accounts shows assigned level regardless of trading performance\n    function testTraderProfileShowsAssignedLvl() public {\n        super.feeTierSetUp();\n        uint256 level = accountant.levelOf(1);\n        console.log(\"Trader 1 level:\");\n        console.log(level);\n    }\n\n    function testMultipleTraderProfileShowsAssignedTIandLvl() public {\n        super.feeTierSetUp();\n        _trade2();\n        uint256 point = accountant.pointOf(1, 0);\n        uint256 ti = accountant.getTI(1);\n        console.log(\"Trader 1 Trader Point:\");\n        console.log(point);\n        console.log(\"Trader 1 TI(%):\");\n        console.log(ti);\n        uint256 point2 = accountant.pointOf(2, 0);\n        uint256 ti2 = accountant.getTI(2);\n        console.log(\"Trader 2 Trader Point:\");\n        console.log(point2);\n        console.log(\"Trader 2 TI(%):\");\n        console.log(ti2);\n    }\n}"
        },
        "test/safu/NetworkState.t.sol": {
            "content": "pragma solidity >=0.8;\n\nimport {console} from \"forge-std/console.sol\";\nimport {stdStorage, StdStorage, Test} from \"forge-std/Test.sol\";\nimport {MockToken} from \"../../contracts/mock/MockToken.sol\";\nimport {MockBase} from \"../../contracts/mock/MockBase.sol\";\nimport {MockQuote} from \"../../contracts/mock/MockQuote.sol\";\nimport {MockBTC} from \"../../contracts/mock/MockBTC.sol\";\nimport {ErrToken} from \"../../contracts/mock/MockTokenOver18Decimals.sol\";\nimport {Utils} from \"../utils/Utils.sol\";\nimport {MatchingEngine} from \"../../contracts/safex/MatchingEngine.sol\";\nimport {OrderbookFactory} from \"../../contracts/safex/orderbooks/OrderbookFactory.sol\";\nimport {Orderbook} from \"../../contracts/safex/orderbooks/Orderbook.sol\";\nimport {ExchangeOrderbook} from \"../../contracts/safex/libraries/ExchangeOrderbook.sol\";\nimport {IOrderbookFactory} from \"../../contracts/safex/interfaces/IOrderbookFactory.sol\";\nimport {WETH9} from \"../../contracts/mock/WETH9.sol\";\nimport {Treasury} from \"../../contracts/sabt/Treasury.sol\";\nimport {NetworkState} from \"../../contracts/safu/NetworkState.sol\";\n\ncontract BaseSetup is Test {\n    Utils public utils;\n    MatchingEngine public matchingEngine;\n    WETH9 public weth;\n    OrderbookFactory public orderbookFactory;\n    Orderbook public book;\n    MockBase public token1;\n    MockQuote public token2;\n    MockBTC public btc;\n    MockToken public feeToken;\n    Treasury public treasury;\n    NetworkState public networkState;\n    address payable[] public users;\n    address public trader1;\n    address public trader2;\n    address public booker;\n    address public attacker;\n\n    function setUp() public virtual {\n        utils = new Utils();\n        users = utils.createUsers(4);\n        trader1 = users[0];\n        vm.label(trader1, \"Trader 1\");\n        trader2 = users[1];\n        vm.label(trader2, \"Trader 2\");\n        booker = users[2];\n        vm.label(booker, \"Booker\");\n        attacker = users[3];\n        vm.label(attacker, \"Attacker\");\n        token1 = new MockBase(\"Base\", \"BASE\");\n        token2 = new MockQuote(\"Quote\", \"QUOTE\");\n        btc = new MockBTC(\"Bitcoin\", \"BTC\");\n        weth = new WETH9();\n\n\n        token1.mint(trader1, 10000000e18);\n        token2.mint(trader1, 10000000e18);\n        btc.mint(trader1, 10000000e18);\n        token1.mint(trader2, 10000000e18);\n        token2.mint(trader2, 10000000e18);\n        btc.mint(trader2, 10000000e18);\n        feeToken = new MockToken(\"Fee Token\", \"FEE\");\n        feeToken.mint(booker, 40000e18);\n        matchingEngine = new MatchingEngine();\n        orderbookFactory = new OrderbookFactory();\n        orderbookFactory.initialize(address(matchingEngine));\n        treasury = new Treasury();\n        treasury.set(address(0), address(0), address(0));\n        matchingEngine.initialize(\n            address(orderbookFactory),\n            address(treasury),\n            address(weth)\n        );\n\n        vm.prank(trader1);\n        token1.approve(address(matchingEngine), 10000000e18);\n        vm.prank(trader1);\n        token2.approve(address(matchingEngine), 10000000e18);\n        vm.prank(trader1);\n        btc.approve(address(matchingEngine), 10000000e18);\n        vm.prank(trader2);\n        token1.approve(address(matchingEngine), 10000000e18);\n        vm.prank(trader2);\n        token2.approve(address(matchingEngine), 10000e18);\n        vm.prank(trader2);\n        btc.approve(address(matchingEngine), 10000e8);\n\n        // deploy network state\n        networkState = new NetworkState();\n\n    }\n}\n\ncontract NetworkStateTest is BaseSetup {\n    ErrToken public err;\n\n    function testAddPair() public {\n        // create orderbook\n        super.setUp();\n        vm.prank(booker);\n        matchingEngine.addPair(address(token1), address(token2));\n        matchingEngine.addPair(address(token2), address(token1));\n    }\n\n    function testAddPairWithOver18DecFails() public {\n        // create orderbook\n        super.setUp();\n\n        err = new ErrToken(\"Error 1\", \"ERR1\");\n        vm.prank(booker);\n        vm.expectRevert();\n        matchingEngine.addPair(address(token1), address(err));\n        vm.expectRevert();\n        matchingEngine.addPair(address(err), address(token2));\n    }\n}"
        },
        "test/utils/Utils.sol": {
            "content": "pragma solidity >=0.8.17;\n\nimport {Test} from \"forge-std/Test.sol\";\n\ncontract Utils is Test {\n    bytes32 internal nextUser = keccak256(abi.encodePacked(\"user address\"));\n\n    function getNextUserAddress() external returns (address payable) {\n        address payable user = payable(address(uint160(uint256(nextUser))));\n        nextUser = keccak256(abi.encodePacked(nextUser));\n        return user;\n    }\n\n    // create users with 100 ETH balance each\n    function createUsers(uint256 userNum) external returns (address payable[] memory) {\n        address payable[] memory users = new address payable[](userNum);\n        for (uint256 i = 0; i < userNum; i++) {\n            address payable user = this.getNextUserAddress();\n            vm.deal(user, 100 ether);\n            users[i] = user;\n        }\n\n        return users;\n    }\n\n    function addUsers(uint256 userNum, address payable[] memory users) external returns (address payable[] memory) {\n        uint256 len = users.length;\n        uint256 newLen = len + userNum;\n        address payable[] memory newUsers = new address payable[](newLen);\n        for (uint256 i = 0; i < len; i++) {\n            newUsers[i] = users[i];\n        }\n        for (uint256 i = len; i < newLen; i++) {\n            address payable user = this.getNextUserAddress();\n            vm.deal(user, 100 ether);\n            newUsers[i] = user;\n        }\n        return newUsers;\n    }\n\n    // move block.number forward by a given number of blocks\n    function mineBlocks(uint256 numBlocks) external {\n        uint256 targetBlock = block.number + numBlocks;\n        vm.roll(targetBlock);\n    }\n}\n"
        }
    },
    "settings": {
        "remappings": [
            "@ensdomains/=node_modules/@ensdomains/",
            "@graphprotocol/=node_modules/@graphprotocol/",
            "@openzeppelin/=node_modules/@openzeppelin/",
            "base64-sol/=node_modules/base64-sol/",
            "ds-test/=lib/forge-std/lib/ds-test/src/",
            "eth-gas-reporter/=node_modules/eth-gas-reporter/",
            "forge-std/=lib/forge-std/src/",
            "hardhat-deploy/=node_modules/hardhat-deploy/",
            "hardhat/=node_modules/hardhat/"
        ],
        "optimizer": {
            "enabled": true,
            "runs": 200
        },
        "metadata": {
            "useLiteralContent": false,
            "bytecodeHash": "ipfs"
        },
        "outputSelection": {
            "*": {
                "": [
                    "ast"
                ],
                "*": [
                    "abi",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers",
                    "metadata"
                ]
            }
        },
        "evmVersion": "london",
        "libraries": {}
    }
}